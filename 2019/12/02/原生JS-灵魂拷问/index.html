<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/niuxinyublog/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/niuxinyublog/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/niuxinyublog/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/niuxinyublog/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/niuxinyublog/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/niuxinyublog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/niuxinyublog/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="第一篇: JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在 JS 中，存在着 7 种原始值，分别是：  boolean null undefined number string symbol bigint  引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Fun">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="原生JS 灵魂拷问">
<meta property="og:url" content="https://niuxinyu.github.io/niuxinyublog/2019/12/02/原生JS-灵魂拷问/index.html">
<meta property="og:site_name" content="niu的blog">
<meta property="og:description" content="第一篇: JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在 JS 中，存在着 7 种原始值，分别是：  boolean null undefined number string symbol bigint  引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Fun">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-2.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-3.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-5.webp">
<meta property="og:updated_time" content="2019-12-04T14:37:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="原生JS 灵魂拷问">
<meta name="twitter:description" content="第一篇: JS数据类型之问——概念篇1.JS原始数据类型有哪些？引用数据类型有哪些？在 JS 中，存在着 7 种原始值，分别是：  boolean null undefined number string symbol bigint  引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Fun">
<meta name="twitter:image" content="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE.webp">
  <link rel="canonical" href="https://niuxinyu.github.io/niuxinyublog/2019/12/02/原生JS-灵魂拷问/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>原生JS 灵魂拷问 | niu的blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/niuxinyublog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">niu的blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/niuxinyublog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/niuxinyublog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/02/原生JS-灵魂拷问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">原生JS 灵魂拷问

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-02 22:20:55" itemprop="dateCreated datePublished" datetime="2019-12-02T22:20:55+08:00">2019-12-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-04 22:37:30" itemprop="dateModified" datetime="2019-12-04T22:37:30+08:00">2019-12-04</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第一篇-JS数据类型之问——概念篇"><a href="#第一篇-JS数据类型之问——概念篇" class="headerlink" title="第一篇: JS数据类型之问——概念篇"></a>第一篇: JS数据类型之问——概念篇</h2><h3 id="1-JS原始数据类型有哪些？引用数据类型有哪些？"><a href="#1-JS原始数据类型有哪些？引用数据类型有哪些？" class="headerlink" title="1.JS原始数据类型有哪些？引用数据类型有哪些？"></a>1.JS原始数据类型有哪些？引用数据类型有哪些？</h3><p>在 JS 中，存在着 7 种原始值，分别是：</p>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
<li>bigint</li>
</ul>
<p>引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</p>
<h3 id="2-说出下面运行的结果，解释原因。"><a href="#2-说出下面运行的结果，解释原因。" class="headerlink" title="2.说出下面运行的结果，解释原因。"></a>2.说出下面运行的结果，解释原因。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.age = <span class="number">26</span></span><br><span class="line">    person = &#123;</span><br><span class="line">        name: <span class="string">'zs'</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">    name: <span class="string">'wr'</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = test(p1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1) ? </span><br><span class="line"><span class="built_in">console</span>.log(p2) ?</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1: &#123;<span class="attr">name</span>: <span class="string">'wr'</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;</span><br><span class="line">p2: &#123;<span class="attr">name</span>: <span class="string">'zs'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p>
</blockquote>
<h3 id="3-null是对象吗？为什么？"><a href="#3-null是对象吗？为什么？" class="headerlink" title="3.null是对象吗？为什么？"></a>3.null是对象吗？为什么？</h3><p>结论: null不是对象。</p>
<p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p>
<h3 id="4-’1’-toString-为什么可以调用？"><a href="#4-’1’-toString-为什么可以调用？" class="headerlink" title="4.’1’.toString()为什么可以调用？"></a>4.’1’.toString()为什么可以调用？</h3><p>其实在这个语句运行的过程中做了这样几件事情：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">'1'</span>)</span><br><span class="line">s.toString()</span><br><span class="line">s = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>第一步: 创建Object类实例。注意为什么不是String ？由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</p>
<p>第二步: 调用实例方法。</p>
<p>第三步: 执行完方法立即销毁这个实例。</p>
<p>整个过程体现了 <code>基本包装类型</code>的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</p>
<blockquote>
<p>参考:《JavaScript高级程序设计(第三版)》P118</p>
</blockquote>
<h3 id="5-0-1-0-2为什么不等于0-3？"><a href="#5-0-1-0-2为什么不等于0-3？" class="headerlink" title="5.0.1+0.2为什么不等于0.3？"></a>5.0.1+0.2为什么不等于0.3？</h3><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<h3 id="6-如何理解BigInt"><a href="#6-如何理解BigInt" class="headerlink" title="6.如何理解BigInt?"></a>6.如何理解BigInt?</h3><h4 id="什么是BigInt"><a href="#什么是BigInt" class="headerlink" title="什么是BigInt?"></a>什么是BigInt?</h4><blockquote>
<p>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对 <code>大整数</code>执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p>
</blockquote>
<h4 id="为什么需要BigInt"><a href="#为什么需要BigInt" class="headerlink" title="为什么需要BigInt?"></a>为什么需要BigInt?</h4><p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p>
<p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">999999999999999</span>) -&gt; <span class="number">10000000000000000</span></span><br></pre></td></tr></table></figure>

<p>同时也会有一定的安全性问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span>;    <span class="comment">// → true 居然是true!</span></span><br></pre></td></tr></table></figure>

<h4 id="如何创建并使用BigInt？"><a href="#如何创建并使用BigInt？" class="headerlink" title="如何创建并使用BigInt？"></a>如何创建并使用BigInt？</h4><p>要创建BigInt，只需要在数字末尾追加n即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">9007199254740995n</span> );    <span class="comment">// → 9007199254740995n</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">9007199254740995</span> );     <span class="comment">// → 9007199254740996</span></span><br></pre></td></tr></table></figure>

<p>另一种创建BigInt的方法是用BigInt()构造函数、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="string">"9007199254740995"</span>);    <span class="comment">// → 9007199254740995n</span></span><br></pre></td></tr></table></figure>

<p>简单使用如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> + <span class="number">20n</span> =&gt; <span class="number">30n</span></span><br><span class="line"><span class="number">10n</span> - <span class="number">20n</span> =&gt; <span class="number">-10n</span></span><br><span class="line">+<span class="number">10n</span> =&gt; <span class="built_in">TypeError</span>:Cannot convert a BigInt value to a number</span><br><span class="line"><span class="number">-10</span> =&gt; <span class="number">-10n</span></span><br><span class="line"><span class="number">10n</span> * <span class="number">20n</span> =&gt; <span class="number">200n</span></span><br><span class="line"><span class="number">20n</span> / <span class="number">10n</span> =&gt; <span class="number">2n</span></span><br><span class="line"><span class="number">23n</span> % <span class="number">10n</span>  =&gt; <span class="number">3n</span></span><br><span class="line"><span class="number">10n</span> ** <span class="number">3n</span> =&gt; <span class="number">1000n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">10n</span></span><br><span class="line">++<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">11n</span></span><br><span class="line">--<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">-9n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x) bigint</span><br></pre></td></tr></table></figure>

<h4 id="值得警惕的点"><a href="#值得警惕的点" class="headerlink" title="值得警惕的点"></a>值得警惕的点</h4><ol>
<li>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</li>
<li>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">10n</span> =&gt; <span class="built_in">TypeError</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">2n</span>, <span class="number">4n</span>, <span class="number">6n</span>) =&gt; <span class="built_in">TypeError</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) &#123; <span class="comment">// 判断为false</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3n</span>) &#123; <span class="comment">// 判断为true</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>元素都为BigInt的数组可以进行sort。</p>
</li>
<li><p>BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</p>
</li>
</ol>
<h2 id="第二篇-JS数据类型之问——检测篇"><a href="#第二篇-JS数据类型之问——检测篇" class="headerlink" title="第二篇: JS数据类型之问——检测篇"></a>第二篇: JS数据类型之问——检测篇</h2><h3 id="1-typeof-是否能正确判断类型？"><a href="#1-typeof-是否能正确判断类型？" class="headerlink" title="1. typeof 是否能正确判断类型？"></a>1. typeof 是否能正确判断类型？</h3><p>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> =&gt; <span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> =&gt; <span class="string">'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> =&gt; <span class="string">'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> =&gt; <span class="string">'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() =&gt; <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure>

<p>但对于引用数据类型，除了函数之外，都会显示”object”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] =&gt; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; =&gt; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log =&gt; <span class="string">'function'</span></span><br></pre></td></tr></table></figure>

<p>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'hello world'</span></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-instanceof能否判断基本数据类型？"><a href="#2-instanceof能否判断基本数据类型？" class="headerlink" title="2. instanceof能否判断基本数据类型？"></a>2. instanceof能否判断基本数据类型？</h3><p>能</p>
<p>比如下面这种方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance] (x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'number'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span> <span class="keyword">instanceof</span> PrimitiveNumber) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果你不知道Symbol，可以看看MDN上关于hasInstance的解释。</p>
<p>其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。</p>
<h3 id="3-能不能手动实现一下instanceof的功能？"><a href="#3-能不能手动实现一下instanceof的功能？" class="headerlink" title="3. 能不能手动实现一下instanceof的功能？"></a>3. 能不能手动实现一下instanceof的功能？</h3><p>核心: 原型链的向上查找。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//基本数据类型直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">'object'</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找到尽头，还没找到</span></span><br><span class="line">        <span class="keyword">if</span> (proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 找到相同的原型对象</span></span><br><span class="line">        <span class="keyword">if</span> (proto == right.prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeof(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="string">'111'</span>, <span class="built_in">String</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'111'</span>), <span class="built_in">String</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Object-is和-的区别？"><a href="#4-Object-is和-的区别？" class="headerlink" title="4. Object.is和===的区别？"></a>4. Object.is和===的区别？</h3><p>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123; </span><br><span class="line">        <span class="comment">//运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的</span></span><br><span class="line">        <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || y !== <span class="number">1</span> || <span class="number">1</span> / x === <span class="number">1</span> / y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理</span></span><br><span class="line">        <span class="comment">//两个都是NaN的时候返回true</span></span><br><span class="line">        <span class="keyword">return</span> x !== x &amp;&amp; y !== y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三篇-JS数据类型之问——转换篇"><a href="#第三篇-JS数据类型之问——转换篇" class="headerlink" title="第三篇: JS数据类型之问——转换篇"></a>第三篇: JS数据类型之问——转换篇</h2><h3 id="1-结果是什么？为什么？"><a href="#1-结果是什么？为什么？" class="headerlink" title="1. [] == ![]结果是什么？为什么？"></a>1. [] == ![]结果是什么？为什么？</h3><p>解析:</p>
<p>== 中，左右两边都需要转换为数字然后进行比较。</p>
<p>[]转换为数字为0。</p>
<p>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,</p>
<p>因此![]为false，进而在转换成数字，变为0。</p>
<p>0 == 0 ， 结果为true</p>
<h3 id="2-JS中类型转换有哪几种？"><a href="#2-JS中类型转换有哪几种？" class="headerlink" title="2. JS中类型转换有哪几种？"></a>2. JS中类型转换有哪几种？</h3><p>JS中，类型转换只有三种：</p>
<ul>
<li>转换成数字</li>
<li>转换成布尔值</li>
<li>转换成字符串</li>
</ul>
<p>转换具体规则如下:</p>
<blockquote>
<p>注意”Boolean 转字符串”这行结果指的是 true 转字符串的例子</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE.webp" alt></p>
<h3 id="3-和-有什么区别？"><a href="#3-和-有什么区别？" class="headerlink" title="3. == 和 ===有什么区别？"></a>3. == 和 ===有什么区别？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如<span class="string">'1'</span>===<span class="number">1</span>的结果是<span class="literal">false</span>，因为一边是string，另一边是number。</span><br></pre></td></tr></table></figure>

<p>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</p>
<ul>
<li>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false</li>
<li>判断的是否是null和undefined，是的话就返回true</li>
<li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较</li>
<li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li>
<li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span> :<span class="number">1</span> &#125; == <span class="string">'[object Object]'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-对象转原始类型是根据什么流程运行的？"><a href="#4-对象转原始类型是根据什么流程运行的？" class="headerlink" title="4. 对象转原始类型是根据什么流程运行的？"></a>4. 对象转原始类型是根据什么流程运行的？</h3><p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>
<ol>
<li>如果Symbol.toPrimitive()方法，优先调用再返回</li>
<li>调用valueOf()，如果转换为原始类型，则返回</li>
<li>调用toString()，如果转换为原始类型，则返回</li>
<li>如果都没有返回原始类型，会报错</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">3</span>, </span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'5'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive] () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h3 id="5-如何让if-a-1-amp-amp-a-2-条件成立？"><a href="#5-如何让if-a-1-amp-amp-a-2-条件成立？" class="headerlink" title="5. 如何让if(a == 1 &amp;&amp; a == 2)条件成立？"></a>5. 如何让if(a == 1 &amp;&amp; a == 2)条件成立？</h3><p>其实就是上一个问题的应用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.value ++</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="第四篇-谈谈你对闭包的理解"><a href="#第四篇-谈谈你对闭包的理解" class="headerlink" title="第四篇: 谈谈你对闭包的理解"></a>第四篇: 谈谈你对闭包的理解</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，</p>
<ol>
<li><code>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。</code></li>
<li></li>
<li><code>（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）</code></li>
</ol>
<h3 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因?"></a>闭包产生的原因?</h3><p>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域， <code>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链</code>，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    f2()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">        <span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>

<p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！</p>
<p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f1()</span><br><span class="line">x()</span><br></pre></td></tr></table></figure>

<p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。</p>
<p>那是不是只有返回函数才算是产生了闭包呢？、</p>
<p>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f3</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    f3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">f3() <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>

<p>让f1执行，给f3赋值后，等于说现在 <code>f3拥有了window、f1和f3本身这几个作用域的访问权限</code>，还是自底向上查找， <code>最近是在f1</code>中找到了a,因此输出2。</p>
<p>在这里是外面的变量 <code>f3存在着父级作用域的引用</code>，因此产生了闭包，形式变了，本质没有改变。</p>
<h3 id="闭包有哪些表现形式"><a href="#闭包有哪些表现形式" class="headerlink" title="闭包有哪些表现形式?"></a>闭包有哪些表现形式?</h3><p>明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？</p>
<ol>
<li>返回一个函数。刚刚已经举例。</li>
<li>作为函数参数传递</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    bar(baz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是 闭包</span></span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 输出 2 而不是 1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</li>
</ol>
<p>以下的闭包保存的仅仅是window和当前作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timerHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">1500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">'#app'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">666</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>IIFE(立即执行函数表达式)创建闭包, 保存了 <code>全局作用域window</code>和 <code>当前函数的作用域</code>，因此可以全局的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">// 6</span></span><br><span class="line">    &#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p>
<p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p>
<p>解决方法：</p>
<p>1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;= <span class="number">5</span>; i ++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、给定时器传入第三个参数, 作为timer函数的第一个函数参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; = <span class="number">5</span>; i ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j) <span class="comment">// 6</span></span><br><span class="line">    &#125;, <span class="number">1</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用ES6中的let</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; = <span class="number">5</span>; i ++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i = 1</span></span><br><span class="line">&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i = 2</span></span><br><span class="line">&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此能输出正确的结果。</p>
<h2 id="第五篇-谈谈你对原型链的理解"><a href="#第五篇-谈谈你对原型链的理解" class="headerlink" title="第五篇: 谈谈你对原型链的理解"></a>第五篇: 谈谈你对原型链的理解</h2><h3 id="1-原型对象和构造函数有何关系？"><a href="#1-原型对象和构造函数有何关系？" class="headerlink" title="1.原型对象和构造函数有何关系？"></a>1.原型对象和构造函数有何关系？</h3><p>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。</p>
<p>当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个<strong>proto</strong>属性，指向构造函数的原型对象。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-2.webp" alt="js原型对象和构造函数的关系"></p>
<h3 id="2-能不能描述一下原型链？"><a href="#2-能不能描述一下原型链？" class="headerlink" title="2.能不能描述一下原型链？"></a>2.能不能描述一下原型链？</h3><p>JavaScript对象通过prototype指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-3.webp" alt="描述原型链"></p>
<ul>
<li>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</li>
<li>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</li>
</ul>
<h2 id="第六篇-JS如何实现继承？"><a href="#第六篇-JS如何实现继承？" class="headerlink" title="第六篇: JS如何实现继承？"></a>第六篇: JS如何实现继承？</h2><h3 id="第一种-借助call"><a href="#第一种-借助call" class="headerlink" title="第一种: 借助call"></a>第一种: 借助call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Perosn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'person1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Perosn1.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1)   <span class="comment">// &#123;name: 'person1', type: 'child1'&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>
<h3 id="第二种-借助原型链"><a href="#第二种-借助原型链" class="headerlink" title="第二种: 借助原型链"></a>第二种: 借助原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'person2'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Person2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child2())</span><br><span class="line"><span class="keyword">let</span> c1 = <span class="keyword">new</span> Child2()</span><br><span class="line"><span class="built_in">console</span>.log(c1.name, c1.play)  <span class="comment">// 'person2', '[1,2,3]'</span></span><br></pre></td></tr></table></figure>

<p>看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2()</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2()</span><br><span class="line">s1.play.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s2.play) <span class="comment">// '[1,2,3,4]'</span></span><br></pre></td></tr></table></figure>

<p>明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。</p>
<p>那么还有更好的方式么？</p>
<h3 id="第三种：将前两种组合"><a href="#第三种：将前两种组合" class="headerlink" title="第三种：将前两种组合"></a>第三种：将前两种组合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'person3'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person3.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child3'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Person3()</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child3()</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child3()</span><br><span class="line">s3.play.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s3.play, s4.play)  <span class="comment">// '[1,2,3,4]', '[1,2,3]'</span></span><br></pre></td></tr></table></figure>

<p>之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？</p>
<h3 id="第四种-组合继承的优化1"><a href="#第四种-组合继承的优化1" class="headerlink" title="第四种: 组合继承的优化1"></a>第四种: 组合继承的优化1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'person4'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person4.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child4'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child4.prototype = Person4.prototype</span><br></pre></td></tr></table></figure>

<p>这里将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child4()</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child4()</span><br><span class="line"><span class="built_in">console</span>.log(s1) <span class="comment">// &#123;name: 'person4', play: [1,2,3], type: 'child4'&#125;</span></span><br></pre></td></tr></table></figure>

<p>控制台显示</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E5%8E%9F%E7%94%9Fjs%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-5.webp" alt="控制台显示-1"></p>
<p>子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。</p>
<h3 id="第五种-最推荐使用-组合继承的优化1"><a href="#第五种-最推荐使用-组合继承的优化1" class="headerlink" title="第五种(最推荐使用): 组合继承的优化1"></a>第五种(最推荐使用): 组合继承的优化1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'person5'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person5.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child5'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child5.prototype = <span class="built_in">Object</span>.create(Person5.prototype)</span><br><span class="line">Child5.prototype.constructor = Child5</span><br></pre></td></tr></table></figure>

<p>这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。</p>
<h3 id="ES6的extends被编译后的JavaScript代码"><a href="#ES6的extends被编译后的JavaScript代码" class="headerlink" title="ES6的extends被编译后的JavaScript代码"></a>ES6的extends被编译后的JavaScript代码</h3><p>ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。</p>
<p>那最后编译成了什么样子呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span> (<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">'object'</span> || <span class="keyword">typeof</span> call === <span class="string">'function'</span>) ? call : self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span> (<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(subClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (subClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 验证是否是 Parent 创造出来的 this</span></span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = (<span class="function"><span class="keyword">function</span>(<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">    _inherits(Child, _Parent)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Child)</span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (Child.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(Child).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Child</span><br><span class="line">&#125;)(Parent)</span><br></pre></td></tr></table></figure>

<p>核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个Object.setPrototypeOf(subClass, superClass)，这是用来干啥的呢？</p>
<p>答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。</p>
<blockquote>
<p>追问: 面向对象的设计一定是好的设计吗？</p>
</blockquote>
<p>不一定。从继承的角度说，这一设计是存在巨大隐患的。</p>
<h3 id="从设计思想上谈谈继承本身的问题"><a href="#从设计思想上谈谈继承本身的问题" class="headerlink" title="从设计思想上谈谈继承本身的问题"></a>从设计思想上谈谈继承本身的问题</h3><p>假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    drive () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开车了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    music () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'放歌了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    addOil () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'加油了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">otherCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以实现车的功能，并且以此去扩展不同的车。</p>
<p>但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。</p>
<p>如果让新能源汽车的类继承Car的话，也是有问题的，俗称”大猩猩和香蕉”的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。</p>
<blockquote>
<p>继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。</p>
</blockquote>
<p>当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类， <code>代码势必会大量重复</code>，另一方面一旦子类有所变动，父类也要进行相应的更新， <code>代码的耦合性太高</code>，维护性不好。</p>
<p>那如何来解决继承的诸多问题呢？</p>
<p>用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。</p>
<p>顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开车了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">music</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'听歌了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOil</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加油了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = compose(drive, music, addOil)</span><br><span class="line"><span class="keyword">let</span> newEnergyCar  = compose(drive, music)</span><br></pre></td></tr></table></figure>

<p>代码干净，复用性也很好。这就是面向组合的设计方式。</p>
<p>参考出处:</p>
<p>ES5实现继承那些事</p>
<p>重学JS系列:聊聊继承</p>
<p>JS最新基本数据类型:BigInt(译)</p>
<p>yck前端面试之道</p>
<p>  <a href="https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&mid=2247484290&idx=1&sn=26b23f21dcf039475f4475db33763934&chksm=ebf9f458dc8e7d4edf74e3987be8bf5dd4c6aeed995e0dfd3739f9b6e21b149995feb3ce9ba9&mpshare=1&scene=1&srcid=111121LXW6I963MP5lBl22Vj&sharer_sharetime=1573522278024&sharer_shareid=98eb99fae9cd4538d3b529f0e32ecae5&key=cc71a6f79ee0f17487282fe93ccb10d20351081d76e41b16271debf0d2b6c8f6ec2754ae502008a0586f738aa84bf886c768ba2dbf5e74753e58b7db3939055c6cd18b84ea87283746086029f1bb80b6&ascene=1&uin=MTUwMjEzNDI3NQ%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=AYpG2ejwozJPkwG9cq9MjXs%3D&pass_ticket=xkzNoP55fnFctkcYTyBzYi6NTqkBjJNw%2FHUmLeNbzgtXX7R5u5UtsNF23unCR86y" target="_blank" rel="noopener">原文地址</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/niuxinyublog/tags/JS/" rel="tag"># JS</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/niuxinyublog/2019/12/02/前端小技巧/" rel="next" title="前端小技巧">
                  <i class="fa fa-chevron-left"></i> 前端小技巧
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/niuxinyublog/2019/12/04/JS-中获取对象属性的-和-之间的区别/" rel="prev" title="JS 中获取对象属性的 . 和 [] 之间的区别">
                  JS 中获取对象属性的 . 和 [] 之间的区别 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一篇-JS数据类型之问——概念篇"><span class="nav-number">1.</span> <span class="nav-text">第一篇: JS数据类型之问——概念篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JS原始数据类型有哪些？引用数据类型有哪些？"><span class="nav-number">1.1.</span> <span class="nav-text">1.JS原始数据类型有哪些？引用数据类型有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-说出下面运行的结果，解释原因。"><span class="nav-number">1.2.</span> <span class="nav-text">2.说出下面运行的结果，解释原因。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-null是对象吗？为什么？"><span class="nav-number">1.3.</span> <span class="nav-text">3.null是对象吗？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-’1’-toString-为什么可以调用？"><span class="nav-number">1.4.</span> <span class="nav-text">4.’1’.toString()为什么可以调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-0-1-0-2为什么不等于0-3？"><span class="nav-number">1.5.</span> <span class="nav-text">5.0.1+0.2为什么不等于0.3？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-如何理解BigInt"><span class="nav-number">1.6.</span> <span class="nav-text">6.如何理解BigInt?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是BigInt"><span class="nav-number">1.6.1.</span> <span class="nav-text">什么是BigInt?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要BigInt"><span class="nav-number">1.6.2.</span> <span class="nav-text">为什么需要BigInt?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建并使用BigInt？"><span class="nav-number">1.6.3.</span> <span class="nav-text">如何创建并使用BigInt？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值得警惕的点"><span class="nav-number">1.6.4.</span> <span class="nav-text">值得警惕的点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二篇-JS数据类型之问——检测篇"><span class="nav-number">2.</span> <span class="nav-text">第二篇: JS数据类型之问——检测篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-typeof-是否能正确判断类型？"><span class="nav-number">2.1.</span> <span class="nav-text">1. typeof 是否能正确判断类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-instanceof能否判断基本数据类型？"><span class="nav-number">2.2.</span> <span class="nav-text">2. instanceof能否判断基本数据类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-能不能手动实现一下instanceof的功能？"><span class="nav-number">2.3.</span> <span class="nav-text">3. 能不能手动实现一下instanceof的功能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Object-is和-的区别？"><span class="nav-number">2.4.</span> <span class="nav-text">4. Object.is和===的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三篇-JS数据类型之问——转换篇"><span class="nav-number">3.</span> <span class="nav-text">第三篇: JS数据类型之问——转换篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-结果是什么？为什么？"><span class="nav-number">3.1.</span> <span class="nav-text">1. [] == ![]结果是什么？为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JS中类型转换有哪几种？"><span class="nav-number">3.2.</span> <span class="nav-text">2. JS中类型转换有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-和-有什么区别？"><span class="nav-number">3.3.</span> <span class="nav-text">3. == 和 ===有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-对象转原始类型是根据什么流程运行的？"><span class="nav-number">3.4.</span> <span class="nav-text">4. 对象转原始类型是根据什么流程运行的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-如何让if-a-1-amp-amp-a-2-条件成立？"><span class="nav-number">3.5.</span> <span class="nav-text">5. 如何让if(a == 1 &amp;&amp; a == 2)条件成立？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四篇-谈谈你对闭包的理解"><span class="nav-number">4.</span> <span class="nav-text">第四篇: 谈谈你对闭包的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是闭包？"><span class="nav-number">4.1.</span> <span class="nav-text">什么是闭包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包产生的原因"><span class="nav-number">4.2.</span> <span class="nav-text">闭包产生的原因?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包有哪些表现形式"><span class="nav-number">4.3.</span> <span class="nav-text">闭包有哪些表现形式?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五篇-谈谈你对原型链的理解"><span class="nav-number">5.</span> <span class="nav-text">第五篇: 谈谈你对原型链的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-原型对象和构造函数有何关系？"><span class="nav-number">5.1.</span> <span class="nav-text">1.原型对象和构造函数有何关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-能不能描述一下原型链？"><span class="nav-number">5.2.</span> <span class="nav-text">2.能不能描述一下原型链？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六篇-JS如何实现继承？"><span class="nav-number">6.</span> <span class="nav-text">第六篇: JS如何实现继承？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种-借助call"><span class="nav-number">6.1.</span> <span class="nav-text">第一种: 借助call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种-借助原型链"><span class="nav-number">6.2.</span> <span class="nav-text">第二种: 借助原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三种：将前两种组合"><span class="nav-number">6.3.</span> <span class="nav-text">第三种：将前两种组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四种-组合继承的优化1"><span class="nav-number">6.4.</span> <span class="nav-text">第四种: 组合继承的优化1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五种-最推荐使用-组合继承的优化1"><span class="nav-number">6.5.</span> <span class="nav-text">第五种(最推荐使用): 组合继承的优化1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6的extends被编译后的JavaScript代码"><span class="nav-number">6.6.</span> <span class="nav-text">ES6的extends被编译后的JavaScript代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从设计思想上谈谈继承本身的问题"><span class="nav-number">6.7.</span> <span class="nav-text">从设计思想上谈谈继承本身的问题</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Niu</p>
  <div class="site-description" itemprop="description">文章</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/niuxinyublog/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Niu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/niuxinyublog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/niuxinyublog/js/utils.js?v=7.4.0"></script><script src="/niuxinyublog/js/motion.js?v=7.4.0"></script>
<script src="/niuxinyublog/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/niuxinyublog/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
