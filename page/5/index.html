<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/niuxinyublog/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/niuxinyublog/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/niuxinyublog/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/niuxinyublog/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/niuxinyublog/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/niuxinyublog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/niuxinyublog/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="文章">
<meta property="og:type" content="website">
<meta property="og:title" content="niu的blog">
<meta property="og:url" content="https://niuxinyu.github.io/niuxinyublog/page/5/index.html">
<meta property="og:site_name" content="niu的blog">
<meta property="og:description" content="文章">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="niu的blog">
<meta name="twitter:description" content="文章">
  <link rel="canonical" href="https://niuxinyu.github.io/niuxinyublog/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>niu的blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/niuxinyublog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">niu的blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/niuxinyublog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/niuxinyublog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/11/26/post-1-5万字概括ES6全部特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/11/26/post-1-5万字概括ES6全部特性/" class="post-title-link" itemprop="url">post-1.5万字概括ES6全部特性</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-26 21:46:36 / 修改时间：22:55:54" itemprop="dateCreated datePublished" datetime="2019-11-26T21:46:36+08:00">2019-11-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#35b378">前言</font></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下提到的《ECMAScript 6 入门》统一使用《ES6》这个名称来代替，而最新的ES6版本也是截止到当前的ES2019.</span><br></pre></td></tr></table></figure>

<p>本文的知识点完全是参考或摘录《ES6》里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照《ES6》的内容来学习。</p>
<p>本文整理出来的笔记都是书中的精华内容，囊括了整个<font color="#35b378"><code>ES6体系</code></font>的所有特性，非常方便大家重新认识<font color="#35b378"><code>全部ES6特性</code></font>。半小时的阅读就可以对<font color="#35b378"><code>ES6</code></font>有一个全面的了解，可以认为是一本<font color="#35b378"><code>ES6特性小字典</code></font>，收藏后可随时查阅。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/ES6%E6%A6%82%E6%8B%AC.webp" alt="ES6缩略"></p>
<h1 id="修正"><a href="#修正" class="headerlink" title="修正"></a><font color="#35b378">修正</font></h1><p><strong>ES6</strong>是<code>ECMA</code> 为 <code>JavaScript</code>制定的第6个标准版本，相关历史可查看此章节《ES6-ECMAScript6简介》。</p>
<p>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在<code>2015年6月</code>发布ES6的第一个版本。以此类推，<code>ECMAscript 2016</code>是ES6的第二个版本、 <code>ECMAscript 2017</code>是ES6的第三个版本。<strong>ES6</strong>既是一个历史名词也是一个泛指，含义是<code>5.1版本</code>以后的<code>JavaScript下一代标准</code>，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>。</p>
<p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>(ES6.0)、<strong>ES2016</strong>(ES6.1)、<strong>ES2017</strong>(ES6.2)、<strong>ES2018</strong>(ES6.3)、<strong>ES2019</strong>(ES6.4)。</p>
<p>另外，ES6更新的内容主要分为以下几点</p>
<ul>
<li><strong>表达式</strong>：声明、解构赋值</li>
<li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li>
<li><strong>语句与运算</strong>：Class、Module、Iterator</li>
<li><strong>异步编程</strong>：Promise、Generator、Async</li>
</ul>
<h1 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a><strong><font color="#35b378">ES2015</font></strong></h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a><code>声明</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>const命令</strong>：声明常量</li>
<li><input checked disabled type="checkbox"> <strong>let命令</strong>：声明变量</li>
</ul>
<blockquote>
<p>作用</p>
</blockquote>
<ul>
<li><p>作用域</p>
</li>
<li><ul>
<li><strong>全局作用域</strong></li>
<li><strong>函数作用域</strong>：<code>function() {}</code></li>
<li><strong>块级作用域</strong>：<code>{}</code></li>
</ul>
</li>
<li><p>作用范围</p>
</li>
<li><ul>
<li><code>var</code>在全局代码中执行</li>
<li><code>const</code>和<code>let</code>只能在代码块中执行</li>
</ul>
</li>
<li><p>赋值使用</p>
</li>
<li><ul>
<li><code>const</code>声明常量后必须立马赋值</li>
<li><code>let</code>声明变量后可立马赋值或使用时赋值</li>
</ul>
</li>
<li><p>声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></p>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>不允许重复声明</li>
<li>未定义就使用会报错：<code>const</code>和<code>let</code>不存在变量提升</li>
<li>暂时性死区：只要块级作用域内存在<code>const</code>和<code>let</code>，所声明常量和变量就绑定此区域，不再受外部影响</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><code>解构赋值</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>数值解构</strong>：<code>const { toString: s } = 123</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>布尔值解构</strong>：<code>const { toString: b } = true</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>对象解构</strong></p>
</li>
<li><ul>
<li>形式：<code>const { x, y } = { x: 1, y: 2 }</code></li>
<li>默认：<code>const { x, y = 2 } = { x: 1 }</code></li>
<li>改名：<code>const { x, y: z } = { x: 1, y: 2 }</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>数组解构</strong></p>
</li>
<li><ul>
<li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li>
<li>形式：<code>const [x, y] = [1, 2]</code></li>
<li>默认：<code>const [x, y = 2] = [1]</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>函数参数解构</strong></p>
</li>
<li><ul>
<li>数组解构：<code>function Func([x = 0, y = 1]) {}</code></li>
<li>对象解构：<code>function Func({ x = 0, y = 1 } = {}) {}</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>交换变量值：<code>[x, y] = [y, x]</code></li>
<li>返回函数多个值：<code>const [x, y, z] = Func()</code></li>
<li>定义函数参数：<code>Func([1, 2])</code></li>
<li>提取JSON数据：<code>const { name, version } = packageJson</code></li>
<li>定义函数参数默认值：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li>
<li>遍历Map结构：<code>for (let [k, v] of Map) {}</code></li>
<li>输入模块指定属性和方法：<code>const { readFile, writeFile } = require(&quot;fs&quot;)</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li>
<li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li>
<li>解构默认值生效条件：属性值严格等于<code>undefined</code></li>
<li>解构遵循匹配模式</li>
<li>解构不成功时变量的值等于<code>undefined</code></li>
<li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li>
</ul>
<h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a><code>字符串扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u{0xXX}</code>或<code>\u{0XXX}</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>标签模板</strong>：函数参数的特殊调用</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>String.raw()</strong>：返回把字符串所有变量替换且对斜杠进行转义的结果</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>String.fromCodePoint()</strong>：返回码点对应字符</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>codePointAt()</strong>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>normalize()</strong>：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(Unicode正规化)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>repeat()</strong>：把字符串重复n次，返回<code>新字符串</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>matchAll()</strong>：返回正则表达式在字符串的所有匹配</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>includes()</strong>：是否存在指定字符串</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>startsWith()</strong>：是否存在字符串头部指定字符串</p>
<p>[x]<strong>endsWith()</strong>：是否存在字符串尾部指定字符串</p>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<p>以上扩展方法均可作用于由<code>4个字节储存</code>的<code>Unicode字符</code>上</p>
<h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a><code>数值扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><input checked disabled type="checkbox"> <strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Number.EPSILON</strong>：数值最小精度</li>
<li><input checked disabled type="checkbox"> <strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Number.parseInt()</strong>：返回转换值的整数部分</li>
<li><input checked disabled type="checkbox"> <strong>Number.parseFloat()</strong>：返回转换值的浮点数部分</li>
<li><input checked disabled type="checkbox"> <strong>Number.isFinite()</strong>：是否为有限数值</li>
<li><input checked disabled type="checkbox"> <strong>Number.isNaN()</strong>：是否为NaN</li>
<li><input checked disabled type="checkbox"> <strong>Number.isInteger()</strong>：是否为整数</li>
<li><input checked disabled type="checkbox"> <strong>Number.isSafeInteger()</strong>：是否在数值安全范围内</li>
<li><input checked disabled type="checkbox"> <strong>Math.trunc()</strong>：返回数值整数部分</li>
<li><input checked disabled type="checkbox"> <strong>Math.sign()</strong>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Math.cbrt()</strong>：返回数值立方根</li>
<li><input checked disabled type="checkbox"> <strong>Math.clz32()</strong>：返回数值的32位无符号整数形式</li>
<li><input checked disabled type="checkbox"> <strong>Math.imul()</strong>：返回两个数值相乘</li>
<li><input checked disabled type="checkbox"> <strong>Math.fround()</strong>：返回数值的32位单精度浮点数形式</li>
<li><input checked disabled type="checkbox"> <strong>Math.hypot()</strong>：返回所有数值平方和的平方根</li>
<li><input checked disabled type="checkbox"> <strong>Math.expm1()</strong>：返回<code>e^n - 1</code></li>
<li><input checked disabled type="checkbox"> <strong>Math.log1p()</strong>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Math.log10()</strong>：返回以10为底的n的对数</li>
<li><input checked disabled type="checkbox"> <strong>Math.log2()</strong>：返回以2为底的n的对数</li>
<li><input checked disabled type="checkbox"> <strong>Math.sinh()</strong>：返回n的双曲正弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.cosh()</strong>：返回n的双曲余弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.tanh()</strong>：返回n的双曲正切</li>
<li><input checked disabled type="checkbox"> <strong>Math.asinh()</strong>：返回n的反双曲正弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.acosh()</strong>：返回n的反双曲余弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.atanh()</strong>：返回n的反双曲正切</li>
</ul>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a><code>对象扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>简洁表示法</strong>：直接写入变量和函数作为对象的属性和方法(<code>{ prop, method() {} }</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>方法的name属性</strong>：返回方法函数名</p>
</li>
<li><ul>
<li>取值函数(getter)和存值函数(setter)：<code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li>
<li>bind返回的函数：<code>bound 函数名</code></li>
<li>Function构造函数返回的函数实例：<code>anonymous</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() {}</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.is()</strong>：对比两值是否相等</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.assign()</strong>：合并对象(浅拷贝)，返回原对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.getPrototypeOf()</strong>：返回对象的原型对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.setPrototypeOf()</strong>：设置对象的原型对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong><strong>proto</strong></strong>：返回或设置对象的原型对象</p>
</li>
</ul>
<blockquote>
<p>属性遍历</p>
</blockquote>
<ul>
<li><p>描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></p>
</li>
<li><p>遍历</p>
</li>
<li><ul>
<li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li>
<li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性的键组成的数组</li>
<li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身可继承可枚举非枚举</code>属性的键组成的数组</li>
<li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>Symbol</code>属性的键组成的数组</li>
<li><code>Reflect.ownKeys()</code>：返回对象<code>自身可继承可枚举非枚举Symbol</code>属性的键组成的数组</li>
</ul>
</li>
<li><p>规则</p>
</li>
<li><ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有Symbol键，按照加入时间升序排列</li>
</ul>
</li>
</ul>
<h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a><code>数组扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>扩展运算符(…)</strong>：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Array.from()</strong>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组</p>
</li>
<li><ul>
<li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li>
<li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Array.of()</strong>：转换一组值为真正数组，返回新数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>copyWithin()</strong>：把指定位置的成员复制到其他位置，返回原数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>find()</strong>：返回第一个符合条件的成员</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>keys()</strong>：返回以索引值为遍历器的对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>values()</strong>：返回以属性值为遍历器的对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>entries()</strong>：返回以索引值和属性值为遍历器的对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>数组空位</strong>：ES6明确将数组空位转为<code>undefined</code>(空位处理规不一，建议避免出现</p>
</li>
</ul>
<blockquote>
<p>扩展应用</p>
</blockquote>
<ul>
<li>克隆数组：<code>const arr = [...arr1]</code></li>
<li>合并数组：<code>const arr = [...arr1, ...arr2]</code></li>
<li>拼接数组：<code>arr.push(...arr1)</code></li>
<li>代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li>
<li>转换字符串为数组：<code>[...&quot;hello&quot;]</code></li>
<li>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li>
<li>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li>
<li>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li>
<li>计算Unicode字符长度：<code>Array.from(&quot;hello&quot;).length</code> =&gt; <code>[...&quot;hello&quot;].length</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<p>使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</p>
<h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a><code>函数扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>参数默认值</strong>：为函数参数指定默认值</p>
</li>
<li><ul>
<li>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) {}</code></li>
<li>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li>
<li>形式：<code>function Func(x = 1, y = 2) {}</code></li>
<li>参数赋值：惰性求值(函数调用后才求值)</li>
<li>参数位置：尾参数</li>
<li>参数作用域：函数作用域</li>
<li>声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li>
<li>length：返回没有指定默认值的参数个数</li>
<li>与解构赋值默认值结合：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li>
<li>应用</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>rest/spread参数(…)</strong>：返回函数多余参数</p>
</li>
<li><ul>
<li>形式：以数组的形式存在，之后不能再有其他参数</li>
<li>作用：代替<code>Arguments对象</code></li>
<li>length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>严格模式</strong>：在严格条件下运行JS</p>
</li>
<li><ul>
<li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>name属性</strong>：返回函数的函数名</p>
</li>
<li><ul>
<li>将匿名函数赋值给变量：<code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li>
<li>将具名函数赋值给变量：<code>函数名</code>(<strong>ES5和ES6</strong>)</li>
<li>bind返回的函数：<code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li>
<li>Function构造函数返回的函数实例：<code>anonymous</code>(<strong>ES5和ES6</strong>)</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>箭头函数(=&gt;)</strong>：函数简写</p>
</li>
<li><ul>
<li>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li>
<li>因为没有<code>this</code>，因此不能用作构造函数</li>
<li>无参数：<code>() =&gt; {}</code></li>
<li>单个参数：<code>x =&gt; {}</code></li>
<li>多个参数：<code>(x, y) =&gt; {}</code></li>
<li>解构参数：<code>({x, y}) =&gt; {}</code></li>
<li>嵌套使用：部署管道机制</li>
<li>this指向固定化</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>尾调用优化</strong>：只保留内层函数的调用帧</p>
</li>
<li><ul>
<li>定义：函数尾调用自身</li>
<li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li>
<li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li>
<li>定义：某个函数的最后一步是调用另一个函数</li>
<li>形式：<code>function f(x) { return g(x); }</code></li>
<li>尾调用</li>
<li>尾递归</li>
</ul>
</li>
</ul>
<blockquote>
<p>箭头函数误区</p>
</blockquote>
<ul>
<li>函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li>
<li>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li>
<li>不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new命令</code></li>
<li>不可使用<code>yield命令</code>，因此箭头函数不能用作<code>Generator函数</code></li>
<li>不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li>
<li>返回对象时必须在对象外面加上括号</li>
</ul>
<p>##　<code>正则扩展</code></p>
<ul>
<li><input checked disabled type="checkbox"> <p><strong>变更RegExp构造函数入参</strong>：允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>u修饰符</strong>：Unicode模式修饰符，正确处理大于<code>\uFFFF</code>的<code>Unicode字符</code></p>
</li>
<li><ul>
<li><code>点字符</code>(.)</li>
<li><code>Unicode表示法</code></li>
<li><code>量词</code></li>
<li><code>预定义模式</code></li>
<li><code>i修饰符</code></li>
<li><code>转义</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>unicode</strong>：是否设置<code>u修饰符</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>sticky</strong>：是否设置<code>y修饰符</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>flags</strong>：正则表达式的修饰符</p>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><code>y修饰符</code>隐含头部匹配标志<code>^</code></li>
<li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><code>Symbol</code></h2><ul>
<li><p>定义：独一无二的值</p>
</li>
<li><p>声明：<code>const set = Symbol(str)</code></p>
</li>
<li><p>入参：字符串(可选)</p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>Symbol()</strong>：创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</li>
<li><strong>Symbol.for()</strong>：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</li>
<li><strong>Symbol.keyFor()</strong>：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li>
<li><strong>Object.getOwnPropertySymbols()</strong>：返回对象中所有用作属性名的<code>Symbol值</code>的数组</li>
</ul>
</li>
<li><p>内置</p>
</li>
<li><ul>
<li><strong>Symbol.hasInstance</strong>：指向一个内部方法，当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li>
<li><strong>Symbol.isConcatSpreadable</strong>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li>
<li><strong>Symbol.species</strong>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li><strong>Symbol.match</strong>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li>
<li><strong>Symbol.replace</strong>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li>
<li><strong>Symbol.search</strong>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li>
<li><strong>Symbol.split</strong>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li>
<li><strong>Symbol.iterator</strong>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li>
<li><strong>Symbol.toPrimitive</strong>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li><strong>Symbol.toStringTag</strong>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li>
<li><strong>Symbol.unscopables</strong>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据类型</p>
</blockquote>
<ul>
<li><strong>Undefined</strong></li>
<li><strong>Null</strong></li>
<li><strong>String</strong></li>
<li><strong>Number</strong></li>
<li><strong>Boolean</strong></li>
<li><strong>Object</strong>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li>
<li><strong>Symbol</strong></li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回</li>
<li>启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，使用<code>Symbol.for()</code>来模拟全局的<code>Singleton模式</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前不能使用<code>new命令</code></li>
<li><code>Symbol()</code>参数表示对当前<code>Symbol值</code>的描述，相同参数的<code>Symbol()</code>返回值不相等</li>
<li><code>Symbol值</code>不能与其他类型的值进行运算</li>
<li><code>Symbol值</code>可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li>
<li><code>Symbol值</code>作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li><code>Symbol值</code>作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(<code>.</code>)读取</li>
<li><code>Symbol值</code>作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义<code>非私有但又只用于内部的方法</code></li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h2><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul>
<li><p>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</p>
</li>
<li><p>声明：<code>const set = new Set(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回Set</li>
<li><strong>size</strong>：返回实例成员总数</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>add()</strong>：添加值，返回实例</li>
<li><strong>delete()</strong>：删除值，返回布尔值</li>
<li><strong>has()</strong>：检查值，返回布尔值</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>values()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li><p>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></p>
</li>
<li><p>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></p>
</li>
<li><p>集合数组</p>
</li>
<li><ul>
<li>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li>
<li>并集：<code>new Set([...a, ...b])</code></li>
<li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li>
<li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li>
</ul>
</li>
<li><p>映射集合</p>
</li>
<li><ul>
<li>声明：<code>let set = new Set(arr)</code></li>
<li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li>
<li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li>
</ul>
<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><ul>
<li><p>定义：和Set结构类似，成员值只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakSet(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回WeakSet</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>add()</strong>：添加值，返回实例</li>
<li><strong>delete()</strong>：删除值，返回布尔值</li>
<li><strong>has()</strong>：检查值，返回布尔值</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><h5 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h5><ul>
<li><p>定义：类似于对象的数据结构，成员键可以是任何类型的值</p>
</li>
<li><p>声明：<code>const set = new Map(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回Map</li>
<li><strong>size</strong>：返回实例成员总数</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>get()</strong>：返回键值对</li>
<li><strong>set()</strong>：添加键值对，返回实例</li>
<li><strong>delete()</strong>：删除键值对，返回布尔值</li>
<li><strong>has()</strong>：检查键值对，返回布尔值</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以键为遍历器的对象</li>
<li><strong>values()</strong>：返回以值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以键和值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li>
<li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li>
</ul>
<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><ul>
<li><p>定义：和Map结构类似，成员键只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakMap(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回WeakMap</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>get()</strong>：返回键值对</li>
<li><strong>set()</strong>：添加键值对，返回实例</li>
<li><strong>delete()</strong>：删除键值对，返回布尔值</li>
<li><strong>has()</strong>：检查键值对，返回布尔值</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><code>Proxy</code></h2><ul>
<li><p>定义：修改某些操作的默认行为</p>
</li>
<li><p>声明：<code>const proxy = new Proxy(target, handler)</code></p>
</li>
<li><p>入参</p>
</li>
<li><ul>
<li><strong>target</strong>：拦截的目标对象</li>
<li><strong>handler</strong>：定制拦截行为</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>Proxy.revocable()</strong>：返回可取消的Proxy实例(返回<code>{ proxy, revoke }</code>，通过revoke()取消代理)</li>
</ul>
</li>
<li><p>拦截方式</p>
</li>
<li><ul>
<li><strong>get()</strong>：拦截对象属性读取</li>
<li><strong>set()</strong>：拦截对象属性设置，返回布尔值</li>
<li><strong>has()</strong>：拦截对象属性检查<code>k in obj</code>，返回布尔值</li>
<li><strong>deleteProperty()</strong>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</li>
<li><strong>defineProperty()</strong>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</li>
<li><strong>ownKeys()</strong>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li>
<li><strong>getOwnPropertyDescriptor()</strong>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li>
<li><strong>getPrototypeOf()</strong>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li>
<li><strong>setPrototypeOf()</strong>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</li>
<li><strong>isExtensible()</strong>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</li>
<li><strong>preventExtensions()</strong>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</li>
<li><strong>apply()</strong>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li>
<li><strong>construct()</strong>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li>
<li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li>
<li><code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li>
<li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li>
<li><code>deleteProperty()</code>：保护内部属性不被删除</li>
<li><code>defineProperty()</code>：阻止属性被外部定义</li>
<li><code>ownKeys()</code>：保护内部属性不被遍历</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>要使<code>Proxy</code>起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li>
<li>没有设置任何拦截时，等同于<code>直接通向原对象</code></li>
<li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li>
<li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li>
</ul>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a><code>Reflect</code></h2><ul>
<li><p>定义：保持<code>Object方法</code>的默认行为</p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>get()</strong>：返回对象属性</li>
<li><strong>set()</strong>：设置对象属性，返回布尔值</li>
<li><strong>has()</strong>：检查对象属性，返回布尔值</li>
<li><strong>deleteProperty()</strong>：删除对象属性，返回布尔值</li>
<li><strong>defineProperty()</strong>：定义对象属性，返回布尔值</li>
<li><strong>ownKeys()</strong>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li>
<li><strong>getOwnPropertyDescriptor()</strong>：返回对象属性描述，返回对象</li>
<li><strong>getPrototypeOf()</strong>：返回对象原型，返回对象</li>
<li><strong>setPrototypeOf()</strong>：设置对象原型，返回布尔值</li>
<li><strong>isExtensible()</strong>：返回对象是否可扩展，返回布尔值</li>
<li><strong>preventExtensions()</strong>：设置对象不可扩展，返回布尔值</li>
<li><strong>apply()</strong>：绑定this后执行指定函数</li>
<li><strong>construct()</strong>：调用构造函数创建实例</li>
</ul>
</li>
</ul>
<blockquote>
<p>设计目的</p>
</blockquote>
<ul>
<li>将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li>
<li>将某些Object方法报错情况改成返回<code>false</code></li>
<li>让<code>Object操作</code>变成<code>函数行为</code></li>
<li><code>Proxy</code>与<code>Reflect</code>相辅相成</li>
</ul>
<blockquote>
<p>废弃方法</p>
</blockquote>
<ul>
<li><code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li>
<li><code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li>
<li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li>
</ul>
<blockquote>
<p>数据绑定：观察者模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observerQueue = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> observerQueue.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>(tgt, key, val, receiver) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123; <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">name</span>: <span class="string">"Yajun"</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> is <span class="subst">$&#123;person.age&#125;</span> years old`</span>);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">"Joway"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a><code>Class</code></h2><ul>
<li><p>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</p>
</li>
<li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p>
</li>
<li><p>方法和关键字</p>
</li>
<li><ul>
<li><strong>constructor()</strong>：构造函数，<code>new命令</code>生成实例时自动调用</li>
<li><strong>extends</strong>：继承父类</li>
<li><strong>super</strong>：新建父类的<code>this</code></li>
<li><strong>static</strong>：定义静态属性方法</li>
<li><strong>get</strong>：取值函数，拦截属性的取值行为</li>
<li><strong>set</strong>：存值函数，拦截属性的存值行为</li>
</ul>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong><strong>proto</strong></strong>：<code>构造函数的继承</code>(总是指向<code>父类</code>)</li>
<li><strong><strong>proto</strong>.<strong>proto</strong></strong>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li>
<li><strong>prototype.<strong>proto</strong></strong>：<code>属性方法的继承</code>(总是指向父类的<code>prototype</code>)</li>
</ul>
</li>
<li><p>静态属性：定义类完成后赋值属性，该属性<code>不会被实例继承</code>，只能通过类来调用</p>
</li>
<li><p>静态方法：使用<code>static</code>定义方法，该方法<code>不会被实例继承</code>，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</p>
</li>
<li><p>继承</p>
</li>
<li><ul>
<li>父类静态属性方法可被子类继承</li>
<li>子类继承父类后，可从<code>super</code>上调用父类静态属性方法</li>
<li>作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的<code>当前子类</code>(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</li>
<li>作为对象调用：在<code>普通方法</code>中指向<code>父类的原型对象</code>，在<code>静态方法</code>中指向<code>父类</code></li>
<li>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</li>
<li>ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></li>
<li>实质</li>
<li>super</li>
<li>显示定义：使用<code>constructor() { super(); }</code>定义继承父类，没有书写则<code>显示定义</code></li>
<li>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code></li>
</ul>
</li>
<li><p>实例：类相当于<code>实例的原型</code>，所有在类中定义的属性方法都会被实例继承</p>
</li>
<li><ul>
<li>显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</li>
<li>隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</li>
</ul>
</li>
<li><p>表达式</p>
</li>
<li><ul>
<li>类表达式：<code>const Class = class {}</code></li>
<li>name属性：返回紧跟<code>class</code>后的类名</li>
<li>属性表达式：<code>[prop]</code></li>
<li>Generator方法：<code>* mothod() {}</code></li>
<li>Async方法：<code>async mothod() {}</code></li>
</ul>
</li>
<li><p>this指向：解构实例属性或方法时会报错</p>
</li>
<li><ul>
<li>绑定this：<code>this.mothod = this.mothod.bind(this)</code></li>
<li>箭头函数：<code>this.mothod = () =&gt; this.mothod()</code></li>
</ul>
</li>
<li><p>属性定义位置</p>
</li>
<li><ul>
<li>定义在构造函数中并使用<code>this</code>指向</li>
<li>定义在<code>类最顶层</code></li>
</ul>
</li>
<li><p><strong>new.target</strong>：确定构造函数是如何调用</p>
</li>
</ul>
<blockquote>
<p>原生构造函数</p>
</blockquote>
<ul>
<li><strong>String()</strong></li>
<li><strong>Number()</strong></li>
<li><strong>Boolean()</strong></li>
<li><strong>Array()</strong></li>
<li><strong>Object()</strong></li>
<li><strong>Function()</strong></li>
<li><strong>Date()</strong></li>
<li><strong>RegExp()</strong></li>
<li><strong>Error()</strong></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>在实例上调用方法，实质是调用原型上的方法</li>
<li><code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, { ... })</code>)</li>
<li>类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</li>
<li>构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</li>
<li>取值函数和存值函数设置在属性的<code>Descriptor对象</code>上</li>
<li>类不存在变量提升</li>
<li>利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</li>
<li>子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</li>
<li>使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</li>
<li><code>extends</code>不仅可继承类还可继承原生的构造函数</li>
</ul>
<blockquote>
<p>私有属性方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">const</span> print = <span class="built_in">Symbol</span>(<span class="string">"print"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">        <span class="keyword">this</span>[name] = <span class="string">"Bruce"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    [print]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>[name]&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继承混合类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CopyProperties</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">"constructor"</span> &amp;&amp; key !== <span class="string">"prototype"</span> &amp;&amp; key !== <span class="string">"name"</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, key, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MixClass</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">                CopyProperties(<span class="keyword">this</span>, <span class="keyword">new</span> mixin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        CopyProperties(Mix, mixin);</span><br><span class="line">        CopyProperties(Mix.prototype, mixin.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">MixClass</span>(<span class="title">Person</span>, <span class="title">Kid</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a><code>Module</code></h2><ul>
<li><p>命令</p>
</li>
<li><ul>
<li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li>
<li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li>
<li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li>
<li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li>
<li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li>
<li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li>
<li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li>
<li><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></li>
<li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li>
<li><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></li>
<li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li>
<li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li>
<li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li>
<li><strong>改名导出</strong>：<code>export { name as newName }</code></li>
<li><strong>export</strong>：规定模块对外接口</li>
<li><strong>import</strong>：导入模块内部功能</li>
<li><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</li>
</ul>
</li>
<li><p>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</p>
</li>
<li><p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
</li>
<li><p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p>
</li>
</ul>
<blockquote>
<p>模块方案</p>
</blockquote>
<ul>
<li><strong>CommonJS</strong>：用于服务器(动态化依赖)</li>
<li><strong>AMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>CMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li>
<li><strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li>
</ul>
<blockquote>
<p>加载方式</p>
</blockquote>
<ul>
<li><p><strong>运行时加载</strong></p>
</li>
<li><ul>
<li>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</li>
<li>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</li>
</ul>
</li>
<li><p><strong>编译时加载</strong></p>
</li>
<li><ul>
<li>定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</li>
<li>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(<strong>本身不是对象</strong>)，可拓展JS高级语法(<strong>宏和类型校验</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>加载实现</p>
</blockquote>
<ul>
<li><p><strong>传统加载</strong>：通过<code>&lt;script&gt;</code>进行同步或异步加载脚本</p>
</li>
<li><ul>
<li>同步加载：<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></li>
<li>Defer异步加载：<code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code>(顺序加载，渲染完再执行)</li>
<li>Async异步加载：<code>&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;</code>(乱序加载，下载完就执行)</li>
</ul>
</li>
<li><p><strong>模块加载</strong>：<code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code>(默认是Defer异步加载)</p>
</li>
</ul>
<blockquote>
<p>CommonJS和ESM的区别</p>
</blockquote>
<ul>
<li><p><code>CommonJS</code>输出<code>值的拷贝</code>，<code>ESM</code>输出<code>值的引用</code></p>
</li>
<li><ul>
<li><code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</li>
<li><code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</li>
</ul>
</li>
<li><p><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载</p>
</li>
<li><ul>
<li><code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</li>
<li><code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li>
</ul>
</li>
</ul>
<blockquote>
<p>Node加载</p>
</blockquote>
<ul>
<li><p>背景：<code>CommonJS</code>和<code>ESM</code>互不兼容，目前解决方案是将两者分开，采用各自的加载方案</p>
</li>
<li><p>区分：要求<code>ESM</code>采用<code>.mjs</code>后缀文件名</p>
</li>
<li><ul>
<li><code>require()</code>不能加载<code>.mjs文件</code>，只有<code>import命令</code>才可加载<code>.mjs文件</code></li>
<li><code>.mjs文件</code>里不能使用<code>require()</code>，必须使用<code>import命令</code>加载文件</li>
</ul>
</li>
<li><p>驱动：<code>node --experimental-modules file.mjs</code></p>
</li>
<li><p>限制：Node的<code>import命令</code>目前只支持加载本地模块(<code>file:协议</code>)，不支持加载远程模块</p>
</li>
<li><p>加载优先级</p>
</li>
<li><ul>
<li>脚本文件省略后缀名：依次尝试加载四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li>
<li>以上不存在：尝试加载<code>package.json</code>的<code>main字段</code>指定的脚本</li>
<li>以上不存在：依次尝试加载名称为<code>index</code>四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li>
<li>以上不存在：报错</li>
</ul>
</li>
<li><p>不存在的内部变量：<code>arguments</code>、<code>exports</code>、<code>module</code>、<code>require</code>、<code>this</code>、<code>__dirname</code>、<code>__filename</code></p>
</li>
<li><p>CommonJS加载ESM</p>
</li>
<li><ul>
<li>不能使用<code>require()</code>，只能使用<code>import()</code></li>
</ul>
</li>
<li><p>ESM加载CommonJS</p>
</li>
<li><ul>
<li>自动将<code>module.exports</code>转化成<code>export default</code></li>
<li><code>CommonJS</code>输出缓存机制在<code>ESM</code>加载方式下依然有效</li>
<li>采用<code>import命令</code>加载<code>CommonJS模块</code>时，不允许采用<code>按需导入</code>，应使用<code>默认导入</code>或<code>整体导入</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>循环加载</p>
</blockquote>
<ul>
<li><p>定义：<code>脚本A</code>的执行依赖<code>脚本B</code>，而<code>脚本A</code>的执行又依赖<code>脚本B</code></p>
</li>
<li><p>加载原理</p>
</li>
<li><ul>
<li>CommonJS：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</li>
<li>ESM：<code>import命令</code>加载变量不会被缓存，而是成为一个指向被加载模块的引用</li>
</ul>
</li>
<li><p>循环加载</p>
</li>
<li><ul>
<li>CommonJS：只输出已经执行的部分，还未执行的部分不会输出</li>
<li>ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>ES6模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></li>
<li>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li>
<li><code>export命令</code>输出的接口与其对应的值是<code>动态绑定关系</code>，即通过该接口可获取模块内部实时的值</li>
<li><code>import命令</code>大括号里的变量名必须与被导入模块对外接口的名称相同</li>
<li><code>import命令</code>输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li>
<li><code>import命令</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li>
<li>重复执行同一句<code>import语句</code>，只会执行一次</li>
<li><code>export default</code>命令只能使用一次</li>
<li><code>export default命令</code>导出的整体模块，在执行<code>import命令</code>时其后不能跟<code>大括号</code></li>
<li><code>export default命令</code>本质是输出一个名为<code>default</code>的变量，后面不能跟<code>变量声明语句</code></li>
<li><code>export default命令</code>本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</li>
<li><code>export default命令</code>和<code>export {}命令</code>可同时存在，对应<code>复合导入</code></li>
<li><code>export命令</code>和<code>import命令</code>可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li>
<li><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用<code>对象解构赋值</code>来获取输出接口</li>
<li>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</li>
<li><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</li>
</ul>
<blockquote>
<p>单例模式：跨模块常量</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量跨文件共享</span></span><br><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> NAME = <span class="string">"Bruce"</span>;</span><br><span class="line"><span class="keyword">const</span> AGE = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> SEX = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; AGE, NAME, SEX &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; AGE &#125; <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AGE);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; AGE, NAME, SEX &#125; <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AGE, NAME, SEX);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认导入互换整体导入</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Person <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.AGE);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Person <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.default.AGE);</span><br></pre></td></tr></table></figure>

<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a><code>Iterator</code></h2><ul>
<li><p>定义：为各种不同的数据结构提供统一的访问机制</p>
</li>
<li><p>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</p>
</li>
<li><p>作用</p>
</li>
<li><ul>
<li>为各种数据结构提供一个统一的简便的访问接口</li>
<li>使得数据结构成员能够按某种次序排列</li>
<li>ES6创造了新的遍历命令<code>for-of</code>，<code>Iterator接口</code>主要供<code>for-of</code>消费</li>
</ul>
</li>
<li><p>形式：<code>for-of</code>(自动去寻找Iterator接口)</p>
</li>
<li><p>数据结构</p>
</li>
<li><ul>
<li>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li>
<li>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li>
</ul>
</li>
<li><p>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</p>
</li>
<li><p>遍历器对象</p>
</li>
<li><ul>
<li><strong>next()</strong>：下一步操作，返回<code>{ done, value }</code>(必须部署)</li>
<li><strong>return()</strong>：<code>for-of</code>提前退出调用，返回<code>{ done: true }</code></li>
<li><strong>throw()</strong>：不使用，配合<code>Generator函数</code>使用</li>
</ul>
</li>
</ul>
<blockquote>
<p>for of 循环</p>
</blockquote>
<ul>
<li><p>定义：调用<code>Iterator接口</code>产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</p>
</li>
<li><p>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位UTF-16字符)</p>
</li>
<li><p>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></p>
</li>
<li><p>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</p>
</li>
<li><p>遍历Set：<code>for-of</code>获取<code>值</code> =&gt; <code>for (const v of set)</code></p>
</li>
<li><p>遍历Map：<code>for-of</code>获取<code>键值对</code> =&gt;  <code>for (const [k, v] of map)</code></p>
</li>
<li><p>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</p>
</li>
<li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p>
</li>
<li><ul>
<li><strong>keys()</strong>：返回遍历器对象，遍历所有的键</li>
<li><strong>values()</strong>：返回遍历器对象，遍历所有的值</li>
<li><strong>entries()</strong>：返回遍历器对象，遍历所有的键值对</li>
</ul>
</li>
<li><p>与<code>for-in</code>区别</p>
</li>
<li><ul>
<li>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</li>
<li>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li>
<li>提供遍历所有数据结构的统一操作接口</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li>
<li>解构赋值：对Set进行结构</li>
<li>扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li>
<li>yield<em>：`yield</em>`后跟一个可遍历的数据结构，会调用其遍历器接口</li>
<li>接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h2><ul>
<li><p>定义：包含异步操作结果的对象</p>
</li>
<li><p>状态</p>
</li>
<li><ul>
<li><strong>进行中</strong>：<code>pending</code></li>
<li><strong>已成功</strong>：<code>resolved</code></li>
<li><strong>已失败</strong>：<code>rejected</code></li>
</ul>
</li>
<li><p>特点</p>
</li>
<li><ul>
<li>对象的状态不受外界影响</li>
<li>一旦状态改变就不会再变，任何时候都可得到这个结果</li>
</ul>
</li>
<li><p>声明：<code>new Promise((resolve, reject) =&gt; {})</code></p>
</li>
<li><p>出参</p>
</li>
<li><ul>
<li><strong>resolve</strong>：将状态从<code>未完成</code>变为<code>成功</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li>
<li><strong>reject</strong>：将状态从<code>未完成</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>Promise实例</strong>：原封不动地返回入参</li>
<li><strong>Thenable对象</strong>：将此对象转为Promise对象并返回(Thenable为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</li>
<li><strong>不具有then()的对象</strong>：将此对象转为Promise对象并返回，状态为<code>resolved</code></li>
<li><strong>不带参数</strong>：返回Promise对象，状态为<code>resolved</code></li>
<li>入参：具有<code>Iterator接口</code>的数据结构</li>
<li>成功：只有全部实例状态变成<code>resolved</code>，最终状态才会变成<code>resolved</code></li>
<li>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></li>
<li><strong>第一参数</strong>：状态变为<code>resolved</code>时调用</li>
<li><strong>第二参数</strong>：状态变为<code>rejected</code>时调用(可选)</li>
<li><strong>then()</strong>：分别指定<code>resolved状态</code>和<code>rejected状态</code>的回调函数</li>
<li><strong>catch()</strong>：指定发生错误时的回调函数</li>
<li><strong>Promise.all()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</li>
<li><strong>Promise.race()</strong>：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</li>
<li><strong>Promise.resolve()</strong>：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)</li>
<li><strong>Promise.reject()</strong>：将对象转为状态为<code>rejected</code>的Promise对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>加载图片</li>
<li>AJAX转Promise对象</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li>
<li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li>
<li>一旦新建<code>Promise对象</code>就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会反应到外部</li>
<li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li>
<li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li>
<li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li>
<li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li>
<li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li>
<li><code>reject()</code>的作用等同于抛出错误</li>
<li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li>
<li>实例状态的错误具有<code>冒泡</code>性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li>
<li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li>
<li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li>
<li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即<code>不会有任何反应</code></li>
<li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li>
<li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a><code>Generator</code></h2><ul>
<li><p>定义：封装多个内部状态的异步编程解决方案</p>
</li>
<li><p>形式：调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
</li>
<li><p>声明：<code>function* Func() {}</code></p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>next()</strong>：使指针移向下一个状态，返回<code>{ done, value }</code>(入参会被当作上一个<code>yield命令表达式</code>的返回值)</li>
<li><strong>return()</strong>：返回指定值且终结遍历<code>Generator函数</code>，返回<code>{ done: true, value: 入参 }</code></li>
<li><strong>throw()</strong>：在<code>Generator函数</code>体外抛出错误，在<code>Generator函数</code>体内捕获错误，返回自定义的<code>new Errow()</code></li>
</ul>
</li>
<li><p>yield命令：声明内部状态的值(<code>return</code>声明结束返回的值)</p>
</li>
<li><ul>
<li>遇到<code>yield命令</code>就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></li>
<li>下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield命令</code></li>
<li>没有再遇到<code>yield命令</code>就一直运行到<code>Generator函数</code>结束，直到遇到<code>return语句</code>为止并将其后表达式的值作为返回对象的<code>value</code></li>
<li><code>Generator函数</code>没有<code>return语句</code>则返回对象的<code>value</code>为<code>undefined</code></li>
</ul>
</li>
<li><p>yield*命令：在一个<code>Generator函数</code>里执行另一个<code>Generator函数</code>(后随具有<code>Iterator接口</code>的数据结构)</p>
</li>
<li><p>遍历：通过<code>for-of</code>自动调用<code>next()</code></p>
</li>
<li><p>作为对象属性</p>
</li>
<li><ul>
<li>全写：<code>const obj = { method: function*() {} }</code></li>
<li>简写：<code>const obj = { * method() {} }</code></li>
</ul>
</li>
<li><p>上下文：执行产生的<code>上下文环境</code>一旦遇到<code>yield命令</code>就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在<code>当前状态</code>，等到对它执行<code>next()</code>时，这个<code>上下文环境</code>又会重新加入调用栈，冻结的变量和对象恢复执行</p>
</li>
</ul>
<blockquote>
<p>方法异同</p>
</blockquote>
<ul>
<li><p>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></p>
</li>
<li><p>不同点</p>
</li>
<li><ul>
<li><strong>next()</strong>：将<code>yield命令</code>替换成一个<code>值</code></li>
<li><strong>return()</strong>：将<code>yield命令</code>替换成一个<code>return语句</code></li>
<li><strong>throw()</strong>：将<code>yield命令</code>替换成一个<code>throw语句</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>异步操作同步化表达</li>
<li>控制流管理</li>
<li>为对象部署Iterator接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator接口</code></li>
<li>作为具有Iterator接口的数据结构</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li>
<li>函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li>
<li><code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li>
<li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li>
<li><code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li>
<li><code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li>
<li><code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li>
<li>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li>
<li>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li>
<li>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li>
<li>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li>
<li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li>
<li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li>
<li>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li>
<li><code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li>
<li><code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li>
<li>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li>
</ul>
<blockquote>
<p>首次next可以传值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Wrapper</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> generator = func(...args);</span><br><span class="line">        generator.next();</span><br><span class="line">        <span class="keyword">return</span> generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> print = Wrapper(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`First Input: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"done"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">print().next(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h1><h2 id="数值扩展-1"><a href="#数值扩展-1" class="headerlink" title="数值扩展"></a><code>数值扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>指数运算符(\</strong>)**：数值求幂(相当于<code>Math.pow()</code>)</li>
</ul>
<p>##　<code>数组扩展</code></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>includes()</strong>：是否存在指定成员</li>
</ul>
<h1 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h1><h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a><code>声明</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li>
</ul>
<h2 id="字符串扩展-1"><a href="#字符串扩展-1" class="headerlink" title="字符串扩展"></a><code>字符串扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>padStart()</strong>：把指定字符串填充到字符串头部，返回新字符串</li>
<li><input checked disabled type="checkbox"> <strong>padEnd()</strong>：把指定字符串填充到字符串尾部，返回新字符串</li>
</ul>
<h2 id="对象扩展-1"><a href="#对象扩展-1" class="headerlink" title="对象扩展"></a><code>对象扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>Object.getOwnPropertyDescriptors()</strong>：返回对象所有自身属性(非继承属性)的描述对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.values()</strong>：返回以值组成的数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.entries()</strong>：返回以键和值组成的数组</p>
</li>
</ul>
<h2 id="函数扩展-1"><a href="#函数扩展-1" class="headerlink" title="函数扩展"></a><code>函数扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li>
</ul>
<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a><code>Async</code></h2><ul>
<li><p>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</p>
</li>
<li><p>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</p>
</li>
<li><p>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
</li>
<li><p>声明</p>
</li>
<li><ul>
<li>具名函数：<code>async function Func() {}</code></li>
<li>函数表达式：<code>const func = async function() {}</code></li>
<li>箭头函数：<code>const func = async() =&gt; {}</code></li>
<li>对象方法：<code>const obj = { async func() {} }</code></li>
<li>类方法：<code>class Cla { async Func() {} }</code></li>
</ul>
</li>
<li><p>await命令：等待当前Promise对象状态变更完毕</p>
</li>
<li><ul>
<li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li>
<li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li>
</ul>
</li>
<li><p>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</p>
</li>
</ul>
<blockquote>
<p>Async对Generator改进</p>
</blockquote>
<ul>
<li>内置执行器</li>
<li>更好的语义</li>
<li>更广的适用性</li>
<li>返回值是Promise对象</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>按顺序完成异步操作</p>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><p><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</p>
</li>
<li><p>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</p>
</li>
<li><p>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</p>
</li>
<li><p>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></p>
</li>
<li><p>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</p>
</li>
<li><p>希望即使前一个异步操作失败也不要中断后面的异步操作</p>
</li>
<li><ul>
<li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li>
<li><code>await命令Promise对象</code>跟一个<code>catch()</code></li>
</ul>
</li>
<li><p><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</p>
</li>
<li><p>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</p>
</li>
<li><p><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</p>
</li>
<li><p>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</p>
</li>
</ul>
<h1 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h1><h2 id="字符串扩展-2"><a href="#字符串扩展-2" class="headerlink" title="字符串扩展"></a><code>字符串扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li>
</ul>
<h2 id="对象扩展-2"><a href="#对象扩展-2" class="headerlink" title="对象扩展"></a><code>对象扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>扩展运算符(…)</strong>：转换对象为用逗号分隔的参数序列(<code>{ ...obj }</code>，相当于<code>rest/spread参数</code>的逆运算)</li>
</ul>
<blockquote>
<p>扩展应用</p>
</blockquote>
<ul>
<li>克隆对象：<code>const obj = { __proto__: Object.getPrototypeOf(obj1), ...obj1 }</code></li>
<li>合并对象：<code>const obj = { ...obj1, ...obj2 }</code></li>
<li>转换字符串为对象：<code>{ ...&quot;hello&quot; }</code></li>
<li>转换数组为对象：<code>{ ...[1, 2] }</code></li>
<li>与对象解构赋值结合：<code>const { x, ...rest/spread } = { x: 1, y: 2, z: 3 }</code>(不能复制继承自原型对象的属性)</li>
<li>修改现有对象部分属性：<code>const obj = { x: 1, ...{ x: 2 } }</code></li>
</ul>
<h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a><code>正则扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符</p>
</li>
<li><ul>
<li>正向匹配：<code>\p{PropRule}</code></li>
<li>反向匹配：<code>\P{PropRule}</code></li>
<li>限制：<code>\p{...}</code>和<code>\P{...}</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?&lt;GroupName&gt;</code>)</p>
</li>
<li><ul>
<li>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u</code></li>
<li>匹配：<code>time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)</code></li>
<li>形式：<code>str.exec().groups.GroupName</code></li>
<li>解构赋值替换</li>
</ul>
</li>
</ul>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a><code>Promise</code></h2><ul>
<li><strong>finally()</strong>：指定不管最后状态如何都会执行的回调函数</li>
</ul>
<h2 id="Async-1"><a href="#Async-1" class="headerlink" title="Async"></a><code>Async</code></h2><p><strong>异步迭代器(for-wait-of)</strong>：，循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</p>
<h1 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h1><h2 id="字符串扩展-3"><a href="#字符串扩展-3" class="headerlink" title="字符串扩展"></a><code>字符串扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li>
<li><input checked disabled type="checkbox"> <strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li>
<li><input checked disabled type="checkbox"> <strong>trimStart()</strong>：消除字符串头部空格，返回新字符串</li>
<li><input checked disabled type="checkbox"> <strong>trimEnd()</strong>：消除字符串尾部空格，返回新字符串</li>
</ul>
<h2 id="对象扩展-3"><a href="#对象扩展-3" class="headerlink" title="对象扩展"></a><code>对象扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>Object.fromEntries()</strong>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li>
</ul>
<h2 id="数组扩展-1"><a href="#数组扩展-1" class="headerlink" title="数组扩展"></a><code>数组扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>flat()</strong>：扁平化数组，返回新数组</li>
<li><input checked disabled type="checkbox"> <strong>flatMap()</strong>：映射且扁平化数组，返回新数组(只能展开一层数组)</li>
</ul>
<h2 id="函数扩展-2"><a href="#函数扩展-2" class="headerlink" title="函数扩展"></a><code>函数扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li>
<li><input checked disabled type="checkbox"> <strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li>
</ul>
<h2 id="Symbol-1"><a href="#Symbol-1" class="headerlink" title="Symbol"></a><code>Symbol</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>description</strong>：返回<code>Symbol值</code>的描述</p>
<h1 id="ES提案"><a href="#ES提案" class="headerlink" title="ES提案"></a><strong>ES提案</strong></h1></li>
</ul>
<h2 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a><code>声明</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>globalThis对象</strong>：作为顶层对象，指向全局环境下的<code>this</code></li>
<li><input checked disabled type="checkbox"> <strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do{}</code>)</li>
<li><input checked disabled type="checkbox"> <strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>{}</code>包括</li>
<li><input checked disabled type="checkbox"> <strong>!#命令</strong>：指定脚本执行器(写在文件首行)</li>
</ul>
<h2 id="数值扩展-2"><a href="#数值扩展-2" class="headerlink" title="数值扩展"></a><code>数值扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>数值分隔符(_)</strong>：使用<code>_</code>作为千分位分隔符(增加数值的可读性)</li>
<li><input checked disabled type="checkbox"> <strong>BigInt()</strong>：创建任何位数的整数(新增的数据类型，使用<code>n</code>结尾)</li>
</ul>
<h2 id="对象扩展-4"><a href="#对象扩展-4" class="headerlink" title="对象扩展"></a><code>对象扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>链判断操作符(?.)</strong>：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)</li>
<li><input checked disabled type="checkbox"> <strong>空判断操作符(??)</strong>：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</li>
</ul>
<h2 id="函数扩展-3"><a href="#函数扩展-3" class="headerlink" title="函数扩展"></a><code>函数扩展</code></h2><ul>
<li><input checked disabled type="checkbox"> <p><strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>管道操作符(|&gt;)</strong>：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>绑定运算符(::)</strong>：函数绑定(左边是对象右边是函数，取代<code>bind</code>、<code>apply</code>、<code>call</code>调用)</p>
</li>
<li><ul>
<li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li>
<li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li>
</ul>
</li>
</ul>
<h2 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a><code>Proxy</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>Promise.try()</strong>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li>
</ul>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><code>Realm</code></h2><ul>
<li>定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li>
<li>声明：<code>new Realm().global</code></li>
</ul>
<h2 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a><code>Class</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>静态属性</strong>：使用<code>static</code>定义属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li>
<li><input checked disabled type="checkbox"> <strong>私有属性</strong>：使用<code>#</code>定义属性，该属性只能在类内部访问</li>
<li><input checked disabled type="checkbox"> <strong>私有方法</strong>：使用<code>#</code>定义方法，该方法只能在类内部访问</li>
<li><input checked disabled type="checkbox"> <strong>装饰器</strong>：使用<code>@</code>注释或修改类和类方法</li>
</ul>
<h2 id="Module-1"><a href="#Module-1" class="headerlink" title="Module"></a><code>Module</code></h2><ul>
<li><p><strong>import()</strong>：动态导入(返回<code>Primise</code>)</p>
</li>
<li><ul>
<li>背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li>
<li>位置：可在任何地方使用</li>
<li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li>
<li>场景：按需加载、条件加载、模块路径动态化</li>
</ul>
</li>
<li><p><strong>import.meta</strong>：返回脚本元信息</p>
</li>
</ul>
<h2 id="Async-2"><a href="#Async-2" class="headerlink" title="Async"></a><code>Async</code></h2><ul>
<li><input checked disabled type="checkbox"> <strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/11/26/应该知道的一些ES6基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/11/26/应该知道的一些ES6基础知识/" class="post-title-link" itemprop="url">应该知道的一些ES6基础知识</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-26 21:41:34 / 修改时间：21:45:18" itemprop="dateCreated datePublished" datetime="2019-11-26T21:41:34+08:00">2019-11-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 freeCodeCamp 社区阅读<a href="https://link.zhihu.com/?target=https%3A//chinese.freecodecamp.org/forum/t/topic/557" target="_blank" rel="noopener">原文</a>。</p>
<p>ES6 为 JavaScript 这门语言带来了很多特性。一些新的语法可以让你写出更具表现力的代码；一些特性完善了函数式编程的工具箱；而也有一些特性颇具争议。</p>
<h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><p>现在有两种新的声明变量的方式（let 和 const），再加上过去使用的方式（var）。</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code> 在当前作用域中声明并可以选择初始化变量。当前作用域可以是任意一个模块，一个函数，或者一个代码块。未被初始化的变量的值是 <code>undefined</code>。</p>
<p>作用域定义了一个变量的生命周期和访问权限。我们无法在变量声明的作用域之外访问它们。</p>
<p>下面这段代码强调了 <code>let</code> 的块级作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>相反，使用 <code>var</code> 声明的变量则不具备块及作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环语句中，使用 <code>let</code> 声明变量将会为每一次迭代创建一个当前块级作用域的本地新变量。以下这个循环在五个不同的 <code>i</code> 变量上创建了五个闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i); <span class="comment">//0 1 2 3 4</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>同样的代码如果换成 <code>var</code> 声明将会创建五个使用同一个变量的闭包，所以所有的闭包函数都会输出 i 变量最终的值。</p>
<p><code>log()</code> 函数是一个闭包。更多关于闭包的内容，可以参看 <a href="https://link.zhihu.com/?target=https%3A//www.freecodecamp.org/news/discover-the-power-of-closures-in-javascript-5c472a7765d7/" target="_blank" rel="noopener">Discover the power of closures in JavaScript</a>。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code> 声明的变量不能再重新赋值。只有当赋值是不可变的时，它才会变成常量。</p>
<p>不可变的值是指那些一旦创建，就不能再改变的值。原始值是不可变的，对象是可变的。</p>
<p><code>const</code> 冻结变量，而 <code>Object.freeze()</code> 冻结对象。</p>
<p>使用 <code>const</code> 声明变量必须强制进行初始化操作。</p>
<p><strong>译注：</strong> <code>const</code> 初始化对象时，不可变的是对象的内存引用地址，仍然可以对对象进行属性操作。当初始化原始值（字符串，数字，布尔值）时，这些值由于不可变更，所以成为常量。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在有模块之前，在任何函数外部声明的变量都是全局变量。</p>
<p>在模块里，在任何函数外部声明的变量会隐藏起来，除非显式地导出，否则其他模块无法访问。</p>
<p>导出操作让其他模块可以访问模块内的函数或者对象。在下面例子中，我从不同的模块导出了不同的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module "./TodoStore.js"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">TodoStore</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//module "./UserStore.js"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UserStore</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>导入操作让当前模块可以访问其他模块内的函数或者对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TodoStore <span class="keyword">from</span> <span class="string">"./TodoStore"</span>;</span><br><span class="line"><span class="keyword">import</span> UserStore <span class="keyword">from</span> <span class="string">"./UserStore"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoStore = TodoStore();</span><br><span class="line"><span class="keyword">const</span> userStore = UserStore();</span><br></pre></td></tr></table></figure>

<h2 id="展开语法-Spread-剩余参数-Rest"><a href="#展开语法-Spread-剩余参数-Rest" class="headerlink" title="展开语法(Spread)/剩余参数(Rest)"></a>展开语法(Spread)/剩余参数(Rest)</h2><p>根据使用的场景，<code>...</code> 操作符可以是展开操作符或者剩余参数。请看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, ...numbers];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>这是展开操作符。现在看另一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">x,y, ...arr</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;</span><br><span class="line">process(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//[3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">...arr</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;</span><br><span class="line">processArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>这是剩余参数。</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>使用剩余参数，我们可以替换掉 <code>arguments</code> 这个虚拟参数。剩余参数是一个数组，而 <code>arguments</code> 不是。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumber</span>(<span class="params">total, value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(addNumber, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>展开操作符让对象和数组的克隆变得更简单和更具表现力。</p>
<p>对象属性的展开操作符是 ES2018 的一部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123; <span class="attr">title</span>: <span class="string">"JavaScript: The Good Parts"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clone with Object.assign()</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.assign(&#123;&#125;, book);</span><br><span class="line"></span><br><span class="line"><span class="comment">//clone with spread operator</span></span><br><span class="line"><span class="keyword">const</span> clone = &#123; ...book &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//clone with slice</span></span><br><span class="line"><span class="keyword">const</span> cloneArr = arr.slice();</span><br><span class="line"></span><br><span class="line"><span class="comment">//clone with spread operator</span></span><br><span class="line"><span class="keyword">const</span> cloneArr = [ ...arr ];</span><br></pre></td></tr></table></figure>

<p><strong>译注：</strong> spread 进行引用类型的拷贝只是浅拷贝。</p>
<h3 id="连结"><a href="#连结" class="headerlink" title="连结"></a>连结</h3><p>在下面的例子中，展开操作符用来连结数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> part1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> part2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = part1.concat(part2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...part1, ...part2];</span><br></pre></td></tr></table></figure>

<h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><p>展开操作符，以及像 <code>Object.assign()</code> 方法，可以用来从至少一个对象复制属性到一个空对象上，然后合并它们的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> authorGateway = &#123; </span><br><span class="line">  getAuthors : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  editAuthor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bookGateway = &#123; </span><br><span class="line">  getBooks : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  editBook: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy with Object.assign()</span></span><br><span class="line"><span class="keyword">const</span> gateway = <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">      authorGateway, </span><br><span class="line">      bookGateway);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//copy with spread operator</span></span><br><span class="line"><span class="keyword">const</span> gateway = &#123;</span><br><span class="line">   ...authorGateway,</span><br><span class="line">   ...bookGateway</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><p>考虑下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BookGateway</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getBooks</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">editBook</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getBooks: getBooks,</span><br><span class="line">    editBook: editBook</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了属性简写，当属性名称和将作为属性值的变量的名称一样时，我们就可以只写一次属性键值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BookGateway</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getBooks</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">editBook</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getBooks,</span><br><span class="line">    editBook</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是另一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoStore = TodoStore();</span><br><span class="line"><span class="keyword">const</span> userStore = UserStore();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> stores = &#123;</span><br><span class="line">  todoStore,</span><br><span class="line">  userStore</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoStore</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> helper = args.helper;</span><br><span class="line">  <span class="keyword">const</span> dataAccess = args.dataAccess;</span><br><span class="line">  <span class="keyword">const</span> userStore = args.userStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用解构赋值写成像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoStore</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; </span><br><span class="line">      helper, </span><br><span class="line">      dataAccess, </span><br><span class="line">      userStore &#125; = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至可以直接在参数列表中使用解构语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoStore</span>(<span class="params">&#123; helper, dataAccess, userStore &#125;</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数将这样调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TodoStore(&#123; </span><br><span class="line">  helper: &#123;&#125;, </span><br><span class="line">  dataAccess: &#123;&#125;, </span><br><span class="line">  userStore: &#123;&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>函数现在可以设置参数默认值。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message, mode = <span class="string">"Info"</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mode + <span class="string">": "</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">"An info"</span>);</span><br><span class="line"><span class="comment">//Info: An info</span></span><br><span class="line"></span><br><span class="line">log(<span class="string">"An error"</span>, <span class="string">"Error"</span>);</span><br><span class="line"><span class="comment">//Error: An error</span></span><br></pre></td></tr></table></figure>

<h2 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h2><p>模板字符串使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```js</span><br><span class="line">function log(message, mode= &quot;Info&quot;)&#123;</span><br><span class="line">  console.log(`$&#123;mode&#125;: $&#123;message&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模板字符串可以支持多行字符串定义。不过，更好的选择是将长文本信息作为资源保留在数据库中。</p>
<p>下面是一个生成跨越多行的 HTML 代码的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTodoItemHtml</span>(<span class="params">todo</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;li&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;<span class="subst">$&#123;todo.title&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;<span class="subst">$&#123;todo.userName&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/li&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更好的尾调用"><a href="#更好的尾调用" class="headerlink" title="更好的尾调用"></a>更好的尾调用</h2><blockquote>
<p>当递归调用是函数执行的最后一项操作时，递归函数是尾递归的。</p>
</blockquote>
<p>尾递归函数比非尾递归函数表现更好。尾递归调用优化不会为每次函数调用创建新的堆栈帧，而是使用一个单一的堆栈帧。（<strong>译注：</strong> 即尾递归只会使用最初函数创建的堆栈帧）</p>
<p>ES6 在严格模式下开启了尾调用优化。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/4t2j3uho/" target="_blank" rel="noopener">下面的函数</a>会从尾调用优化中受益。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">from, to</span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">from</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; to)  <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="comment">//the last statement is the recursive call </span></span><br><span class="line">  print(n + <span class="number">1</span>, to); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>注： 尾调用优化现在还没有被主流浏览器支持。</p>
<p><strong>译注：</strong></p>
<p>按照阮一峰老师 <a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/function%23%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">ES6 标准入门中提到的尾调用优化</a>，上面的代码其实并不会产生尾调用优化。因为 JS 中函数除非显式地指定 <code>return</code> 语句，否则函数将默认返回 <code>undefined</code>。上面示例的代码只是调用了自己，其实函数还有下一步操作，是返回 <code>undefined</code>。正确的代码应该是 <code>return print(n + 1, to)</code>。</p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p><strong>译注：</strong> Promise 的 resolve 状态这里译为解决， reject 状态译为拒绝。</p>
<blockquote>
<p>Promise 是对一次异步调用的引用。它将来可能会在某处解决或者失败。</p>
</blockquote>
<p>多个 Promise 能够更好地被组合在一起执行。正如<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/eqyhq2e3/" target="_blank" rel="noopener">下面代码</a>所示，可以很容易地在所有 Promise 都解决后调用一个函数，或者只要有一个 Promise 被解决就调用一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> fetch(<span class="string">"/todos"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> fetch(<span class="string">"/users"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAlbums</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> fetch(<span class="string">"/albums"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPromises = [</span><br><span class="line">  getTodos(), </span><br><span class="line">  getUsers(), </span><br><span class="line">  getAlbums()</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(getPromises).then(doSomethingWhenAll);</span><br><span class="line"><span class="built_in">Promise</span>.race(getPromises).then(doSomethingWhenOne);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWhenAll</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWhenOne</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetch()</code> 函数是 Fetch API 的一部分，它会返回一个 Promise。</p>
<p><code>Promise.all()</code> 返回一个 Promise，它会在所有传入的 Promise 都解决后进入解决状态。 <code>Promise.race()</code> 返回一个 Promise，一旦传入的 Promise 中有任意一个被解决或者拒绝，它就会进入解决或者拒绝状态。</p>
<p>promise 有三种状态：pending、resolved 或者 rejected。在 promise 没有返回 resolved 或者 rejected 时是 pending 状态。</p>
<p>Promise 支持链式调用，允许你通过一组函数传递数据。在<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/kgxnay46/" target="_blank" rel="noopener">下面的例子中</a>，<code>getTodos()</code> 的结果传递给 <code>toJson()</code> 作为参数传入，然后它的结果又传递给 <code>getTopPriority()</code> 作为参数传入，最后它的结果又作为参数传递给 <code>renderTodos()</code> 函数。当有错误抛出或者任一 Promise 被拒绝，<code>handleError</code> 函数会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getTodos()</span><br><span class="line">  .then(toJson)</span><br><span class="line">  .then(getTopPriority)</span><br><span class="line">  .then(renderTodos)</span><br><span class="line">  .catch(handleError);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toJson</span>(<span class="params">response</span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTopPriority</span>(<span class="params">todos</span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderTodos</span>(<span class="params">todos</span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params">error</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>.then()</code> 处理了成功的场景，<code>.catch()</code> 处理了发生错误的场景。任意一步有错误抛出，调用链将跳转到链中最近的拒绝状态处理方法。</p>
<p><code>Promise.resolve()</code> 返回一个被解决的 Promise。 <code>Promise.reject()</code> 返回一个被拒绝的 Promise。</p>
<h2 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h2><p>ES6 中的类是使用自定义原型创建对象的语法糖。它有着比之前的构造函数更好的语法。<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/aLg8t632/" target="_blank" rel="noopener">参考下面的例子</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  doSomething()&#123; <span class="built_in">console</span>.log(<span class="string">"doSomething"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> service = <span class="keyword">new</span> Service();</span><br><span class="line"><span class="built_in">console</span>.log(service.__proto__ === Service.prototype);</span><br></pre></td></tr></table></figure>

<p>所有定义在 Service 类上的方法会被添加到 <code>Service.prototype</code> 原型对象上。<code>Service</code>类的实例都有相同的原型（<code>Service.prototype</code>）。所有实例都会将方法调用代理到 <code>Service.prototype</code> 原型对象上。所有的实例都会继承定义在 <code>Service.prototype</code> 上的方法。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>“类可以继承自其他类”。下面是一个<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/1xo96yt8/" target="_blank" rel="noopener">继承的例子</a>，<code>SpecialService</code> 类继承自 <code>Service</code> 类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  doSomething()&#123; <span class="built_in">console</span>.log(<span class="string">"doSomething"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  doSomethingElse()&#123; <span class="built_in">console</span>.log(<span class="string">"doSomethingElse"</span>); &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> specialService = <span class="keyword">new</span> SpecialService();</span><br><span class="line">specialService.doSomething();</span><br><span class="line">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>

<p>所有定义在 <code>SpecialService</code> 类上的方法会被添加到 <code>SpecialService.prototype</code> 原型对象上。所有实例都会将方法调用会被代理到 <code>SpecialService.prototype</code> 原型对象上。如果方法在 <code>SpecialService.prototype</code> 上找不到，会继续在 <code>Service.prototype</code> 上查找，如果还找不到，则继续在 <code>Object.prototype</code> 上查找。</p>
<h3 id="类可能是一个不好的特性"><a href="#类可能是一个不好的特性" class="headerlink" title="类可能是一个不好的特性"></a>类可能是一个不好的特性</h3><p>尽管它们看上去封装好了，类的所有成员仍然是公有的。你仍然需要处理各种 <code>this</code> 这个缺失的上下文产生的问题。类暴露出去的公有 API 都是可变的。</p>
<p><code>class</code> 可能是一个不好的特性，如果你忽略 JavaScript 的函数特性的话。<code>class</code> 可能会让人觉得 JavaScript 是一门基于类的语言然而实际上它既是一门函数式编程语言，又是基于原型的语言。</p>
<p>可以使用工厂函数来创建封装的对象。看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Service</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"doSomething"</span>); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">     doSomething</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里所有的成员变量都默认是私有的。暴露的公有的 API 是不可变的。无需管理 <code>this</code> 产生的问题。</p>
<p>在使用框架和组件时，<code>class</code> 可以用作异常。React 就是这种情况，但在 <a href="https://link.zhihu.com/?target=https%3A//reactjs.org/docs/hooks-overview.html" target="_blank" rel="noopener">React Hooks</a> 中就不是了。</p>
<p>为什么工厂函数更好，可以参看 <a href="https://link.zhihu.com/?target=https%3A//www.freecodecamp.org/news/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15/" target="_blank" rel="noopener">Class vs Factory function: exploring the way forward</a>。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数快速地创建匿名函数，可以用来以更精简地语法创建较小地回调函数。</p>
<p>让我们来看一个 todo 应用的例子。一个 todo 对象有一个 <code>id</code>，一个 <code>title</code>，以及一个 <code>complete</code> 的布尔属性。现在来看下面这段只从对象中选择 <code>title</code> 属性的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> titles = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title);</span><br></pre></td></tr></table></figure>

<p>或者下面这段只选择还未完成的待办事项的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filteredTodos = todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed);</span><br></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>箭头函数没有自己的 <code>this</code> 和 <code>arguments</code>。因此，你也许会看见箭头函数被用来解决 <code>this</code> 产生的一些问题。我认为避免这些问题的最佳方式是根本不使用 <code>this</code>。（<strong>译注：</strong> 不用妖魔化 this）</p>
<h3 id="箭头函数也可能是一个不好的特性"><a href="#箭头函数也可能是一个不好的特性" class="headerlink" title="箭头函数也可能是一个不好的特性"></a>箭头函数也可能是一个不好的特性</h3><p>在需要用到具名函数的场景时，箭头函数可能是一个不好的特性。使用箭头函数会影响代码的可读性和可维护性。看下面这段全部使用匿名箭头函数的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newTodos = todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> </span><br><span class="line">       !todo.completed &amp;&amp; todo.type === <span class="string">"RE"</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">todo</span> =&gt;</span> (&#123;</span><br><span class="line">       title : todo.title,</span><br><span class="line">       userName : users[todo.userId].name</span><br><span class="line">    &#125;))</span><br><span class="line">    .sort(<span class="function">(<span class="params">todo1, todo2</span>) =&gt;</span>  </span><br><span class="line">      todo1.userName.localeCompare(todo2.userName));</span><br></pre></td></tr></table></figure>

<p>现在来看<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/pm7n2ab5/" target="_blank" rel="noopener">另一段同样逻辑的代码</a>，这段代码使用命名的纯函数进行了重构，函数的命名能帮助我们更好地理解它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newTodos = todos.filter(isTopPriority)</span><br><span class="line">  .map(partial(toTodoView, users))</span><br><span class="line">  .sort(ascByUserName);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTopPriority</span>(<span class="params">todo</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !todo.completed &amp;&amp; todo.type === <span class="string">"RE"</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toTodoView</span>(<span class="params">users, todo</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    title : todo.title,</span><br><span class="line">    userName : users[todo.userId].name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ascByUserName</span>(<span class="params">todo1, todo2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> todo1.userName.localeCompare(todo2.userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更重要的是，匿名箭头函数将匿名显示在调用堆栈中。</p>
<p>可以参看 <a href="https://link.zhihu.com/?target=https%3A//www.freecodecamp.org/news/how-to-make-your-code-better-with-intention-revealing-function-names-6c8b5271693e/" target="_blank" rel="noopener">How to make your code better with intention-revealing function names</a>了解为什么具名函数更好。</p>
<p>更少的代码并不意味着更具可读性。通过<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/wc8be2gn/" target="_blank" rel="noopener">下面这个例子</a>看看哪一个对你更易理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//with arrow function</span></span><br><span class="line"><span class="keyword">const</span> prop = <span class="function"><span class="params">key</span> =&gt;</span> <span class="function"><span class="params">obj</span> =&gt;</span> obj[key];</span><br><span class="line"></span><br><span class="line"><span class="comment">//with function keyword</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj[key];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意返回对象的情况。下面的代码中，<code>getSampleTodo()</code> 函数返回了 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSampleTodo = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">title</span> : <span class="string">"A sample todo"</span> &#125;;</span><br><span class="line"></span><br><span class="line">getSampleTodo();</span><br><span class="line"><span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>我认为 ES6 的生成器是一个让代码更复杂的无必要的特性。（<strong>译注：</strong> 这一点不认可作者，只能说对上层应用开发和新手来说没有必要使用。）</p>
<p>ES6 的生成器创建了一个包含 <code>next()</code> 方法的对象。<code>next()</code> 方法又创建了一个包含 <code>value</code> 属性的对象。ES6 的生成器改善了循环的使用。看<a href="https://link.zhihu.com/?target=https%3A//jsfiddle.net/cristi_salcescu/edq7vfwm/" target="_blank" rel="noopener">下面的代码</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sequence</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = sequence();</span><br><span class="line">generator.next().value;<span class="comment">//1</span></span><br><span class="line">generator.next().value;<span class="comment">//2</span></span><br><span class="line">generator.next().value;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>同样的生成器可以用一个闭包来简单实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequence</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = sequence();</span><br><span class="line">generator();<span class="comment">//1</span></span><br><span class="line">generator();<span class="comment">//2</span></span><br><span class="line">generator();<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>更多关于函数生成器的例子可以参看 <a href="https://link.zhihu.com/?target=https%3A//www.freecodecamp.org/news/lets-experiment-with-functional-generators-and-the-pipeline-operator-in-javascript-520364f97448/" target="_blank" rel="noopener">Let’s experiment with functional generators and the pipeline operator in JavaScript</a>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>let</code> 和 <code>const</code> 用来声明和初始化变量。</p>
<p>模块封装功能并仅仅暴露一小部分。</p>
<p>展开操作符和剩余参数，以及属性简写让代码更具表现力。</p>
<p>Promise 和尾递归完善了函数式编程的工具箱。</p>
<p>[原文地址](那些你应该知道的 ES6 特性 - freeCodeCamp的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/87285383" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/87285383</a>)</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/11/26/js数据类型之增删改查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/11/26/js数据类型之增删改查/" class="post-title-link" itemprop="url">js数据类型之增删改查</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-26 21:37:12 / 修改时间：21:40:10" itemprop="dateCreated datePublished" datetime="2019-11-26T21:37:12+08:00">2019-11-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JS数据类型复杂类型学习之增删改查"><a href="#JS数据类型复杂类型学习之增删改查" class="headerlink" title="JS数据类型复杂类型学习之增删改查"></a>JS数据类型复杂类型学习之增删改查</h1><h2 id="七种数据类型"><a href="#七种数据类型" class="headerlink" title="七种数据类型"></a>七种数据类型</h2><p>number、string、bool、symbol、undefined、null、Object</p>
<p>总结四基两空一对象</p>
<h2 id="五个-falsy值"><a href="#五个-falsy值" class="headerlink" title="五个 falsy值"></a>五个 falsy值</h2><p>undefined、null、0、NaN、’ ‘(空字符串)</p>
<p>falsy 相当于是 false 但是不是false的值</p>
<h2 id="对象-Object-（第七种数据类型，唯一一个复杂数据类型）"><a href="#对象-Object-（第七种数据类型，唯一一个复杂数据类型）" class="headerlink" title="对象 Object （第七种数据类型，唯一一个复杂数据类型）"></a>对象 Object （第七种数据类型，唯一一个复杂数据类型）</h2><p>定义：</p>
<ul>
<li>无序的数据集合</li>
<li>键值对的集合</li>
</ul>
<p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">'name'</span>: <span class="string">'rose'</span> , <span class="string">'age'</span>: <span class="string">'18'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> object ( &#123; <span class="string">'name'</span>: <span class="string">'rose'</span>  &#125; )  <span class="comment">//这是正规写法，第一种是简单写法</span></span><br><span class="line"><span class="built_in">console</span>.log = ( &#123; <span class="string">'name'</span>: <span class="string">'rose'</span> , <span class="string">'age'</span>: <span class="string">'18'</span> &#125; )  <span class="comment">//未命名对象，</span></span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ul>
<li>键名是字符串，不是标识符，可以包含任意字符</li>
<li>引号可以省略，省略之后就只能写标识符</li>
<li>就算引号省略了，键名也还是字符串（重点）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">属性名：每个 key 都是对象的属性名</span><br><span class="line">属性值：每个 value 都是对象的属性值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实践1</span><br><span class="line"></span><br><span class="line">Object.key(obj);</span><br><span class="line">可以得到 obj 的key</span><br><span class="line"></span><br><span class="line">所有的属性名会自动变成字符串</span><br><span class="line"></span><br><span class="line">Object.keys(obj);</span><br><span class="line">可以得到 obj 所有的key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实践2</span><br><span class="line"></span><br><span class="line">变量做属性名</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">let p1 = &apos;name&apos;</span><br><span class="line">let obj = &#123; p1:&apos;rose&apos; &#125;这样写，属性名为字符串&apos;p1&apos;</span><br><span class="line">let obj = &#123; [p1]:&apos;rose&apos; &#125;这样写，属性名为字符串&apos;name&apos;</span><br><span class="line"></span><br><span class="line">对比</span><br><span class="line">不加 [] 的属性名会自动变成字符串</span><br><span class="line">加了 [] 的属性名会当做变量求值</span><br><span class="line">值如果不是字符串，会自动变成字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">超纲知识</span><br><span class="line">以后学习“迭代”用的还上</span><br></pre></td></tr></table></figure>

<p>原型</p>
<ul>
<li>所有的对象都有原型<ul>
<li>原型中存储着对象的共有属性</li>
<li>比如 obj 的原型就是一个对象；</li>
<li><code>obj.__proto__</code> 存着这个对象的地址</li>
<li>这个对象里有 toString / valueOf / constructor 等属性</li>
</ul>
</li>
<li>对象的原型也是对象<ul>
<li>所以对象的原型也是原型</li>
<li>obj = {} 的原型即为所有对象的原型</li>
<li>这个原型包含所有对象的共有属性，是对象的根</li>
<li>这个原型也有原型，是 null</li>
</ul>
</li>
</ul>
<h2 id="对象的-增、删、改、查"><a href="#对象的-增、删、改、查" class="headerlink" title="对象的 增、删、改、查"></a>对象的 增、删、改、查</h2><p><strong>删除属性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.xxx 或 <span class="keyword">delete</span> obj[<span class="string">'xxx'</span>]</span><br><span class="line"><span class="number">1</span>、即可删除 obj 的 xxx 属性</span><br><span class="line"><span class="number">2</span>、请区分“属性值为<span class="literal">undefined</span>”和 “不含属性名”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不含属性名</span><br><span class="line"><span class="string">'xxx'</span> <span class="keyword">in</span> obj === <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">含有属性名，但是值为<span class="literal">undefined</span></span><br><span class="line"><span class="string">'xxx'</span> <span class="keyword">in</span> obj &amp;&amp; obj.xxx === <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意 obj.xxx === <span class="literal">undefined</span> ,不能判定 <span class="string">'xxx'</span> 是否为 obj 的属性</span><br><span class="line">示例</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">obj x === <span class="literal">undefined</span> <span class="comment">//得到 true</span></span><br><span class="line">obj2 x  === <span class="literal">undefined</span> <span class="comment">//得到 true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实践<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'rose'</span>,<span class="attr">age</span>:<span class="string">'18'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、obj.name = <span class="literal">undefined</span></span><br><span class="line"><span class="number">2</span>、<span class="keyword">delete</span> obj.name <span class="comment">//也可以这样 delete obj['name']</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>和<span class="number">2</span>的区别</span><br><span class="line">一号只删除属性值，属性名还在，属性值为<span class="literal">undefined</span>；</span><br><span class="line">二号完全删除属性值和属性名。</span><br></pre></td></tr></table></figure>

<p><strong>查看属性（也是读属性）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">查看自身所有属性</span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line">可以得到 obj 所有的key</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(obj);</span><br><span class="line">可以得到 obj 所有的值</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(obj);</span><br><span class="line">可以得到 obj 所有的 key 和值</span><br><span class="line"></span><br><span class="line">查看自身加共有属性</span><br><span class="line"><span class="built_in">console</span>.dir(obj)</span><br><span class="line">或者自己依次使用 <span class="built_in">Object</span>.keys 打印出 obj.__proto__</span><br><span class="line"></span><br><span class="line">判断一个属性是自身的还是共有的</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看一个属性</span><br><span class="line"></span><br><span class="line">两种方法查看属性</span><br><span class="line"><span class="number">1</span>、中括号语法： obj[<span class="string">'key'</span>]</span><br><span class="line"><span class="number">2</span>、点语法： obj.key</span><br><span class="line"><span class="number">3</span>、坑新人语法： obj[key] <span class="comment">//变量 key 值一般不为 'key'</span></span><br><span class="line"></span><br><span class="line">重点：</span><br><span class="line"><span class="number">1</span>、新手优先使用中括号语法，点语法容易误导你，让你以为 key 不是字符串</span><br></pre></td></tr></table></figure>

<p><strong>修改或增加属性（写属性）</strong></p>
<ul>
<li>直接赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'rose'</span>&#125; <span class="comment">// name 是字符串</span></span><br><span class="line">obj.name = <span class="string">'rose'</span> <span class="comment">// name 是字符串</span></span><br><span class="line">obj[<span class="string">'name'</span>] = <span class="string">'rose'</span></span><br><span class="line">&lt;&lt;obj[name] = <span class="string">'rose'</span> <span class="comment">//错误的，因为 name 的值是不确定的&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">obj [<span class="string">'na'</span> + <span class="string">'me'</span>] = <span class="string">'rose'</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'name'</span>;obj[key] = <span class="string">'rose'</span></span><br><span class="line">&lt;&lt;<span class="keyword">let</span> key = <span class="string">'name'</span>;obj.key = <span class="string">'rose'</span> <span class="comment">//错，因为obj.key 等价 obj['key']&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>批量赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(obj,&#123;<span class="attr">age</span>:<span class="string">'18'</span>, <span class="attr">gender</span>: <span class="string">'man'</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>修改或者增加共有属性</strong></p>
<ul>
<li>无法通过自身修改或者增加共有属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;；obj2 = &#123;&#125; <span class="comment">// 共有 toString</span></span><br><span class="line">obj.toString = <span class="string">'xxx'</span> <span class="comment">//只会改 obj 的自身属性</span></span><br><span class="line">obj2.toString <span class="comment">//还在原型上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>强制修改或者增加原型上的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、obj.__proto__.toString = <span class="string">'xxx'</span> <span class="comment">//不推荐使用__proto__</span></span><br><span class="line"><span class="number">2</span>、<span class="built_in">Object</span>.protoye.toString = <span class="string">'xxx'</span></span><br><span class="line"><span class="number">3</span>、一般来说，不要修改原型，会引发很多问题</span><br></pre></td></tr></table></figure>

<p><strong>修改隐藏属性</strong></p>
<ul>
<li>不推荐使用 <code>__proto__</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'rose'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">name</span>: <span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> common = &#123;<span class="attr">kind</span>: <span class="string">'human'</span>&#125;</span><br><span class="line">obj.__proto__ = common</span><br><span class="line">obj2.__proto__ = common</span><br></pre></td></tr></table></figure>

<ul>
<li>推荐使用<code>Object.create</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(common)</span><br><span class="line">obj.name = <span class="string">'rose'</span></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.create(common)</span><br><span class="line">obj2.name = <span class="string">'jack'</span></span><br><span class="line"></span><br><span class="line">规范</span><br><span class="line">要改的话一开始就改，别后来再改</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>删</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">delete</span> obj[<span class="string">'xxx'</span>]</span><br><span class="line"><span class="number">2</span>、<span class="string">'name'</span> <span class="keyword">in</span> obj <span class="comment">// false</span></span><br><span class="line"><span class="number">3</span>、obj.hasOwnporperty(<span class="string">'name'</span>) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>和<span class="number">3</span>的区别：</span><br><span class="line">查看 <span class="string">'xxx'</span> 这个属性是自身的还是原型的；</span><br><span class="line">第二种可以证明 <span class="string">'name'</span> 是否在 obj 中，在返回 <span class="literal">true</span> 、不在返回 <span class="literal">false</span>；</span><br><span class="line">但是无法证明实在自身属性还是原型属性里面的；</span><br><span class="line">第三种直接证明是否是自身拥有，只有一种 <span class="literal">false</span> ，自身不存在。</span><br></pre></td></tr></table></figure>

<p><strong>查</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="built_in">console</span>.dir(obj)</span><br><span class="line">obj[<span class="string">'name'</span>]</span><br><span class="line">obj.name <span class="comment">//这里的 name 是字符串</span></span><br><span class="line">obj[name] <span class="comment">//这里的 name 是变量</span></span><br></pre></td></tr></table></figure>

<p><strong>改</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">改自身 obj[<span class="string">'name'</span>] = <span class="string">'jack'</span></span><br><span class="line">批量改自身 <span class="built_in">Object</span>.assign(obj,&#123;<span class="attr">age</span>:<span class="string">'18'</span>,...&#125;)</span><br><span class="line">改共有属性 obj.__proto__[<span class="string">'toString'</span>] = <span class="string">'xxx'</span></span><br><span class="line">改共有属性 object.prototype[<span class="string">'toString'</span>] = <span class="string">'xxx'</span></span><br><span class="line">该原型 obj.__proto__ = common</span><br><span class="line">该原型 <span class="keyword">let</span> obj = object.create = common</span><br><span class="line"></span><br><span class="line">重点</span><br><span class="line">所有 __proto__ 代码都是强烈不推荐的使用的</span><br></pre></td></tr></table></figure>

<p><strong>增</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本上和“改”一样，已有的属性就是改，没有的属性就是增加</span><br></pre></td></tr></table></figure>

<p>[原文地址](JS数据类型复杂类型学习之增删改查 - Alejandro的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/86563057" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86563057</a>)</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/31/post-Vue组件通信的六种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/31/post-Vue组件通信的六种方式/" class="post-title-link" itemprop="url">post Vue组件通信的六种方式</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-31 17:04:39 / 修改时间：19:00:50" itemprop="dateCreated datePublished" datetime="2019-08-31T17:04:39+08:00">2019-08-31</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue组件通信的六种方式"><a href="#Vue组件通信的六种方式" class="headerlink" title="Vue组件通信的六种方式"></a>Vue组件通信的六种方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/17/16ac35bf70530315?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="组件间的关系"></p>
<p>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p>
<p>针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。本文总结了vue组件间通信的几种方式，如props、<code>$emit</code>/<code>$on</code>、vuex、<code>$parent</code> / <code>$children</code>、<code>$attrs</code>/<code>$listeners</code>和provide/inject，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。</p>
<p>本文的代码请猛戳<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fljianshu%2FBlog%2Ftree%2Fmaster%2Fvue2.0%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener">github博客</a>，纸上得来终觉浅，大家动手多敲敲代码！</p>
<h2 id="方法一-props-emit"><a href="#方法一-props-emit" class="headerlink" title="方法一     props/$emit"></a>方法一     props/$emit</h2><p>父组件通过props的方式向子组件B传递，B to A通过在 B 组件中<code>$emti</code>，父组件中v-on的方式实现。</p>
<h3 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1.父组件向子组件传值"></a>1.父组件向子组件传值</h3><p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件<code>Users.vue</code>中如何获取父组件App.vue中的数据 <code>users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//App.vue父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Users from &quot;./components/Users&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    &quot;users&quot;:Users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//users子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HelloWorld&apos;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    users:&#123;           //这个就是父组件中子标签自定义名字</span><br><span class="line">      type:Array,</span><br><span class="line">      required:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</strong></p>
<h3 id="2-子组件向父组件传值（通过事件形式）"><a href="#2-子组件向父组件传值（通过事件形式）" class="headerlink" title="2.子组件向父组件传值（通过事件形式）"></a>2.子组件向父组件传值（通过事件形式）</h3><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/17/16ac35bf70ac2d51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1 @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app-header&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title:&quot;Vue.js Demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeTitle() &#123;</span><br><span class="line">      this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件  传递值“子向父组件传值”</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致</span><br><span class="line">   // updateTitle($event)接受传递过来的文字</span><br><span class="line">    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &quot;./components/Header&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      title:&quot;传递的是一个值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateTitle(e)&#123;   //声明这个函数</span><br><span class="line">      this.title = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">   &quot;app-header&quot;:Header,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</strong></p>
<h2 id="方法二、-emit-on"><a href="#方法二、-emit-on" class="headerlink" title="方法二、$emit/$on"></a>方法二、<code>$emit</code>/<code>$on</code></h2><p><strong>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p>
<p>实现方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bus.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>

<p>在需要通信的组件中都引入<code>bus.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"emit"</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"bus"</span>&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt; </span><br><span class="line">&lt;<span class="regexp">/template &gt; </span></span><br><span class="line"><span class="regexp">import Bus from './</span>bus.js<span class="string">'</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: '</span><span class="string">'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    bus() &#123;</span></span><br><span class="line"><span class="string">      Bus.$emit('</span>msg<span class="string">', '</span>我要传给兄弟组件们，你收到没有<span class="string">')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在钩子函数中监听 msg 事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"on"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">import Bus from './</span>bus.js<span class="string">'</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        message:  '</span><span class="string">'</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    mounted() &#123;　　　</span></span><br><span class="line"><span class="string">       let self = this</span></span><br><span class="line"><span class="string">       Bus.$on('</span>msg<span class="string">', (e) =&gt; &#123;</span></span><br><span class="line"><span class="string">         self.message = e</span></span><br><span class="line"><span class="string">         console.log(`传来的数据是：$&#123;e&#125;`)</span></span><br><span class="line"><span class="string">       &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>

<p>最后 p 会显示来自 $emit 传来的信息。</p>
<p>另外一个使用<code>Bus.js</code>来实现的非父子组件间的传值：地址：<a href="https://github.com/chenyinkai/blog/issues/28" target="_blank" rel="noopener">https://github.com/chenyinkai/blog/issues/28</a></p>
<p>首先新建一个<code>bus.js</code>，使用一个空的Vue实例作为事件总线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bus.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>

<p>再创建两个组件，兄弟关系：</p>
<p><code>a</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">a.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;aa&quot;&gt;</span><br><span class="line">	&#123;&#123;msg&#125;&#125;</span><br><span class="line">	&lt;button @click=&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &quot;../bus&quot;;// 引入bus.js</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;aa&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;this is aa component&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toBus() &#123;</span><br><span class="line">      Bus.$emit(&quot;on&quot;, &quot;data from aa component&quot;);// 发送 `on` 事件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><code>b</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">b.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;bb&quot;&gt;</span><br><span class="line">      &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &quot;../bus&quot;;// 引入bus.js</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;bb&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;this is bb component&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    Bus.$on(&quot;on&quot;, msg =&gt; &#123; // 监听 `on` 事件</span><br><span class="line">      this.msg = msg;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>最后将 <code>a</code> , <code>b</code> 组件展示出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;A&gt;&lt;/A&gt;</span><br><span class="line">    &lt;B&gt;&lt;/B&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import A from &apos;./a.vue&apos;</span><br><span class="line">import B from &apos;./b.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HelloWorld&apos;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    A,</span><br><span class="line">    B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>此时点击 <code>a</code> 组件中的按钮，就会发现 <code>b</code> 中的 <code>msg</code> 变成了 <code>data from aa component</code></p>
<h2 id="方法三：vuex"><a href="#方法三：vuex" class="headerlink" title="方法三：vuex"></a>方法三：vuex</h2><p><img src="https://user-gold-cdn.xitu.io/2019/5/17/16ac35bf70ef8eb1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h3 id="1-简要介绍Vuex原理"><a href="#1-简要介绍Vuex原理" class="headerlink" title="1.简要介绍Vuex原理"></a>1.简要介绍Vuex原理</h3><p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p>
<h3 id="2-简要介绍各模块在流程中的功能："><a href="#2-简要介绍各模块在流程中的功能：" class="headerlink" title="2.简要介绍各模块在流程中的功能："></a>2.简要介绍各模块在流程中的功能：</h3><ul>
<li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li>dispatch：操作行为触发方法，是唯一能执行action的方法。</li>
<li>actions：<strong>操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state</strong>。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li>
<li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
<li>mutations：<strong>状态改变操作方法，由actions中的commit(‘mutation 名称’)来触发</strong>。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li>
<li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li>
<li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li>
</ul>
<h3 id="3-Vuex与localStorage"><a href="#3-Vuex与localStorage" class="headerlink" title="3.Vuex与localStorage"></a>3.Vuex与localStorage</h3><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，<strong>具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultCity = <span class="string">"上海"</span></span><br><span class="line"><span class="keyword">try</span> &#123;   <span class="comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span></span><br><span class="line">  <span class="keyword">if</span> (!defaultCity)&#123;</span><br><span class="line">    defaultCity = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'defaultCity'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity(state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.localStorage.setItem(<span class="string">'defaultCity'</span>, <span class="built_in">JSON</span>.stringify(state.city));</span><br><span class="line">      <span class="comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(state.subscribeList);   <span class="comment">// array -&gt; string</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">"subscribeList"</span>));    <span class="comment">// string -&gt; array</span></span><br></pre></td></tr></table></figure>

<h2 id="方法四、-attrs-listeners"><a href="#方法四、-attrs-listeners" class="headerlink" title="方法四、$attrs/$listeners"></a>方法四、<code>$attrs</code>/<code>$listeners</code></h2><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-<code>$attrs</code>/<code>$listeners</code></p>
<ul>
<li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li>
</ul>
<p>接下来我们看个跨级通信的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;浪里行舟&lt;/h2&gt;</span><br><span class="line">    &lt;child-com1</span><br><span class="line">      :foo=&quot;foo&quot;</span><br><span class="line">      :boo=&quot;boo&quot;</span><br><span class="line">      :coo=&quot;coo&quot;</span><br><span class="line">      :doo=&quot;doo&quot;</span><br><span class="line">      title=&quot;前端工匠&quot;</span><br><span class="line">    &gt;&lt;/child-com1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; childCom1 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &quot;Javascript&quot;,</span><br><span class="line">      boo: &quot;Html&quot;,</span><br><span class="line">      coo: &quot;CSS&quot;,</span><br><span class="line">      doo: &quot;Vue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// childCom1.vue</span><br><span class="line">&lt;template class=&quot;border&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom2</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    foo: String // foo作为props属性绑定</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// childCom2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom3</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    boo: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// childCom3.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    coo: String,</span><br><span class="line">    title: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/5/17/16ac35bf77e44744?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p>如上图所示<code>$attrs``$attrs``$listeners</code></p>
<p>简单来说：<code>$attrs</code>与<code>$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</p>
<h2 id="方法五、provide-inject"><a href="#方法五、provide-inject" class="headerlink" title="方法五、provide/inject"></a>方法五、provide/inject</h2><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><p>Vue2.2.0新增API,这对选项需要一起使用，<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。 <strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p>
<h4 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2.举个例子"></a>2.举个例子</h4><p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: <span class="string">'浪里行舟'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">'name'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">// 浪里行舟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 A.vue 里，我们设置了一个 <strong>provide: name</strong>，值为 浪里行舟，它的作用就是将 <strong>name</strong> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <strong>name</strong> 变量，那么在组件 B 中，就可以直接通过 <strong>this.name</strong> 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。</p>
<p>需要注意的是：<strong>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</strong>—-vue官方文档 所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。</p>
<h4 id="3-provide与inject-怎么实现数据响应式"><a href="#3-provide与inject-怎么实现数据响应式" class="headerlink" title="3.provide与inject 怎么实现数据响应式"></a>3.provide与inject 怎么实现数据响应式</h4><p>一般来说，有两种办法：</p>
<ul>
<li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</li>
<li>使用2.6最新API Vue.observable 优化响应式 provide(推荐)</li>
</ul>
<p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/17/16ac35bf7131f3db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 组件 </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;h1&gt;A 组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button @click="() =&gt; changeColor()"&gt;改变color&lt;/</span>button&gt;</span><br><span class="line">      &lt;ChildrenB /&gt;</span><br><span class="line">      &lt;ChildrenC /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      color: "blue"</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ provide() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   return &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     theme: &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/       color: this.color /</span><span class="regexp">/这种方式绑定的数据并不是可响应的</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     &#125; /</span><span class="regexp">/ 即A组件的color变化后，组件D、E、F不会跟着变</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   &#125;;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ &#125;,</span></span><br><span class="line"><span class="regexp">  provide() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      theme: this/</span><span class="regexp">/方法一：提供祖先组件的实例</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    changeColor(color) &#123;</span></span><br><span class="line"><span class="regexp">      if (color) &#123;</span></span><br><span class="line"><span class="regexp">        this.color = color;</span></span><br><span class="line"><span class="regexp">      &#125; else &#123;</span></span><br><span class="line"><span class="regexp">        this.color = this.color === "blue" ? "red" : "blue";</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 方法二:使用2.6最新API Vue.observable 优化响应式 provide</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ provide() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   this.theme = Vue.observable(&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     color: "blue"</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   &#125;);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   return &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     theme: this.theme</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   &#125;;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ methods: &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   changeColor(color) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     if (color) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/       this.theme.color = color;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     &#125; else &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/       this.theme.color = this.theme.color === "blue" ? "red" : "blue";</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/     &#125;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/   &#125;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F 组件 </span></span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"border2"</span>&gt;</span><br><span class="line">    &lt;h3 :style=<span class="string">"&#123; color: injections.theme.color &#125;"</span>&gt;F 组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  inject: &#123;</span></span><br><span class="line"><span class="regexp">    theme: &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/函数式组件取值不一样</span></span><br><span class="line"><span class="regexp">      default: () =&gt; (&#123;&#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p>
<h2 id="方法六、-parent-children与-ref"><a href="#方法六、-parent-children与-ref" class="headerlink" title="方法六、$parent / $children与 ref"></a>方法六、<code>$parent</code> / <code>$children</code>与 <code>ref</code></h2><ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li>
</ul>
<p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component-a 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">'Vue.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="built_in">window</span>.alert(<span class="string">'Hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=<span class="string">"comA"</span>&gt;&lt;<span class="regexp">/component-a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="keyword">const</span> comA = <span class="keyword">this</span>.$refs.comA;</span><br><span class="line">      <span class="built_in">console</span>.log(comA.title);  <span class="comment">// Vue.js</span></span><br><span class="line">      comA.sayHello();  <span class="comment">// 弹窗</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过，<strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// parent.vue</span><br><span class="line">&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br></pre></td></tr></table></figure>

<p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常见使用场景可以分为三类：</p>
<ul>
<li>父子通信： 父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></li>
<li>兄弟通信： Bus；Vuex</li>
<li>跨级通信： Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/26/post-js中优雅的小数取整/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/26/post-js中优雅的小数取整/" class="post-title-link" itemprop="url">post js中优雅的小数取整</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 22:14:26 / 修改时间：22:15:04" itemprop="dateCreated datePublished" datetime="2019-08-26T22:14:26+08:00">2019-08-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="js中的优雅的小数取整"><a href="#js中的优雅的小数取整" class="headerlink" title="js中的优雅的小数取整"></a>js中的优雅的小数取整</h1><p><a href="https://github.com/akira-cn/FE_You_dont_know/issues/5" target="_blank" rel="noopener">参考文章</a></p>
<p>如何优雅地取数值的整数和小数部分</p>
<p>在处理数值的时候，获取浮点数的整数和小数部分，是一种常见的操作，在JavaScript中有许多方法可以达到目的，但也正因为方法众多，所以哪种方法更好，也值得我们仔细研究一番。</p>
<h4 id="取整数"><a href="#取整数" class="headerlink" title="取整数"></a>取整数</h4><p>parseInt比较常用来取整数部分，在一些项目中经常能看到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(num)); <span class="comment">// 3</span></span><br><span class="line">num = <span class="number">-3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(num)); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<p>用parseInt取整数，一般情况下，结果是没问题的，但是如果严格来说，其实parseInt并不是设计用来取整数的。</p>
<p>👉🏻 <font color="red"><strong>知识点：</strong></font> parseInt(string, radix) 这个方法是一个将字符串转换为整数的方法，它有两个参数，第一个参数表示要转换的字符串，如果参数不是一个字符串，则将其转换为字符串。第二个参数是基数即进制，默认为10。</p>
<p>所以实际上parseInt(3.75)这个代码，会先将3.75转为字符串”3.75”，然后再将它parseInt成为3。</p>
<p>所以用parseInt方法取整数，有两个不好的地方，一是parseInt这个函数名，看起来就是将字符串转整数的，用在这里不是很适合，另一个是转字符串有点多此一举，而且肯定会带来性能开销，所以使用parseInt虽然方便，但不是最好的办法。</p>
<p>💡<font color="red"><strong>补充：</strong></font><br>parseInt中的这个toString不仅仅是“多此一举”，还可能导致严重的问题，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">0.00000001</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">1000000000000000000000</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这是因为，0.00000001.toString() === 1e-8而1000000000000000000000.toString() === 1e+21。</p>
<p>既然parseInt不好用，有经验的同学，会想到用Math的方法来取整，相关的有3个方法，分别是<code>Math.ceil</code>、<code>Math.round</code>和<code>Math.floor</code>。</p>
<p>其中<code>Math.round</code>是四舍五入的，<code>Math.ceil</code>是向上取整，<code>Math.floor</code>是向下取整。</p>
<p>要达到parseInt的结果，我们需要判断数值的符号，如果是负数，要使用Math.ceil，如果是正数，则使用Math.floor：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trunc</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.floor(num);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(trunc(<span class="number">3.75</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(trunc(<span class="number">-3.75</span>)); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<p>使用Math.round和Math.ceil实现trunc方法，要比使用parseInt的性能好，因为省去了转字符串。</p>
<p>实际上，在ES2015之后，还提供了原生的Math.trunc，我们可以更方便地使用Math.trunc，不用自己使用Math.floor和Math.ceil去实现了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES 2015</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">3.75</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-3.75</span>)); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<p>狡猾的取整方式(tricky(机警的，狡猾的))</p>
<p>如果看一些库的代码，你可能会看到这样的取整方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure>

<p>这是一种利用位或“|”操作来取整的手段，老司机经常用，我以前也用。</p>
<p>位或运算为什么能达到我们的效果呢，具体可以看<a href="http://www.ecma-international.org/ecma-262/10.0/index.html#prod-BitwiseORExpression" target="_blank" rel="noopener">ECMA-262</a>文档</p>
<p><img src="https://camo.githubusercontent.com/1b853f176e8e7f610957ffdfd2a5f13c81c72934/68747470733a2f2f70342e73736c2e7168696d672e636f6d2f743031383664373630373538636163643566362e6a7067" alt="img"></p>
<p>对位操作的处理中，第5、6步，会把操作数转为Int32，所以我们就可以利用这个特点来使用“|”操作符了。</p>
<p>不过这么做也是有缺陷的，你发现问题了吗？</p>
<p>👉🏻 <strong>冷知识</strong>：因为bitwise操作将操作数转为Int32，所以它不能处理超过32位的数值取整，而JavaScript有效整数的范围是53位。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">17179869184.89</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(num)); <span class="comment">// 17179869184</span></span><br></pre></td></tr></table></figure>

<p>那么用“|”有什么好处呢？如果考虑js文件大小，那么<code>a|0</code>与其他方式比较，是最短的方式，所以如果要考虑压缩代码的大小，且明确知道数值范围不会超过32位整数的时候，可以考虑使用这个技巧。</p>
<h4 id="取小数"><a href="#取小数" class="headerlink" title="取小数"></a>取小数</h4><p>取了整数部分，接下来取小数部分就很简单了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fract</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num - <span class="built_in">Math</span>.trunc(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fract(<span class="number">3.75</span>)); <span class="comment">// 0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(fract(<span class="number">-3.75</span>)); <span class="comment">// -0.75</span></span><br></pre></td></tr></table></figure>

<p>上面的代码思路就是先用<code>Math.trunc(num)</code>取整，然后再与原数相减，就得到了小数部分。</p>
<p>但是，我们还有更加简单的办法：</p>
<p>👉🏻 <strong>知识点</strong>：JavaScript的取模运算%并不限于整数运算，可以对浮点数取模。</p>
<p>所以，直接将原数对1取模，即可获得小数部分！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3.75</span> % <span class="number">1</span>); <span class="comment">// 0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-3.75</span> % <span class="number">1</span>); <span class="comment">// -0.75</span></span><br></pre></td></tr></table></figure>

<p>这是最简单的取小数的方式，然后反过来，还可以倒推出另一种实现trunc取整的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trunc</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num - num % <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>取小数部分，可以用来实现周期函数，比如实现匀速的js周期动画：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"progress_bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#progress_bar</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">el, duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p = (<span class="built_in">Date</span>.now() - startTime) / duration;</span><br><span class="line">    p %= <span class="number">1</span>;</span><br><span class="line">    el.style.width = <span class="string">`<span class="subst">$&#123;<span class="number">300</span> * p&#125;</span>px`</span>;</span><br><span class="line">    requestAnimationFrame(update);</span><br><span class="line">  &#125;</span><br><span class="line">  update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">document</span>.getElementById(<span class="string">'progress_bar'</span>);</span><br><span class="line">run(bar, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们的周期函数要考虑负数那一半区间，其实fract的方式要修改一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fract</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num - <span class="built_in">Math</span>.floor(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方式才是正确的周期，它和之前的实现区别是负数区间返回的值不同，前者负数返回的小数部分为负数，这个实现中，如果num是正数，返回num的小数部分，如果num是负数，返回1.0 + num的负数小数部分，这样就保证返回值始终在0.0~1.0的区间内。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fract</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num - <span class="built_in">Math</span>.floor(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-3.75</span> % <span class="number">1</span>); <span class="comment">// -0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(fract(num)); <span class="comment">// 0.25</span></span><br></pre></td></tr></table></figure>

<p>好了，关于取整和取小数的讨论就到这里。如果你们还有哪些关于取整和取小数的问题，欢迎在issue中讨论。</p>
<p>还有一个比较常见的parseInt的问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000001</span>); <span class="comment">// 1，这也是一个常见的坑</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"0.0000001"</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="number">0.0000001</span>.toString(); <span class="comment">// "1e-7"</span></span><br></pre></td></tr></table></figure>

<p>### </p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/26/post-cookie的添加、查询及删除/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/26/post-cookie的添加、查询及删除/" class="post-title-link" itemprop="url">post cookie的添加、查询及删除</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 22:11:19 / 修改时间：22:13:36" itemprop="dateCreated datePublished" datetime="2019-08-26T22:11:19+08:00">2019-08-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><a href="<https://segmentfault.com/a/1190000004556040">参考文章</a></p>
<p>设置cookie的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetCookie</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    exp.setTime(exp.getTime() + <span class="number">60</span> * <span class="number">2000</span>);<span class="comment">//过期时间 2分钟</span></span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + <span class="built_in">escape</span>(value) + <span class="string">";expires="</span> + exp.toGMTString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除所有的cookie的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearAllCookie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">var</span> keys = <span class="built_in">document</span>.cookie.match(<span class="regexp">/[^ =;]+(?=\=)/g</span>);</span><br><span class="line">				<span class="keyword">if</span>(keys) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">var</span> i = keys.length; i--;)</span><br><span class="line">						<span class="built_in">document</span>.cookie = keys[i] + <span class="string">'=0;domain=xx;path=xx;expires='</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>).toUTCString()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>注意：需要设置cookie的域名和路径</p>
<p>查询cookie：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cookieStr = <span class="built_in">document</span>.cookie,</span><br><span class="line">        cookieArr = cookieStr.split(<span class="string">";"</span>),</span><br><span class="line">        res = []	这个数组用来存储结果</span><br><span class="line">   	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cookieArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> t = cookieArr[i].split(<span class="string">"="</span>)</span><br><span class="line">        params.forEach(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>].trim() == item) &#123;    trim()去掉两边的空格，避免出错</span><br><span class="line">                res.push(t[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中传入的参数是数组形式。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/26/post-element-ui-树形控件的自定义样式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/26/post-element-ui-树形控件的自定义样式/" class="post-title-link" itemprop="url">post element-ui 树形控件的自定义样式</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 22:09:15 / 修改时间：22:20:00" itemprop="dateCreated datePublished" datetime="2019-08-26T22:09:15+08:00">2019-08-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="针对element-ui的树形控件的自定义样式"><a href="#针对element-ui的树形控件的自定义样式" class="headerlink" title="针对element-ui的树形控件的自定义样式"></a>针对element-ui的树形控件的自定义样式</h1><p><strong>对于样式的自定义，参考的文章是</strong>：<a href="https://blog.csdn.net/qq_36437172/article/details/86307048" target="_blank" rel="noopener">https://blog.csdn.net/qq_36437172/article/details/86307048</a></p>
<p>其中自定义树形控件默认图标之后的图标可以使用下边的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-tree&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"slot-t-node"</span> slot-scope=<span class="string">"&#123; node, data &#125;"</span>&gt;</span><br><span class="line">        &lt;i :<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; 'fa fa-folder': !node.expanded, 'fa fa-folder-open':node.expanded&#125;"</span> style=<span class="string">"color: #fcd568;"</span> /&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/el-tree&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是自定义图标的一种方式，<a href="https://element.eleme.cn/#/zh-CN/component/tree" target="_blank" rel="noopener">官网</a>提供了两种 render 和 slot 来添加自定义节点内容，可以在节点区添加按钮或图标等。</p>
<p>对于上边的代码：node.expanded是节点展开状态。</p>
<p>在这里就可以自定义设置图标的各种样式。</p>
<p><strong>修改默认的三角图标</strong></p>
<p>tree控件使用的时候默认是带三角图标的</p>
<p><img src="images%5C1565937063033.png" alt="1565937063033"></p>
<p>可以通过<code>icon-class</code>来自定义这个图标，有一个需求是，需要在前边显示+，当点击展开的时候，切换为-，目前想到的方法是用css直接去写样式，相对比较好操作，首先对tree的自定义图标这么写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span></span></span><br><span class="line"><span class="tag"><span class="attr">icon-class</span>=<span class="string">"plus plus_"</span>        </span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中plus是对应的加号+的样式，plus_对应的是减号-的样式，然后在外部的css文件中定义这俩个类的样式，为什么要在外部定义，因为如果在组建内部定义的话，由于scoped的限制，样式不会生效</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">外部的<span class="selector-tag">css</span>文件</span><br><span class="line"><span class="selector-class">.plus</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">transition</span>: color .<span class="number">25s</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.plus</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">10px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.plus</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">     <span class="attribute">position</span>: absolute;</span><br><span class="line">     <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">     <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">     <span class="attribute">margin-left</span>: -<span class="number">5px</span>;</span><br><span class="line">     <span class="attribute">margin-top</span>: -<span class="number">40px</span>;</span><br><span class="line">     <span class="attribute">border-left</span>: <span class="number">10px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line">其中的具体的样式在根据实际的需求进行更改，之后只需要再设置以下节点展开状态的样式</span><br><span class="line"><span class="selector-class">.expanded</span><span class="selector-class">.plus_</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">还需要取消<span class="selector-tag">tree</span>控件的默认的图标旋转样式</span><br><span class="line"><span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在使用了树形控件的组件内部引入该样式文件，便可以生效。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/26/post-关于更改checkbox的样式的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/26/post-关于更改checkbox的样式的问题/" class="post-title-link" itemprop="url">post 关于更改checkbox的样式的问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 22:07:17 / 修改时间：22:08:38" itemprop="dateCreated datePublished" datetime="2019-08-26T22:07:17+08:00">2019-08-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于更改checkbox样式的问题"><a href="#关于更改checkbox样式的问题" class="headerlink" title="关于更改checkbox样式的问题"></a>关于更改checkbox样式的问题</h1><p>很多时候我们需要修改check的默认样式以达到更好的ui效果，但是实际上checkbox的样式是由浏览器决定的，这就增加了修改的难度，所以如果想要修改checkbox的样式，一般都是用<code>label</code>来模拟checkbox。</p>
<p>具体的代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"check"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"check"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">'checkbox'</span>]</span>&#123;</span></span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"checkbox"</span>]</span>+<span class="selector-tag">label</span>&#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    -webkit-box-sizing: border-box;</span><br><span class="line">    -moz-box-sizing: border-box;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"checkbox"</span>]</span>+<span class="selector-tag">label</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">content</span><span class="selector-pseudo">:''</span>;</span></span><br><span class="line">        display: inline-block;</span><br><span class="line">        width: 14px;</span><br><span class="line">        height: 14px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">        vertical-align: middle;</span><br><span class="line"><span class="css">        <span class="selector-tag">-webkit-transition</span>: <span class="selector-tag">background</span> <span class="selector-tag">ease-in</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">-o-transition</span>: <span class="selector-tag">background</span> <span class="selector-tag">ease-in</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">transition</span>: <span class="selector-tag">background</span> <span class="selector-tag">ease-in</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"checkbox"</span>]</span><span class="selector-pseudo">:checked</span> +<span class="selector-tag">label</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line">    background-color: green</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样出来的效果就是：点击后按钮就会变为绿色，针对以上的方法，进行优化：</p>
<p>如果想要给checkbox添加对勾的话，就可以</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"check"</span> <span class="attr">class</span>=<span class="string">"fa fa-check"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">这里可以为label设置相应的icon图标类，之后在css中</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"checkbox"</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">content</span><span class="selector-pseudo">:"</span>对应的<span class="selector-tag">icon</span>图标的<span class="selector-tag">unicode</span>码",</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ddd</span>;</span></span><br><span class="line">        设置该checkbox被选中时候的边框样式</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>### </p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/26/post-Vue实现监听浏览器的返回按钮/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/26/post-Vue实现监听浏览器的返回按钮/" class="post-title-link" itemprop="url">post Vue实现监听浏览器的返回按钮</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 22:03:42 / 修改时间：22:05:38" itemprop="dateCreated datePublished" datetime="2019-08-26T22:03:42+08:00">2019-08-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vue实现监听浏览器的左上角的返回按钮"><a href="#vue实现监听浏览器的左上角的返回按钮" class="headerlink" title="vue实现监听浏览器的左上角的返回按钮"></a>vue实现监听浏览器的左上角的返回按钮</h1><p><a href="[https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#组件内的守卫)">官方文档</a></p>
<p>可以使用路由守卫：</p>
<p>后台管理中监听的浏览器的返回事件就是通过路由守卫实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">      <span class="comment">// 导航守卫===》导航离开该组件的对应路由时调用</span></span><br><span class="line">      <span class="comment">/* to:即将要进入的目标 路由对象</span></span><br><span class="line"><span class="comment">         from: 当前导航正要离开的路由</span></span><br><span class="line"><span class="comment">         next:执行的效果，next(false): 中断当前的导航  next(&#123; path: '/' &#125;): 跳转到一个不同的地址</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span>(to.fullPath == <span class="string">'/1'</span> || to.fullPath == <span class="string">'/2'</span>|| to.fullPath == <span class="string">'/3'</span>)&#123;</span><br><span class="line">            next();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          MessageBox(&#123;</span><br><span class="line">            title: <span class="string">'提示'</span>,</span><br><span class="line">            message: <span class="string">'您确定要返回吗?'</span>,</span><br><span class="line">            showCancelButton: <span class="literal">true</span>,</span><br><span class="line">            closeOnClickModal:<span class="literal">true</span></span><br><span class="line">          &#125;).then(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(action == <span class="string">'confirm'</span>)&#123;</span><br><span class="line">              next();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              next(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中MessageBox是Mint-ui中的提示框，可以更换为其他的插件。</span></span><br></pre></td></tr></table></figure>

<p>beforeRouteLeave是一个生命周期函数，可以全局的使用或者是在需要使用的组件的内部使用。</p>
<h2 id="对于全局的路由守卫router-beforeEach"><a href="#对于全局的路由守卫router-beforeEach" class="headerlink" title="对于全局的路由守卫router.beforeEach"></a>对于全局的路由守卫router.beforeEach</h2><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong>to: Route</strong>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#路由对象" target="_blank" rel="noopener">路由对象</a></li>
<li><strong>from: Route</strong>: 当前导航正要离开的路由</li>
<li><strong>next: Function</strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><strong>next()</strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li>
<li><strong>next(false)</strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><strong>next(‘/‘) 或者 next({ path: ‘/‘ })</strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://router.vuejs.org/zh/api/#to" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://router.vuejs.org/zh/api/#router-push" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。</li>
<li><strong>next(error)</strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://router.vuejs.org/zh/api/#router-onerror" target="_blank" rel="noopener"><code>router.onError()</code></a> 注册过的回调。</li>
</ul>
</li>
</ul>
<p><strong>确保要调用 next 方法，否则钩子就不会被 resolved。</strong></p>
<h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code> (2.2 新增)</li>
<li><code>beforeRouteLeave</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// just use `this`</span></span><br><span class="line">  <span class="keyword">this</span>.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span> , next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">'Do you really want to leave? you have unsaved changes!'</span>)</span><br><span class="line">  <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h2><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ol>
<p>另外的一个例子：<a href="https://www.jianshu.com/p/9c8da115ba2e" target="_blank" rel="noopener">监听浏览器返回并且清除缓存</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/08/26/post-js判断某个字符串中是否包含指定字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/08/26/post-js判断某个字符串中是否包含指定字符串/" class="post-title-link" itemprop="url">post js判断某个字符串中是否包含指定字符串</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 22:01:45 / 修改时间：22:02:42" itemprop="dateCreated datePublished" datetime="2019-08-26T22:01:45+08:00">2019-08-26</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="js判断某个字符串中是否包含有某个字符串"><a href="#js判断某个字符串中是否包含有某个字符串" class="headerlink" title="js判断某个字符串中是否包含有某个字符串"></a>js判断某个字符串中是否包含有某个字符串</h1><h4 id="方法一：indexOf-（推荐）"><a href="#方法一：indexOf-（推荐）" class="headerlink" title="方法一：indexOf()（推荐）"></a>方法一：indexOf()（推荐）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"3"</span>) != <span class="number">-1</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。</p>
<h4 id="方法二-search"><a href="#方法二-search" class="headerlink" title="方法二: search()"></a>方法二: search()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">"3"</span>) != <span class="number">-1</span> );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</p>
<h4 id="方法三-match"><a href="#方法三-match" class="headerlink" title="方法三:match()"></a>方法三:match()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(str.match(reg))&#123;</span><br><span class="line">    <span class="comment">// 包含        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a><strong>RegExp 对象方法</strong></h4><h4 id="方法四-test"><a href="#方法四-test" class="headerlink" title="方法四:test()"></a>方法四:test()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>test() 方法用于检索字符串中指定的值。返回 true 或 false。</p>
<h4 id="方法五-exec"><a href="#方法五-exec" class="headerlink" title="方法五:exec()"></a>方法五:exec()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(reg.exec(str))&#123;</span><br><span class="line">    <span class="comment">// 包含        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/niuxinyublog/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/niuxinyublog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/niuxinyublog/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/niuxinyublog/page/6/">6</a><a class="extend next" rel="next" href="/niuxinyublog/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Niu</p>
  <div class="site-description" itemprop="description">文章</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/niuxinyublog/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Niu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/niuxinyublog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/niuxinyublog/js/utils.js?v=7.4.0"></script><script src="/niuxinyublog/js/motion.js?v=7.4.0"></script>
<script src="/niuxinyublog/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/niuxinyublog/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
