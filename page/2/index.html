<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/niuxinyublog/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/niuxinyublog/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/niuxinyublog/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/niuxinyublog/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/niuxinyublog/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/niuxinyublog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/niuxinyublog/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="文章">
<meta property="og:type" content="website">
<meta property="og:title" content="niu的blog">
<meta property="og:url" content="https://niuxinyu.github.io/niuxinyublog/page/2/index.html">
<meta property="og:site_name" content="niu的blog">
<meta property="og:description" content="文章">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="niu的blog">
<meta name="twitter:description" content="文章">
  <link rel="canonical" href="https://niuxinyu.github.io/niuxinyublog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>niu的blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/niuxinyublog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">niu的blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/niuxinyublog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/niuxinyublog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/18/uni-app-开发遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/18/uni-app-开发遇到的问题/" class="post-title-link" itemprop="url">uni-app 开发遇到的问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-18 21:02:20 / 修改时间：21:04:50" itemprop="dateCreated datePublished" datetime="2020-02-18T21:02:20+08:00">2020-02-18</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uni-app-开发遇到的问题"><a href="#uni-app-开发遇到的问题" class="headerlink" title="uni-app 开发遇到的问题"></a>uni-app 开发遇到的问题</h1><p>uni-app 去除顶部的状态栏之后导致的沉浸式全屏，可以通过设置几个全局的css变量来解决</p>
<h2 id="App去除导航栏后改变状态栏样式"><a href="#App去除导航栏后改变状态栏样式" class="headerlink" title="App去除导航栏后改变状态栏样式"></a>App去除导航栏后改变状态栏样式</h2><p>App因为默认为沉浸式，去除<code>导航栏</code>后，页面顶部会直通到<code>状态栏</code>的区域，可能出现如下需求：</p>
<ul>
<li>改变状态栏文字颜色：设置该页面的 <code>navigationBarTextStyle</code> 属性，可取值为 black/white。如果想单独设置颜色，App端可使用<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.html5plus.org%2Fdoc%2Fzh_cn%2Fnavigator.html%23plus.navigator.setStatusBarStyle" target="_blank" rel="noopener">plus.navigator.setStatusBarStyle</a>设置。部分低端Android手机（4.4）自身不支持设置状态栏前景色。</li>
<li>改变状态栏背景颜色：通过绘制一个占位的view固定放在状态栏位置，设置此view的背景颜色，即可达到想要的效果，uni-app提供了一个状态栏高度的css变量，具体参考：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Funiapp.dcloud.io%2Fframe%3Fid%3Dcss%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">uni-app内置的CSS变量</a>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;!-- #ifdef APP-PLUS --&gt;  </span><br><span class="line">        &lt;view class=&quot;status_bar&quot;&gt;  </span><br><span class="line">            &lt;view class=&quot;top_view&quot;&gt;&lt;/view&gt;  </span><br><span class="line">        &lt;/view&gt;  </span><br><span class="line">        &lt;!-- #endif --&gt; </span><br><span class="line">        &lt;view&gt;  </span><br><span class="line">            </span><br><span class="line">        &lt;/view&gt; </span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.status_bar &#123;  </span><br><span class="line">    height: var(--status-bar-height);  </span><br><span class="line">    width: 100%;  </span><br><span class="line">    background-color: #F8F8F8;  </span><br><span class="line">&#125;  </span><br><span class="line">.top_view &#123;  </span><br><span class="line">    height: var(--status-bar-height);  </span><br><span class="line">    width: 100%;  </span><br><span class="line">    position: fixed;  </span><br><span class="line">    background-color: #F8F8F8;  </span><br><span class="line">    top: 0;  </span><br><span class="line">    z-index: 999;  </span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>var(–status-bar-height) 此变量在微信小程序环境为固定 25px，在 5+App 里为手机实际状态栏高度。</li>
<li>当设置 “navigationStyle”:”custom” 取消原生导航栏后，由于窗体为沉浸式，占据了状态栏位置。此时可以使用一个高度为 var(–status-bar-height) 的 view 放在页面顶部，避免页面内容出现在状态栏。（实战过程中此方案仍不能解决页面内容出现在状态栏的问题）</li>
</ul>
<p><strong>设置css变量后解决页面顶部会直通到状态栏的区域的问题</strong>：设置了css变量后，手机顶部状态栏区域还是会被页面内容覆盖，可使用<code>plus.navigator.getStatusbarHeight()</code>来动态计算系统状态栏的高度barHeight，然后设置页面主view的样式<code>:style=&quot;{&#39;margin-top&#39;:barHeight+&#39;px&#39;}&quot;，</code>来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view class=&quot;uni-flex uni-column&quot; style=&quot;height: 100%;&quot;&gt;</span><br><span class="line">        &lt;!-- #ifdef APP-PLUS --&gt;  </span><br><span class="line">        &lt;view class=&quot;status_bar&quot;&gt;  </span><br><span class="line">            &lt;view class=&quot;top_view&quot;&gt;&lt;/view&gt; </span><br><span class="line">        &lt;/view&gt;  </span><br><span class="line">        &lt;!-- #endif --&gt; </span><br><span class="line">        </span><br><span class="line">        &lt;view class=&quot;uni-flex uni-row jk-bg-blue uni-center&quot; style=&quot;height: 12%;&quot; :style=&quot;&#123;&apos;margin-top&apos;:barHeight+&apos;px&apos;&#125;&quot;&gt;</span><br><span class="line">            &lt;view class=&quot;flex-sub jk-header uni-flex uni-column justify-start&quot; @tap=&quot;test1&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;text-white cuIcon-scan&quot;&gt;&lt;/text&gt;</span><br><span class="line">                &lt;text&gt;扫码&lt;/text&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;flex-treble jk-header uni-flex uni-column justify-center&quot; @tap=&quot;test2&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;text-white cuIcon-rank&quot;&gt;&lt;/text&gt;</span><br><span class="line">                &lt;text&gt;统计&lt;/text&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;flex-sub jk-header uni-flex uni-column justify-end&quot; @click=&quot;test3&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;text-white cuIcon-exit&quot;&gt;&lt;/text&gt;</span><br><span class="line">                &lt;text&gt;退出&lt;/text&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;view class=&quot;uni-flex align-center uni-row margin-xs&quot; style=&quot;height: 78%;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">        &lt;view class=&quot;uni-flex uni-row uni-center&quot; style=&quot;height: 10%;color: #000000;background-color: F8F8F8;border-top: 3px solid #eee;&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">                </span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var _self;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        uniPopup,</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            barHeight:25,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        //获取系统状态栏高度</span><br><span class="line">        getSystemStatusBarHeight:function()&#123;</span><br><span class="line">            // #ifdef APP-PLUS</span><br><span class="line">            var height = plus.navigator.getStatusbarHeight();</span><br><span class="line">            _self.barHeight = height;</span><br><span class="line">            // #endif</span><br><span class="line">            // #ifdef H5</span><br><span class="line">            _self.barHeight = 0;</span><br><span class="line">            // #endif</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    onLoad:function()&#123;</span><br><span class="line">        _self = this;</span><br><span class="line">        _self.getSystemStatusBarHeight();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt; </span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><code>备注</code>：此种方式经测试，有时页面打开后页面主视图和状态栏区域会留白(留白的高度其实是状态栏高度)。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/18/webstorm-打开Vue项目卡顿问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/18/webstorm-打开Vue项目卡顿问题/" class="post-title-link" itemprop="url">webstorm 打开Vue项目卡顿问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-18 20:56:57 / 修改时间：21:01:38" itemprop="dateCreated datePublished" datetime="2020-02-18T20:56:57+08:00">2020-02-18</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="webstorm-打开Vue项目卡顿问题"><a href="#webstorm-打开Vue项目卡顿问题" class="headerlink" title="webstorm 打开Vue项目卡顿问题"></a>webstorm 打开Vue项目卡顿问题</h1><p>在开发中遇到的一个问题，很让人头疼，使用 <code>webstorm</code> 导入<code>Vue</code>项目之后， <code>cpu</code> 占用率居高不下，并且很快就会提示 <code>low memory</code> 内存不够的警告。</p>
<p>尝试了网上的多种方式，从升高内存到修改 <code>node_modules</code> 到忽略目录，都没有生效。</p>
<p>最终的解决办法是: 在导入项目的时候删掉  <code>node_modules</code> ，然后在 <code>webstorm</code> 中打开项目，再去执行 <code>npm i</code>，这样就可以解决 <code>cpu</code> 及内存占用率高的问题了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/08/记开发中的需求及对应的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/08/记开发中的需求及对应的实现/" class="post-title-link" itemprop="url">记开发中的需求及对应的实现</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-08 22:20:35 / 修改时间：22:33:04" itemprop="dateCreated datePublished" datetime="2020-02-08T22:20:35+08:00">2020-02-08</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="记录开发中遇到的一些需求及最终的解决办法"><a href="#记录开发中遇到的一些需求及最终的解决办法" class="headerlink" title="记录开发中遇到的一些需求及最终的解决办法"></a>记录开发中遇到的一些需求及最终的解决办法</h1><h2 id="加载之后输入框自动获得焦点，点击输入框以外的盒子，焦点不会丢失"><a href="#加载之后输入框自动获得焦点，点击输入框以外的盒子，焦点不会丢失" class="headerlink" title="加载之后输入框自动获得焦点，点击输入框以外的盒子，焦点不会丢失"></a>加载之后输入框自动获得焦点，点击输入框以外的盒子，焦点不会丢失</h2><p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/%E9%9C%80%E6%B1%821.png" alt></p>
<p>实现的办法是，监听外部盒子的 <code>mousedown</code> 事件，然后阻止他的默认行为</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'.div'</span>).addEventListener(<span class="string">'mousedown'</span>, (e) =&gt; &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">    &#125;)</span><br><span class="line">    input.addEventListener(<span class="string">'mousedown'</span>, () =&gt; &#123;</span><br><span class="line">        input.focus()</span><br><span class="line">    &#125;)</span><br><span class="line">    input.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/08/vue-插件开发中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/08/vue-插件开发中遇到的问题/" class="post-title-link" itemprop="url">vue 插件开发中遇到的问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-08 19:56:30 / 修改时间：21:04:12" itemprop="dateCreated datePublished" datetime="2020-02-08T19:56:30+08:00">2020-02-08</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于vue使用脚手架新创建出来应用之后出现的 <code>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</code> 报错信息，在<a href="https://codewithhugo.com/vue-warn-runtime-only-build/" target="_blank" rel="noopener">https://codewithhugo.com/vue-warn-runtime-only-build/</a>  找到了解决办法，解决办法是在 vue.config.js 文件中加入如下的配置  <code>runtimeCompiler: true</code>， 既可以解决报错。报错的情景是在开发vue插件的时候遇到的。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/08/eslint-使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/08/eslint-使用/" class="post-title-link" itemprop="url">eslint 使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-08 19:41:25 / 修改时间：19:55:50" itemprop="dateCreated datePublished" datetime="2020-02-08T19:41:25+08:00">2020-02-08</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装-ESLint"><a href="#安装-ESLint" class="headerlink" title="安装 ESLint"></a>安装 ESLint</h2><p>如果你仅仅想让 ESLint 成为你项目构建系统的一部分，我们可以在项目根目录进行本地安装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure>

<p>如果想使 ESLint 适用于你所有的项目，我们建议使用全局安装，使用全局安装 ESLint 后，你使用的任何 ESLint 插件或可分享的配置也都必须在全局安装。</p>
<p>这里我们使用全局安装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g eslint</span><br></pre></td></tr></table></figure>

<p>安装完毕后，我们使用 <code>eslint --init</code> 命令在用户目录中生成一个配置文件（也可以在任何你喜欢的位置进行生成）</p>
<p>我们在第一个选项中选择自定义代码风格，之后根据需要自行选择。(这里最后一步的询问是否安装依赖可以不安装，因为会导致报错的问题)</p>
<p>设置完成后我们会得到一份文件名为 <code>.eslintrc.js</code> 的配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"commonjs"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"es6"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"eslint:recommended"</span>,</span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"indent"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="number">4</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"linebreak-style"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"windows"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"quotes"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"single"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"semi"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"never"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="配置-ESLint"><a href="#配置-ESLint" class="headerlink" title="配置 ESLint"></a>配置 ESLint</h2><p>配置文件生成之后，我们接着可以进行自定义修改，这里我们只粗略讲解常用的配置项，完整的可配置项可访问<a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>在上文生成的配置文件中可以使用 <code>env</code> 属性来指定要启用的环境，将其设置为 <code>true</code>，以保证在进行代码检测时不会把<a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments" target="_blank" rel="noopener">这些环境</a>预定义的全局变量识别成未定义的变量而报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"commonjs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置语言选项"><a href="#设置语言选项" class="headerlink" title="设置语言选项"></a>设置语言选项</h3><p>默认情况下，ESLint 支持 ECMAScript 5 语法，如果你想启用对 ECMAScript 其它版本和 JSX 等的支持，ESLint 允许你使用 <code>parserOptions</code> 属性进行指定想要支持的 JavaScript <a href="http://eslint.cn/docs/user-guide/configuring#specifying-parser-options" target="_blank" rel="noopener">语言选项</a>，不过你可能需要自行安装 <code>eslint-plugin-react</code> 等插件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"ecmaVersion"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"sourceType"</span>: <span class="string">"module"</span>,</span><br><span class="line">    <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">        <span class="string">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p>在上文的配置文件中， <code>&quot;extends&quot;: &quot;eslint:recommended&quot;</code> 选项表示启用推荐规则，在推荐规则的基础上我们还可以根据需要使用 <code>rules</code> 新增自定义规则，每个规则的第一个值都是代表该规则检测后显示的错误级别：</p>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 将规则视为一个警告</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 将规则视为一个错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"indent"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"linebreak-style"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"windows"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"quotes"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"single"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"semi"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"never"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的可配置规则列表可访问：<a href="http://eslint.cn/docs/rules/" target="_blank" rel="noopener">http://eslint.cn/docs/rules/</a></p>
<p>其中带 <code>√</code> 标记的表示该规则为推荐规则。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/06/5个提升你js编码水平的实例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/06/5个提升你js编码水平的实例/" class="post-title-link" itemprop="url">5个提升你js编码水平的实例</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-06 18:16:50" itemprop="dateCreated datePublished" datetime="2020-02-06T18:16:50+08:00">2020-02-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-08 19:36:04" itemprop="dateModified" datetime="2020-02-08T19:36:04+08:00">2020-02-08</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5个提升你js编码水平的实例"><a href="#5个提升你js编码水平的实例" class="headerlink" title="5个提升你js编码水平的实例"></a>5个提升你js编码水平的实例</h1><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><p>首先来提问一个， <code>typeof</code>是否能正确判断类型？</p>
<p>答案是：不可以，因为由于历史原因，在判断原始类型时，<code>typeof null</code>会等于<code>object</code>。而且对于对象来说，除了函数，都会转换成<code>object</code>。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"1"</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>.alert <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>

<p>再来提问一个，<code>instanceof</code>是否能正确判断类型？</p>
<p>答案是：还是不可以，虽然<code>instanceof</code>是通过原型链来判断的，但是对于对象来说，<code>Array</code>也会被转换成<code>Object</code>，而且也不能区分基本类型<code>string</code>和<code>boolean</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> Func()</span><br><span class="line"><span class="built_in">console</span>.log(func <span class="keyword">instanceof</span> Func) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>)</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以该怎么办呢？</p>
<p>这时候我们可以使用：<code>Object.prototype.toString.call()</code></p>
<p>所以为什么？</p>
<p>因为每个对象都有一个<code>toString()</code>方法，当要将对象表示为文本值或以预期字符串的方式引用对象时，会自动调用该方法。默认情况下，从<code>Object</code>派生的每个对象都会继承<code>toString()</code>方法。如果此方法未在自定义对象中被覆盖，则<code>toString()</code>返回<code>[Object type]</code>，其中<code>type</code>是对象类型。所以就有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">"1"</span>) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// [object Numer]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p>所以综合上述知识点，我们可以封装出以下通用类型判断方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line">    <span class="keyword">var</span> dataType =</span><br><span class="line">        data <span class="keyword">instanceof</span> Element</span><br><span class="line">            ? <span class="string">"element"</span></span><br><span class="line">            : toString</span><br><span class="line">                .call(data)</span><br><span class="line">                .replace(<span class="regexp">/\[object\s(.+)]/</span>, <span class="string">'$1'</span>)</span><br><span class="line">                .toLowerCase()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="string">''</span>)) <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="string">"a"</span>) <span class="comment">// string</span></span><br><span class="line">type(<span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line">type(<span class="built_in">window</span>) <span class="comment">// window</span></span><br><span class="line">type(<span class="built_in">document</span>.querySelector(<span class="string">"h1"</span>)) <span class="comment">// element</span></span><br></pre></td></tr></table></figure>

<h2 id="通用的数组-类数组对象封装"><a href="#通用的数组-类数组对象封装" class="headerlink" title="通用的数组/类数组对象封装"></a>通用的数组/类数组对象封装</h2><p>类数组对象介绍：<a href="https://segmentfault.com/a/1190000000415572" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000415572</a></p>
<p>如果我们使用 ES5/ES6+的数组 API，很容易就能够对数组进行各类的循环操作，但是如果我们要循环一个类数组对象呢？</p>
<p>例如<code>NodeList</code>。直接循环是会报错的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>).map(<span class="function"><span class="params">e</span> =&gt;</span> e) <span class="comment">// Uncaught TypeError: document.querySelectorAll(...).map is not a function</span></span><br></pre></td></tr></table></figure>

<p>当然我们可以用扩展运算符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...document.querySelectorAll(<span class="string">"div"</span>)].map(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br></pre></td></tr></table></figure>

<p>那如果我们不用扩展运算符呢？</p>
<p>那么我们就可以利用<code>call</code>的特性，将<code>NodeList</code>里的元素一个一个的插入到数组中，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listMap = <span class="function"><span class="keyword">function</span>(<span class="params">array, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !fn ? array : <span class="built_in">Array</span>.prototype[type][<span class="string">"call"</span>](array, fn)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>);</span><br><span class="line">listMap(divs, <span class="string">"forEach"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取-dom-元素节点的偏移量"><a href="#获取-dom-元素节点的偏移量" class="headerlink" title="获取 dom 元素节点的偏移量"></a>获取 dom 元素节点的偏移量</h2><p>如果有用过<code>jQuery</code>的童鞋，就一定不会忘记<code>$(&#39;&#39;).offset()</code>这个 api 的强大功能，这个 api 可以轻易获取元素的偏移量，那么如果我们不用<code>jQuery</code>该怎么实现呢？</p>
<p>我们先来看看例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getOffset = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> scrollTop =</span><br><span class="line">        el.getBoundingClientRect().top +</span><br><span class="line">        <span class="built_in">document</span>.body.scrollTop +</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">      <span class="keyword">var</span> scrollLeft =</span><br><span class="line">        el.getBoundingClientRect().left +</span><br><span class="line">        <span class="built_in">document</span>.body.scrollLeft +</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">            top: scrollTop,</span><br><span class="line">            left: scrollLeft</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先来看<code>getBoundingClientRect()</code>这个方法。</p>
<p><code>getBoundingClientRect()</code>方法返回元素的大小及其相对于视口的位置。返回值是一个 <code>DOMRect</code> 对象，是与该元素相关的 CSS 边框集合 。</p>
<p>然后就是<code>document.body.scrollTop</code> 跟 <code>document.documentElement.scrollTop</code>这两个是一个功能，只不过在不同的浏览器下会有一个始终为 0，所以做了以上的兼容性处理。所以当我们做拖拽功能的时候，就可以依赖上以上属性。</p>
<p>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">".moveBox"</span>)</span><br><span class="line">getOffset(el) <span class="comment">// &#123;top: xxx, left: xxx&#125;</span></span><br></pre></td></tr></table></figure>

<p>一个摇杆功能的实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle parent"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle child"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">		<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">140px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">		<span class="attribute">position</span>: relative;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">45px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">45px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> touchObj = &#123;</span><br><span class="line">		$parent: $(<span class="string">'.parent'</span>),</span><br><span class="line">		$target: $(<span class="string">'.child'</span>),</span><br><span class="line">		startX: <span class="number">0</span>,</span><br><span class="line">		startY: <span class="number">0</span>,</span><br><span class="line">		moveX: <span class="number">0</span>,</span><br><span class="line">		moveY: <span class="number">0</span>,</span><br><span class="line">		endX: <span class="number">0</span>,</span><br><span class="line">		endY: <span class="number">0</span>,</span><br><span class="line">		istouchStart: <span class="literal">false</span>,</span><br><span class="line">		boundary(&#123;</span><br><span class="line">				origin,</span><br><span class="line">				radius</span><br><span class="line">		&#125;) &#123;</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						sin,</span><br><span class="line">						cos,</span><br><span class="line">						atan2</span><br><span class="line">				&#125; = <span class="built_in">Math</span></span><br><span class="line">				<span class="keyword">const</span> angle = atan2(origin.y, origin.x)</span><br><span class="line">				<span class="keyword">const</span> limitX = (cos(angle) + <span class="number">1</span>) * radius</span><br><span class="line">				<span class="keyword">const</span> limitY = (sin(angle) + <span class="number">1</span>) * radius</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">						limitX,</span><br><span class="line">						limitY</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		getPos(ev) &#123;</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						changedTouches,</span><br><span class="line">						touches</span><br><span class="line">				&#125; = ev</span><br><span class="line">				<span class="keyword">let</span> posX</span><br><span class="line">				<span class="keyword">let</span> posY</span><br><span class="line">				<span class="keyword">if</span> (ev.type.indexOf(<span class="string">'mouse'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						posX = ev.pageX</span><br><span class="line">						posY = ev.pageY</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">const</span> touchData = touches.length ? touches : changedTouches</span><br><span class="line">						<span class="keyword">const</span> [&#123;</span><br><span class="line">								pageX,</span><br><span class="line">								pageY</span><br><span class="line">						&#125;] = touchData</span><br><span class="line">						posX = pageX</span><br><span class="line">						posY = pageY</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">						x: posX,</span><br><span class="line">						y: posY</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		start(ev) &#123;</span><br><span class="line">				touchObj.$parent = $(<span class="string">'.parent'</span>)</span><br><span class="line">				touchObj.$target = $(<span class="string">'.child'</span>)</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						target</span><br><span class="line">				&#125; = ev</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (touchObj.$target[<span class="number">0</span>] !== target) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">let</span> &#123;</span><br><span class="line">						getPos</span><br><span class="line">				&#125; = touchObj</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						x,</span><br><span class="line">						y</span><br><span class="line">				&#125; = getPos(ev)</span><br><span class="line"></span><br><span class="line">				touchObj.startX = x</span><br><span class="line">				touchObj.startY = y</span><br><span class="line"></span><br><span class="line">				touchObj.istouchStart = <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		move(ev) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!touchObj.istouchStart) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">let</span> &#123;</span><br><span class="line">						$parent,</span><br><span class="line">						$target,</span><br><span class="line">						boundary,</span><br><span class="line">						getPos</span><br><span class="line">				&#125; = touchObj</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						x,</span><br><span class="line">						y</span><br><span class="line">				&#125; = getPos(ev)</span><br><span class="line"></span><br><span class="line">				touchObj.moveX = x</span><br><span class="line">				touchObj.moveY = y</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						top: $parentOffsetTop,</span><br><span class="line">						left: $parentOffsetLeft</span><br><span class="line">				&#125; = $parent.offset()</span><br><span class="line">				<span class="keyword">const</span> $parentWidth = <span class="built_in">parseFloat</span>($parent.css(<span class="string">'width'</span>))</span><br><span class="line">				<span class="keyword">const</span> $parentR = ($parentWidth / <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">const</span> $parentY = ($parentOffsetTop + $parentR)</span><br><span class="line">				<span class="keyword">const</span> $parentX = ($parentOffsetLeft + $parentR)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						top: $targetOffsetTop,</span><br><span class="line">						left: $targetOffsetLeft</span><br><span class="line">				&#125; = $target.offset()</span><br><span class="line">				<span class="keyword">const</span> $targetWidth = <span class="built_in">parseFloat</span>($target.css(<span class="string">'width'</span>))</span><br><span class="line">				<span class="keyword">const</span> $targetR = ($targetWidth / <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">const</span> $targetY = ($targetOffsetTop + $targetR)</span><br><span class="line">				<span class="keyword">const</span> $targetX = ($targetOffsetLeft + $targetR)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> $radius = $parentR - $targetR</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> $SquareR =  $radius ** <span class="number">2</span></span><br><span class="line">				<span class="keyword">const</span> $SquareX = (touchObj.moveX - $parentX) ** <span class="number">2</span></span><br><span class="line">				<span class="keyword">const</span> $SquareY = (touchObj.moveY - $parentY) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> $X = touchObj.moveX - $parentOffsetLeft - $targetR</span><br><span class="line">				<span class="keyword">const</span> $Y = touchObj.moveY - $parentOffsetTop - $targetR</span><br><span class="line"></span><br><span class="line">				<span class="keyword">let</span> $targetLeft = $X</span><br><span class="line">				<span class="keyword">let</span> $targetTop = $Y</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						limitX,</span><br><span class="line">						limitY</span><br><span class="line">				&#125; = boundary(&#123;</span><br><span class="line">						origin: &#123;</span><br><span class="line">								x: $X - $parentR + $targetR,</span><br><span class="line">								y: $Y - $parentR + $targetR</span><br><span class="line">						&#125;,</span><br><span class="line">						radius: $radius</span><br><span class="line">				&#125;)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 圆: 坐标 = (a, b), 半径 = r</span></span><br><span class="line">				<span class="comment">// 点P: 坐标 = (x1, y1)</span></span><br><span class="line">				<span class="comment">// 圆上: (x1 - a) ** 2 + (y - b) ** 2 = r ** 2</span></span><br><span class="line">				<span class="comment">// 圆外: (x1 - a) ** 2 + (y - b) ** 2 &gt; r ** 2</span></span><br><span class="line">				<span class="comment">// 圆内: (x1 - a) ** 2 + (y - b) ** 2 &lt; r ** 2</span></span><br><span class="line">				<span class="keyword">if</span> (($SquareX + $SquareY) &gt; $SquareR) &#123;</span><br><span class="line">						<span class="built_in">console</span>.log(<span class="string">'圆外'</span>)</span><br><span class="line">						$targetLeft = limitX</span><br><span class="line">						$targetTop = limitY</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				$target.css(&#123;</span><br><span class="line">						left: $targetLeft + <span class="string">'px'</span>,</span><br><span class="line">						top: $targetTop + <span class="string">'px'</span></span><br><span class="line">				&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		end(ev) &#123;</span><br><span class="line">				<span class="keyword">let</span> &#123;</span><br><span class="line">						getPos,</span><br><span class="line">						$target</span><br><span class="line">				&#125; = touchObj</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						x,</span><br><span class="line">						y</span><br><span class="line">				&#125; = getPos(ev)</span><br><span class="line"></span><br><span class="line">				touchObj.endX = x</span><br><span class="line">				touchObj.endY = y</span><br><span class="line"></span><br><span class="line">				$target.css(&#123;</span><br><span class="line">						left: <span class="string">'45px'</span>,</span><br><span class="line">						top: <span class="string">'45px'</span></span><br><span class="line">				&#125;)</span><br><span class="line"></span><br><span class="line">				touchObj.istouchStart = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startEvent = <span class="string">'mousedown'</span>, moveEvent = <span class="string">'mousemove'</span>, endEvent = <span class="string">'mouseup'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="string">'ontouchstart'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? (</span><br><span class="line">				startEvent = <span class="string">'touchstart'</span>,</span><br><span class="line">				moveEvent = <span class="string">'touchmove'</span>,</span><br><span class="line">				endEvent = <span class="string">'touchend'</span></span><br><span class="line">		) : <span class="string">''</span></span><br><span class="line">		<span class="built_in">window</span>.addEventListener(startEvent, touchObj.start)</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(moveEvent, touchObj.move)</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(endEvent, touchObj.end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, init)</span><br></pre></td></tr></table></figure>

<h2 id="Fade-特效"><a href="#Fade-特效" class="headerlink" title="Fade 特效"></a>Fade 特效</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fade in</span></span><br><span class="line"><span class="keyword">var</span> fadeIn = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.style.opacity = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">var</span> tick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        el.style.opacity = +el.style.opacity + (<span class="keyword">new</span> <span class="built_in">Date</span>() - last) / <span class="number">400</span></span><br><span class="line">        last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (+el.style.opacity &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            requestAnimationFrame(tick)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tick()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fade out</span></span><br><span class="line"><span class="keyword">var</span> fadeOut = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.style.opacity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">var</span> tick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        el.style.opacity = +el.style.opacity - (<span class="keyword">new</span> <span class="built_in">Date</span>() - last) / <span class="number">400</span></span><br><span class="line">        last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (+el.style.opacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestAnimationFrame(tick)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是淡入淡出效果的具体实现，这里是利用<code>requestAnimationFrame</code>对<code>opacity</code>通过递归的方式进行修改。</p>
<p>其实这里需要提一个概念，就是<strong>时间分片</strong>。</p>
<p>这是一个非常重要的概念，例如 <strong>React</strong> 的 <strong>Fiber</strong> 核心实现就是<strong>时间分片</strong>。它会将一个长任务切分成一个含有若干小任务的任务队列，然后一个接着一个的执行。</p>
<p><code>requestAnimationFrame</code>就是这样一个 API，它可以根据系统来决定回调函数的执行时机，其实也就是在下一次重绘之前更新动画帧，因为有这样的机制，所以能防止丢帧。</p>
<h2 id="利用队列的概念进行数据操作"><a href="#利用队列的概念进行数据操作" class="headerlink" title="利用队列的概念进行数据操作"></a>利用队列的概念进行数据操作</h2><p>队列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为 rear）进行插入操作，在前端（称为 front）进行删除操作。</p>
<p>虽然很多人觉得了解数据结构对前端作用不大，但是如果我们懂一些基础的概念，是否在编码时能够更加扩散我们的思维呢？我们看下面两个例子：</p>
<h3 id="获取节点在该父节点下的坐标"><a href="#获取节点在该父节点下的坐标" class="headerlink" title="获取节点在该父节点下的坐标"></a>获取节点在该父节点下的坐标</h3><p>如果我们要操作原生 DOM，那么是绕不开获取节点在该父节点的下标的这个功能的，那么我们该如何实现呢？</p>
<p>当然就是利用我们的循环啦，对子元素集合进行遍历，直到确定下标为止，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> index = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> ((el = el.previousElementSibling)) &#123;</span><br><span class="line">        i++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空子节点"><a href="#清空子节点" class="headerlink" title="清空子节点"></a>清空子节点</h3><p>如果我们要清空某个 DOM 节点的子节点，我们有以下的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (el.firstChild) &#123;</span><br><span class="line">            el.removeChild(el.firstChild);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面只是提供一个思路，其实el.innerHTML = ‘’会更简洁。</strong></p>
<h2 id="利用-reduce-进行数据优化"><a href="#利用-reduce-进行数据优化" class="headerlink" title="利用 reduce 进行数据优化"></a>利用 reduce 进行数据优化</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>没错，又是一个老生常谈的问题，数组去重，但是我们这次去除的不仅仅是单个的数据，而是拥有某个相同键值的对象集合。例如下面的例子，我们有以下的数据：</p>
<h2 id="牛逼的-reduce"><a href="#牛逼的-reduce" class="headerlink" title="牛逼的 reduce"></a>牛逼的 reduce</h2><h3 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h3><p>首先我们来看看一个老生常谈的问题，我们假设有这样的一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kris"</span>,</span><br><span class="line">            age: <span class="string">"24"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Andy"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kitty"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Andy"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kitty"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Andy"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kitty"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在我们要去重里面<code>name</code>重复的对象，这时候我们可以利用<code>reduce</code>，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onst dataReducer = <span class="function">(<span class="params">prev, cur, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// let obj = &#123;&#125;</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = cur;</span><br><span class="line">    prev[name] = cur;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    <span class="comment">// 这样利用初始时传进的对象来搜集即可，并且 prev 描述为 total 更容易理解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducedData = data.reduce(dataReducer, &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> newData = <span class="built_in">Object</span>.values(reducedData);</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/01/25/JavaScript-中this的指向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/01/25/JavaScript-中this的指向/" class="post-title-link" itemprop="url">JavaScript 中this的指向</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-01-25 11:52:53 / 修改时间：12:57:58" itemprop="dateCreated datePublished" datetime="2020-01-25T11:52:53+08:00">2020-01-25</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-中-this-的指向问题"><a href="#JavaScript-中-this-的指向问题" class="headerlink" title="JavaScript 中 this 的指向问题"></a>JavaScript 中 this 的指向问题</h1><h3 id="场景-1：全局环境下的-this"><a href="#场景-1：全局环境下的-this" class="headerlink" title="场景 1：全局环境下的 this"></a>场景 1：全局环境下的 this</h3><p>这种情况相对简单直接，函数在浏览器全局环境中被简单调用，非严格模式下<code>this</code>指向<code>window</code>; 在<code>use strict</code>指明严格模式的情况下就是<code>undefined</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// window</span></span><br><span class="line">f2() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>对于该问题的变种问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">10</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = foo.fn</span><br><span class="line">fn1() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<p>这里<code>this</code>仍然指向的是<code>window</code>。虽然<code>fn</code>函数在<code>foo</code>对象中作为方法被引用，但是在赋值给<code>fn1</code>之后，<code>fn1</code>的执行仍然是在<code>window</code>的全局环境中。因此输出<code>window</code>和<code>undefined</code>，还是上面这道题目，如果调用改变为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">10</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.fn()</span><br></pre></td></tr></table></figure>

<p>将会输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">bar</span>: <span class="number">10</span>, <span class="attr">fn</span>: ƒ&#125;</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这其实属于第二种情况了，因为这个时候<code>this</code>指向的是最后调用它的对象，在<code>foo.fn()</code>语句中<code>this</code>指向<code>foo</code>对象。请记住：<strong>在执行函数时，如果函数中的this是被上一级的对象所调用，那么this指向的就是上一级的对象；否则指向全局环境。</strong></p>
<h3 id="场景2：上下文对象调用中的-this"><a href="#场景2：上下文对象调用中的-this" class="headerlink" title="场景2：上下文对象调用中的 this"></a>场景2：上下文对象调用中的 this</h3><p>我们直接来看“难”一点的：当存在更复杂的调用关系时，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Lucas'</span>,</span><br><span class="line">    brother: &#123;</span><br><span class="line">        name: <span class="string">'Mike'</span>,</span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.brother.fn())</span><br></pre></td></tr></table></figure>

<p>在这种嵌套的关系中，<code>this</code>指向<strong>最后</strong>调用它的对象，因此输出将会是：<code>Mike</code></p>
<p>下边是更为复杂的嵌套关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    text: <span class="string">'o1'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    text: <span class="string">'o2'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">    text: <span class="string">'o3'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = o1.fn</span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1.fn())</span><br><span class="line"><span class="built_in">console</span>.log(o2.fn())</span><br><span class="line"><span class="built_in">console</span>.log(o3.fn())</span><br></pre></td></tr></table></figure>

<p>答案是：<code>o1</code>、<code>o1</code>、<code>undefined</code></p>
<p>我们来一一分析。</p>
<ul>
<li>第一个 <code>console</code> 最简单，<code>o1</code> 没有问题。难点在第二个和第三个上面，关键还是看调用 <code>this</code> 的那个函数。</li>
<li>第二个 <code>console</code> 的 <code>o2.fn()</code>，最终还是调用 <code>o1.fn()</code>，因此答案仍然是 <code>o1</code>。</li>
<li>最后一个，在进行 <code>var fn = o1.fn</code> 赋值之后，是“裸奔”调用，因此这里的 <code>this</code> 指向 <code>window</code>，答案当然是 <code>undefined</code>。</li>
</ul>
<p>如果是在面试中，我作为面试官，就会追问：如果我们需要让：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(o2.fn())</span><br></pre></td></tr></table></figure>

<p>输出 <code>o2</code>，该怎么做？</p>
<p>一般开发者可能会想到使用<code>bind/call/apply</code>来对<code>this</code>的指向进行干预，这确实是一种思路。但是我接着问，<strong>如果不能使用bind/call/apply，有别的方法吗？</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    text: <span class="string">'o1'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    text: <span class="string">'o2'</span>,</span><br><span class="line">    fn: o1.fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o2.fn())</span><br></pre></td></tr></table></figure>

<p>还是应用那个重要的结论：<code>this</code> 指向<strong>最后</strong>调用它的对象，在 <code>fn</code> 执行时，挂到 <code>o2</code> 对象上即可，我们提前进行了类似赋值的操作。</p>
<h2 id="场景3：bind-call-apply-改变-this-指向"><a href="#场景3：bind-call-apply-改变-this-指向" class="headerlink" title="场景3：bind/call/apply 改变 this 指向"></a>场景3：bind/call/apply 改变 this 指向</h2><p>上文提到 bind/call/apply：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'lucas'</span>,</span><br><span class="line">    logName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">    name: <span class="string">'mike'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.logName.call(bar))</span><br></pre></td></tr></table></figure>

<p>将会输出<code>mike</code>，这不难理解。<strong>但是对 call/apply/bind 的高级考察往往会结合构造函数以及组合式实现继承。实现继承的话题，我们会单独讲到。构造函数的使用案例，我们结合下面的场景进行分析。</strong></p>
<h2 id="场景-4：构造函数和-this"><a href="#场景-4：构造函数和-this" class="headerlink" title="场景 4：构造函数和 this"></a>场景 4：构造函数和 this</h2><p>这方面最直接的例题为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bar = <span class="string">"Lucas"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.bar)</span><br></pre></td></tr></table></figure>

<p>答案将会输出 <code>Lucas</code>。但是这样的场景往往伴随着下一个问题：<code>**new**</code> <strong>操作符调用构造函数，具体做了什么？</strong>以下供参考：</p>
<ul>
<li>创建一个新的对象；</li>
<li>将构造函数的 <code>this</code> 指向这个新对象；</li>
<li>为这个对象添加属性、方法等；</li>
<li>最终返回新对象。</li>
</ul>
<p>以上过程，也可以用代码表述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;</span><br><span class="line">obj.__proto__ = Foo.prototype</span><br><span class="line">Foo.call(obj)</span><br></pre></td></tr></table></figure>

<p>当然，这里对 <code>new</code> 的模拟是一个简单基本版的，更复杂的情况这个问题下我不会赘述。</p>
<p>需要指出的是，如果在构造函数中出现了显式 <code>return</code> 的情况，那么需要注意分为两种场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">"Lucas"</span></span><br><span class="line">    <span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.user)</span><br></pre></td></tr></table></figure>

<p>将会输出 <code>undefined</code>，此时 <code>instance</code> 是返回的空对象 <code>o</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">"Lucas"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.user)</span><br></pre></td></tr></table></figure>

<p>将会输出 <code>Lucas</code>，也就是说此时 <code>instance</code> 是返回的目标对象实例 <code>this</code>。</p>
<p><strong>结论：</strong>如果构造函数中显式返回一个值，且返回的是一个对象，那么 <code>this</code> 就指向这个返回的对象；如果返回的不是一个对象，那么 <code>this</code> 仍然指向实例。</p>
<h2 id="场景-5：箭头函数中的-this-指向"><a href="#场景-5：箭头函数中的-this-指向" class="headerlink" title="场景 5：箭头函数中的 this 指向"></a>场景 5：箭头函数中的 this 指向</h2><p>箭头函数使用<code>this</code>不适用以上标准规则，而是根据外层（函数或者全局）上下文作用域来决定。</p>
<p>来看题目：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;  </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(foo.fn())</span><br></pre></td></tr></table></figure>

<p>这道题中，<code>this</code> 出现在 <code>setTimeout()</code> 中的匿名函数里，因此 <code>this</code> 指向 <code>window</code> 对象。如果需要 <code>this</code> 指向 <code>foo</code> 这个 object 对象，可以巧用箭头函数解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;  </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(foo.fn())</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;fn: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>单纯箭头函数中的 <code>this</code> 非常简单，<strong>但是综合所有情况，结合</strong> <code>**this**</code> <strong>的优先级考察，这时候</strong> <code>**this**</code> <strong>指向并不好确定。请继续阅读。</strong></p>
<h2 id="终极场景-6：this-优先级相关"><a href="#终极场景-6：this-优先级相关" class="headerlink" title="终极场景 6：this 优先级相关"></a>终极场景 6：this 优先级相关</h2><p>我们常常把通过 <code>call</code>、<code>apply</code>、<code>bind</code>、<code>new</code> 对 <code>this</code> 绑定的情况称为显式绑定；根据调用关系确定的 <code>this</code> 指向称为隐式绑定。</p>
<p><strong>那么显式绑定和隐式绑定谁的优先级更高呢？</strong></p>
<p>请看例题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2)</span><br><span class="line">obj2.foo.call(obj1)</span><br></pre></td></tr></table></figure>

<p>输出分别为 2、1，也就是说 <code>call</code>、<code>apply</code> 的显式绑定一般来说优先级比隐式绑定更高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</span><br><span class="line">bar(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)</span><br></pre></td></tr></table></figure>

<p>上述代码通过 <code>bind</code>，将 <code>bar</code> 函数中的 <code>this</code> 绑定为 <code>obj1</code> 对象。执行 <code>bar(2)</code> 后，<code>obj1.a</code> 值为 2。即经过 <code>bar(2)</code> 执行后，<code>obj1</code> 对象为：<code>{a: 2}</code>。</p>
<p>当再使用 <code>bar</code> 作为构造函数时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(baz.a)</span><br></pre></td></tr></table></figure>

<p>将会输出 3。我们看 <code>bar</code> 函数本身是通过 <code>bind</code> 方法构造的函数，其内部已经对将 <code>this</code> 绑定为 <code>obj1</code>，它再作为构造函数，通过 <code>new</code> 调用时，返回的实例已经与 <code>obj1</code> 解绑。 也就是说：</p>
<p><strong>new</strong> <strong>绑定修改了</strong> <strong>bind</strong> <strong>绑定中的</strong> <strong>this，因此</strong> <strong>new</strong> <strong>绑定的优先级比显式</strong> <strong>bind</strong> <strong>绑定更高。</strong></p>
<p>我们再看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))</span><br></pre></td></tr></table></figure>

<p>将会输出 2。由于 <code>foo()</code> 的 <code>this</code> 绑定到 <code>obj1</code>，<code>bar</code>（引用箭头函数）的 <code>this</code> 也会绑定到 <code>obj1</code>，箭头函数的绑定无法被修改。</p>
<p>如果将 <code>foo</code> 完全写成箭头函数的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))</span><br></pre></td></tr></table></figure>

<p>将会输出 <code>123</code>。</p>
<p>这里我再“抖个机灵”，仅仅将上述代码的第一处变量 <code>a</code> 的赋值改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))</span><br></pre></td></tr></table></figure>

<p>答案将会输出为 <code>undefined</code>，原因是因为使用 <code>const</code> 声明的变量不会挂载到 <code>window</code> 全局对象当中。因此 <code>this</code> 指向 <code>window</code> 时，自然也找不到 <code>a</code> 变量了。关于 <code>const</code> 或者 <code>let</code> 等声明变量的方式不再本课的主题当中，我们后续也将专门进行介绍。</p>
<p>在ES5中，全局变量直接挂载到全局对象的属性上，所以能在window上看到var声明的变量<br>在ES6中，全局对象的属性和全局变量脱钩，但是为了保持兼容性，旧的不变，所以var、function声明的全局变量依然可以在window对象上看到，而let、const声明的全局变量在window对象上看不到</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/21/从ES6到ES10的新特性万字大总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/21/从ES6到ES10的新特性万字大总结/" class="post-title-link" itemprop="url">从ES6到ES10的新特性万字大总结</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-21 19:41:40 / 修改时间：21:00:56" itemprop="dateCreated datePublished" datetime="2019-12-21T19:41:40+08:00">2019-12-21</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从ES6到ES10的新特性万字大总结"><a href="#从ES6到ES10的新特性万字大总结" class="headerlink" title="从ES6到ES10的新特性万字大总结"></a>从ES6到ES10的新特性万字大总结</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）在标准ECMA-262中定义的脚本语言规范。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p>至发稿日为止有九个ECMA-262版本发表。其历史版本如下：</p>
<ol>
<li>1997年6月：第一版</li>
<li>1998年6月：修改格式，使其与ISO/IEC16262国际标准一样</li>
<li>1999年12月：强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变</li>
<li>2009年12月：添加严格模式(<code>&quot;use strict&quot;</code>)。修改了前面版本模糊不清的概念。增加了getters，setters，JSON以及在对象属性上更完整的反射。</li>
<li>2011年6月：ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。</li>
<li>2015年6月：ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。</li>
<li>2016年6月：ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性。</li>
<li>2017年6月：ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性。</li>
<li>2018年6月：ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。</li>
<li>2019年6月：ECMAScript 2019 （ES2019），第 10 版。</li>
</ol>
<h3 id="发展标准"><a href="#发展标准" class="headerlink" title="发展标准"></a>发展标准</h3><p>TC39（Technical Committee 39）是一个推动JavaScript发展的委员会，它的成语来自各个主流浏览器的代表成语。会议实行多数决，每一项决策只有大部分人同意且没有强烈反对才能去实现。</p>
<p>TC39成员制定着ECMAScript的未来。</p>
<p>每一项新特性最终要进入到ECMAScript规范里，需要经历5个阶段，这5个阶段如下：</p>
<ul>
<li><p><strong>Stage 0</strong>: Strawperson</p>
<p>只要是TC39成员或者贡献者，都可以提交想法</p>
</li>
<li><p><strong>Stage 1</strong>: Proposal</p>
<p>这个阶段确定一个正式的提案</p>
</li>
<li><p><strong>Stage 2</strong>: draft</p>
<p>规范的第一个版本，进入此阶段的提案大概率会成为标准</p>
</li>
<li><p><strong>Stage 3</strong>: Candidate</p>
<p>进一步完善提案细则</p>
</li>
<li><p><strong>Stage 4</strong>: Finished</p>
<p>表示已准备好将其添加到正式的ECMAScript标准中</p>
</li>
</ul>
<p><strong>由于ES6以前的属性诞生年底久远，我们使用也比较普遍，遂不进行说明，ES6之后的语言风格跟ES5以前的差异比较大，所以单独拎出来做个记录。</strong></p>
<h2 id="ES6-ES2015"><a href="#ES6-ES2015" class="headerlink" title="ES6(ES2015)"></a>ES6(ES2015)</h2><blockquote>
<p>ES6是一次重大的革新，比起过去的版本，改动比较大，本文仅对常用的API以及语法糖进行讲解。</p>
</blockquote>
<h3 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h3><p>在ES6以前，<code>JS</code>只有<code>var</code>一种声明方式，但是在ES6之后，就多了<code>let</code>跟<code>const</code>这两种方式。用<code>var</code>定义的变量没有块级作用域的概念，而<code>let</code>跟<code>const</code>则会有，因为这三个关键字创建是不一样的。</p>
<p>区别如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// 10</span></span><br><span class="line">b <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line">c <span class="comment">// c is not defined</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">40</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">50</span></span><br><span class="line">d = <span class="number">60</span></span><br><span class="line">d <span class="comment">// 60</span></span><br><span class="line">e = <span class="number">70</span> <span class="comment">// VM231:1 Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>var</th>
<th>let</th>
<th>const</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>变量提升</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>全局变量</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>重复声明</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>重新赋值</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>暂时死区</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>块作用域</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>只声明不初始化</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><p>在ES6之前，如果我们要生成一个实例对象，传统的方法就是写一个构造函数，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.information = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在ES6之后，我们只需要写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    information() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数（Arrow-function）"><a href="#箭头函数（Arrow-function）" class="headerlink" title="箭头函数（Arrow function）"></a>箭头函数（Arrow function）</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或 <code>new.target</code>。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p>
<p>在ES6以前，我们写函数一般是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> newList = list.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是在ES6里，我们可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> newList = list.map(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br></pre></td></tr></table></figure>

<h3 id="函数参数默认值（Function-parameter-defaults）"><a href="#函数参数默认值（Function-parameter-defaults）" class="headerlink" title="函数参数默认值（Function parameter defaults）"></a>函数参数默认值（Function parameter defaults）</h3><p>在ES6之前，如果我们写函数需要定义初始值的时候，需要这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">config</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = data || <span class="string">'data is empty'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来也没有问题，但是如果参数的布尔值为<strong>falsy</strong>时就会出问题，例如我们这样调用config：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config(<span class="number">0</span>)</span><br><span class="line">config(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>那么结果就永远是后面的值</p>
<p>如果我们用函数参数默认值就没有这个问题，写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="function">(<span class="params">data = <span class="string">'data is empty'</span></span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（Template-string）"><a href="#模板字符串（Template-string）" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h3><p>在ES6之前，如果我们要拼接字符串，则需要像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'kris'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br></pre></td></tr></table></figure>

<p>但是在ES6之后，我们只需要写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'kris'</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, I am <span class="subst">$&#123;age&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<h3 id="解构赋值（Destructuring-assignment）"><a href="#解构赋值（Destructuring-assignment）" class="headerlink" title="解构赋值（Destructuring assignment）"></a>解构赋值（Destructuring assignment）</h3><p>我们通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>
<p>比如我们需要交换两个变量的值，在ES6之前我们可能需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure>

<p>但是在ES6里，我们有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>

<h3 id="模块化（Module）"><a href="#模块化（Module）" class="headerlink" title="模块化（Module）"></a>模块化（Module）</h3><p>在ES6之前，JS并没有模块化的概念，有的也只是社区定制的类似CommonJS和AMD之类的规则。例如基于CommonJS的NodeJS：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是 <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<p>在ES6之后我们则可以写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    area</span><br><span class="line">&#125; = <span class="string">'./circle.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是: <span class="subst">$&#123;area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<h3 id="扩展操作符（Spread-operator）"><a href="#扩展操作符（Spread-operator）" class="headerlink" title="扩展操作符（Spread operator）"></a>扩展操作符（Spread operator）</h3><p>扩展操作符可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p>
<p>比如在ES5的时候，我们要对一个数组的元素进行相加，在不使用<code>reduce</code>或者<code>reduceRight</code>的场合，我们需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> total = sum.apply(<span class="literal">null</span>, list)</span><br></pre></td></tr></table></figure>

<p>但是如果我们使用扩展操作符，只需要如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z</span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> total = sum(...list)</span><br></pre></td></tr></table></figure>

<p>非常的简单，但是要注意的是扩展操作符只能用于可迭代对象</p>
<p>如果是下面的情况，是会报错的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> array = [...obj] <span class="comment">// TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<h3 id="对象属性简写（Object-attribute-shorthand）"><a href="#对象属性简写（Object-attribute-shorthand）" class="headerlink" title="对象属性简写（Object attribute shorthand）"></a>对象属性简写（Object attribute shorthand）</h3><p>在ES6之前，如果我们要将某个变量赋值为同样名称的对象元素，则需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="string">'Miaow'</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="string">'Woof'</span></span><br><span class="line"><span class="keyword">var</span> bird = <span class="string">'Peet peet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someObject = &#123;</span><br><span class="line">  cat: cat,</span><br><span class="line">  dog: dog,</span><br><span class="line">  bird: bird</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在ES6里我们就方便很多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'Miaow'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'Woof'</span></span><br><span class="line"><span class="keyword">let</span> bird = <span class="string">'Peet peet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someObject = &#123;</span><br><span class="line">  cat,</span><br><span class="line">  dog,</span><br><span class="line">  bird</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someObject)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  cat: "Miaow",</span></span><br><span class="line"><span class="comment">//  dog: "Woof",</span></span><br><span class="line"><span class="comment">//  bird: "Peet peet"</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 是ES6提供的一种异步解决方案，比回调函数更加清晰明了。</p>
<p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p>
<ol>
<li>等待中（pending）</li>
<li>完成了 （resolved）</li>
<li>拒绝了（rejected）</li>
</ol>
<p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="comment">// 无效</span></span><br><span class="line">  reject(<span class="string">'reject'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finifsh'</span>)</span><br><span class="line"><span class="comment">// new Promise -&gt; finifsh</span></span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code>，并且是一个全新的 <code>Promise</code>，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code>，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>当然了，<code>Promise</code> 也很好地解决了回调地狱的问题，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以改写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url1)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url2)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>

<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p><code>for...of</code>语句在可迭代对象（包括 <code>Array，Map，Set，String，TypedArray，arguments</code> 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> array1) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "c"</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p><strong>symbol</strong> 是一种基本数据类型，<code>Symbol()</code>函数会返回<strong>symbol</strong>类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”<code>new Symbol()</code>“。</p>
<p>每个从<code>Symbol()</code>返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> symbol2 = <span class="built_in">Symbol</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> symbol3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol1); <span class="comment">// "symbol"</span></span><br><span class="line"><span class="built_in">console</span>.log(symbol3.toString()); <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器（Iterator）-生成器（Generator）"><a href="#迭代器（Iterator）-生成器（Generator）" class="headerlink" title="迭代器（Iterator）/ 生成器（Generator）"></a>迭代器（Iterator）/ 生成器（Generator）</h3><p>迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。</p>
<p>一旦创建，迭代器对象可以通过重复调用next()显式地迭代，从而获取该对象每一级的值，直到迭代完，返回<code>{ value: undefined, done: true }</code></p>
<p>虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 生成器函数使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener"><code>function*</code></a>语法编写。 最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。 通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。</p>
<p>可以根据需要多次调用该函数，并且每次都返回一个新的Generator，但每个Generator只能迭代一次。</p>
<p>所以我们可以有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeRangeIterator</span>(<span class="params">start = <span class="number">0</span>, end = Infinity, step = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i += step) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = makeRangeIterator(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">a.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 7, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 9, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-WeakSet"><a href="#Set-WeakSet" class="headerlink" title="Set/WeakSet"></a>Set/WeakSet</h3><p><code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>所以我们可以通过<code>Set</code>实现数组去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(numbers)]) </span><br><span class="line"><span class="comment">// [2, 3, 4, 5, 6, 7, 32]</span></span><br></pre></td></tr></table></figure>

<p><code>WeakSet</code> 结构与 <code>Set</code> 类似，但区别有以下两点：</p>
<ul>
<li><code>WeakSet</code> 对象中只能存放对象引用, 不能存放值, 而 <code>Set</code> 对象都可以。</li>
<li><code>WeakSet</code> 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code>WeakSet</code> 对象是无法被枚举的, 没有办法拿到它包含的所有元素。</li>
</ul>
<p>所以代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">ws.has(foo)    <span class="comment">// false, 对象 foo 并没有被添加进 ws 中 </span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>) <span class="comment">// 从集合中删除 window 对象</span></span><br><span class="line">ws.has(<span class="built_in">window</span>)    <span class="comment">// false, window 对象已经被删除了</span></span><br><span class="line"></span><br><span class="line">ws.clear() <span class="comment">// 清空整个 WeakSet 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-WeakMap"><a href="#Map-WeakMap" class="headerlink" title="Map/WeakMap"></a>Map/WeakMap</h3><p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>例子如下，我们甚至可以使用<code>NaN</code>来作为键值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">"not a number"</span>);</span><br><span class="line"></span><br><span class="line">myMap.get(<span class="literal">NaN</span>); <span class="comment">// "not a number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherNaN = <span class="built_in">Number</span>(<span class="string">"foo"</span>);</span><br><span class="line">myMap.get(otherNaN); <span class="comment">// "not a number"</span></span><br></pre></td></tr></table></figure>

<p><code>WeakMap</code> 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<p>跟<code>Map</code>的区别与<code>Set</code>跟<code>WeakSet</code>的区别相似，具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;,</span><br><span class="line">    o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    o3 = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">wm1.set(o1, <span class="number">37</span>);</span><br><span class="line">wm1.set(o2, <span class="string">"azerty"</span>);</span><br><span class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象</span></span><br><span class="line">wm2.set(o3, <span class="literal">undefined</span>);</span><br><span class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class="line">wm1.get(o2); <span class="comment">// "azerty"</span></span><br><span class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></span><br><span class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></span><br><span class="line"></span><br><span class="line">wm1.has(o2); <span class="comment">// true</span></span><br><span class="line">wm2.has(o2); <span class="comment">// false</span></span><br><span class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></span><br><span class="line"></span><br><span class="line">wm3.set(o1, <span class="number">37</span>);</span><br><span class="line">wm3.get(o1); <span class="comment">// 37</span></span><br><span class="line">wm3.clear();</span><br><span class="line">wm3.get(o1); <span class="comment">// undefined,wm3已被清空</span></span><br><span class="line">wm1.has(o1);   <span class="comment">// true</span></span><br><span class="line">wm1.delete(o1);</span><br><span class="line">wm1.has(o1);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy/Reflect"></a>Proxy/Reflect</h3><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p>
<p><code>Reflect</code> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 <code>Proxy</code> 的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p>
<p><code>Proxy</code>跟<code>Reflect</code>是非常完美的配合，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observe = <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">            <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">                  callback(key, value);</span><br><span class="line">                  target[key] = value;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy)</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FooBar = &#123; <span class="attr">open</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> FooBarObserver = observe(FooBar, (property, value) =&gt; &#123;</span><br><span class="line">  property === <span class="string">'open'</span> &amp;&amp; value </span><br><span class="line">          ? <span class="built_in">console</span>.log(<span class="string">'FooBar is open!!!'</span>) </span><br><span class="line">          : <span class="built_in">console</span>.log(<span class="string">'keep waiting'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(FooBarObserver.open) <span class="comment">// false</span></span><br><span class="line">FooBarObserver.open = <span class="literal">true</span> <span class="comment">// FooBar is open!!!</span></span><br></pre></td></tr></table></figure>

<p>当然也不是什么都可以被代理的，如果对象带有<code>configurable: false</code> 跟<code>writable: false</code> 属性，则代理失效。</p>
<h3 id="Regex对象的扩展"><a href="#Regex对象的扩展" class="headerlink" title="Regex对象的扩展"></a>Regex对象的扩展</h3><h4 id="正则新增符号"><a href="#正则新增符号" class="headerlink" title="正则新增符号"></a>正则新增符号</h4><ul>
<li><code>i</code> 修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 修饰符</span></span><br><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>y</code>修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y修饰符</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>String.prototype.flags</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看RegExp构造函数的修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>)</span><br><span class="line">regex.flags <span class="comment">// 'i'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>unicode模式</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span></span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>u转义</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u转义</span></span><br><span class="line">/\,/ <span class="comment">// /\,/</span></span><br><span class="line">/\,/u <span class="comment">// 报错 没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串方法的实现改为调用RegExp方法"><a href="#字符串方法的实现改为调用RegExp方法" class="headerlink" title="字符串方法的实现改为调用RegExp方法"></a>字符串方法的实现改为调用<code>RegExp</code>方法</h4><ul>
<li>String.prototype.match<code>调用</code>RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace<code>调用</code>RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search<code>调用</code>RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split<code>调用</code>RegExp.prototype[Symbol.split]</li>
</ul>
<h4 id="正则新增属性"><a href="#正则新增属性" class="headerlink" title="正则新增属性"></a>正则新增属性</h4><ul>
<li><code>RegExp.prototype.sticky</code> 表示是否有<code>y</code>修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hello\d/y.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>RegExp.prototype.flags</code>获取修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc/ig.flags <span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>

<h3 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h3><ul>
<li><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><code>八进制表示法</code> : <code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><code>Number.EPSILON</code> : 数值最小精度</li>
<li><code>Number.MIN_SAFE_INTEGER</code> : 最小安全数值(<code>-2^53</code>)</li>
<li><code>Number.MAX_SAFE_INTEGER</code> : 最大安全数值(<code>2^53</code>)</li>
<li><code>Number.parseInt()</code> : 返回转换值的整数部分</li>
<li><code>Number.parseFloat()</code> : 返回转换值的浮点数部分</li>
<li><code>Number.isFinite()</code> : 是否为有限数值</li>
<li><code>Number.isNaN()</code> : 是否为NaN</li>
<li><code>Number.isInteger()</code> : 是否为整数</li>
<li><code>Number.isSafeInteger()</code> : 是否在数值安全范围内</li>
<li><code>Math.trunc()</code> : 返回数值整数部分</li>
<li><code>Math.sign()</code> : 返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li>
<li><code>Math.cbrt()</code> : 返回数值立方根</li>
<li><code>Math.clz32()</code> : 返回数值的32位无符号整数形式</li>
<li><code>Math.imul()</code> : 返回两个数值相乘</li>
<li><code>Math.fround()</code> : 返回数值的32位单精度浮点数形式</li>
<li><code>Math.hypot()</code> : 返回所有数值平方和的平方根</li>
<li><code>Math.expm1()</code> : 返回<code>e^n - 1</code></li>
<li><code>Math.log1p()</code> : 返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><code>Math.log10()</code> : 返回以10为底的n的对数</li>
<li><code>Math.log2()</code> : 返回以2为底的n的对数</li>
<li><code>Math.sinh()</code> : 返回n的双曲正弦</li>
<li><code>Math.cosh()</code> : 返回n的双曲余弦</li>
<li><code>Math.tanh()</code> : 返回n的双曲正切</li>
<li><code>Math.asinh()</code> : 返回n的反双曲正弦</li>
<li><code>Math.acosh()</code> : 返回n的反双曲余弦</li>
<li><code>Math.atanh()</code> : 返回n的反双曲正切</li>
</ul>
<h3 id="Array对象的扩展"><a href="#Array对象的扩展" class="headerlink" title="Array对象的扩展"></a>Array对象的扩展</h3><ul>
<li><code>Array.prototype.from</code>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">'foo'</span>)) <span class="comment">// ["f", "o", "o"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x)) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.of()</code>：转换一组值为真正数组，返回新数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>)       <span class="comment">// [7] </span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>)          <span class="comment">// [empty, empty, empty, empty, empty, empty]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.copyWithin()</code>：把指定位置的成员复制到其他位置，返回原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// ["d", "b", "c", "d", "e"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">1</span>, <span class="number">3</span>)) <span class="comment">// ["d", "d", "e", "d", "e"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.find()</code>：返回第一个符合条件的成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.findIndex()</code>：返回第一个符合条件的成员索引值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isLargeNumber = <span class="function">(<span class="params">element</span>) =&gt;</span> element &gt; <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.findIndex(isLargeNumber)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.fill()</code>：根据指定值填充整个数组，返回原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>)) <span class="comment">// [1, 2, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">5</span>, <span class="number">1</span>)) <span class="comment">// [1, 5, 5, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">6</span>)) <span class="comment">// [6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.keys()</code>：返回以索引值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.values()</code>：返回以属性值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.values()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.entries()</code>：返回以索引值和属性值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.entries()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [1, "b"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>数组空位</code>：ES6明确将数组空位转为<code>undefined</code>或者<code>empty</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>]) <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]] <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">//  [empty × 3]</span></span><br><span class="line">[,<span class="string">'a'</span>] <span class="comment">// [empty, "a"]</span></span><br></pre></td></tr></table></figure>

<h2 id="ES7-ES2016"><a href="#ES7-ES2016" class="headerlink" title="ES7(ES2016)"></a>ES7(ES2016)</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h3><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array1.includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pets = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'cat'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'at'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符**"></a>幂运算符**</h3><p>幂运算符**，具有与Math.pow()一样的功能，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>) <span class="comment">// 1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)) <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（Template-string）-1"><a href="#模板字符串（Template-string）-1" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h3><p>自ES7起，带标签的模版字面量遵守以下转义序列的规则：</p>
<ul>
<li>Unicode字符以”\u”开头，例如<code>\u00A9</code></li>
<li>Unicode码位用”\u{}”表示，例如<code>\u{2F804}</code></li>
<li>十六进制以”\x”开头，例如<code>\xA9</code></li>
<li>八进制以””和数字开头，例如<code>\251</code></li>
</ul>
<p>这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">latex<span class="string">`\unicode`</span></span><br><span class="line"><span class="comment">// 在较老的ECMAScript版本中报错（ES2016及更早）</span></span><br><span class="line"><span class="comment">// SyntaxError: malformed Unicode character escape sequence</span></span><br></pre></td></tr></table></figure>

<h2 id="ES8-ES2017"><a href="#ES8-ES2017" class="headerlink" title="ES8(ES2017)"></a>ES8(ES2017)</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>虽然<code>Promise</code>可以解决回调地狱的问题，但是链式调用太多，则会变成另一种形式的回调地狱 —— 面条地狱，所以在ES8里则出现了<code>Promise</code>的语法糖<code>async/await</code>，专门解决这个问题。</p>
<p>我们先看一下下面的<code>Promise</code>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">    .then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob)</span><br><span class="line">          <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">          image.src = objectURL</span><br><span class="line">          <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'There has been a problem with your fetch operation: '</span> + e.message)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>然后再看看<code>async/await</code>版的，这样看起来是不是更清晰了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">      <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob)</span><br><span class="line">      <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      image.src = objectURL</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br></pre></td></tr></table></figure>

<p>当然，如果你喜欢，你甚至可以两者混用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> response.blob()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> objectURL = URL.createObjectURL(blob)</span><br><span class="line">      <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      image.src = objectURL</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">      a: <span class="string">'somestring'</span>,</span><br><span class="line">      b: <span class="number">42</span>,</span><br><span class="line">      c: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(object1)) <span class="comment">// ["somestring", 42, false]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">      a: <span class="string">'somestring'</span>,</span><br><span class="line">      b: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "a: somestring"</span></span><br><span class="line"><span class="comment">// "b: 42"</span></span><br></pre></td></tr></table></figure>

<h3 id="padStart"><a href="#padStart" class="headerlink" title="padStart()"></a>padStart()</h3><p><code>padStart()</code> 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'5'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.padStart(<span class="number">2</span>, <span class="string">'0'</span>)) <span class="comment">// "05"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullNumber = <span class="string">'2034399002125581'</span></span><br><span class="line"><span class="keyword">const</span> last4Digits = fullNumber.slice(<span class="number">-4</span>)</span><br><span class="line"><span class="keyword">const</span> maskedNumber = last4Digits.padStart(fullNumber.length, <span class="string">'*'</span>) </span><br><span class="line"><span class="built_in">console</span>.log(maskedNumber) <span class="comment">// "************5581"</span></span><br></pre></td></tr></table></figure>

<h3 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h3><p><code>padEnd()</code> 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'Breaded Mushrooms'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.padEnd(<span class="number">25</span>, <span class="string">'.'</span>)) <span class="comment">// "Breaded Mushrooms........"</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'200'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.padEnd(<span class="number">5</span>)) <span class="comment">// "200  "</span></span><br></pre></td></tr></table></figure>

<p>###函数参数结尾逗号（Function parameter lists and calls trailing commas）</p>
<p>在ES5里就添加了对象的尾逗号，不过并不支持函数参数，但是在ES8之后，便开始支持这一特性，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p,</span>) </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">(p) =&gt; &#123;&#125;</span><br><span class="line">(p,) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">f(p)</span><br><span class="line">f(p,)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>,)</span><br></pre></td></tr></table></figure>

<p>但是以下的方式是不合法的：</p>
<p>仅仅包含逗号的函数参数定义或者函数调用会抛出 SyntaxError。 而且，当使用剩余参数的时候，并不支持尾后逗号，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">,</span>) </span>&#123;&#125; <span class="comment">// SyntaxError: missing formal parameter</span></span><br><span class="line">(,) =&gt; &#123;&#125;       <span class="comment">// SyntaxError: expected expression, got ','</span></span><br><span class="line">f(,)             <span class="comment">// SyntaxError: expected expression, got ','</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...p,</span>) </span>&#123;&#125; <span class="comment">// SyntaxError: parameter after rest parameter</span></span><br><span class="line">(...p,) =&gt; &#123;&#125;        <span class="comment">// SyntaxError: expected closing parenthesis, got ','</span></span><br></pre></td></tr></table></figure>

<p>在解构里也可以使用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有尾后逗号的数组解构</span></span><br><span class="line">[a, b,] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有尾后逗号的对象解构</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  p: <span class="number">42</span>, </span><br><span class="line">  q: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;p, q,&#125; = o</span><br></pre></td></tr></table></figure>

<p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...b,] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// SyntaxError: rest element may not have a trailing comma</span></span><br></pre></td></tr></table></figure>

<h3 id="ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）"><a href="#ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）" class="headerlink" title="ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）"></a>ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sab = <span class="keyword">new</span> SharedArrayBuffer(<span class="number">1024</span>) <span class="comment">// 必须实例化</span></span><br><span class="line">worker.postMessage(sab)</span><br></pre></td></tr></table></figure>

<h3 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a>Atomics对象</h3><p><strong>Atomics对象</strong>  提供了一组静态方法用来对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener"><code>SharedArrayBuffer</code></a> 对象进行原子操作。</p>
<p>方法如下：</p>
<ul>
<li><strong>Atomics.add()</strong> ：将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</li>
<li><strong>Atomics.and()</strong>：将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</li>
<li><strong>Atomics.compareExchange()</strong>：如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</li>
<li><strong>Atomics.exchange()</strong>：将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</li>
<li><strong>Atomics.load()</strong>：返回数组中指定元素的值。</li>
<li><strong>Atomics.or()</strong>：将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</li>
<li><strong>Atomics.store()</strong>：将数组中指定的元素设置为给定的值，并返回该值。</li>
<li><strong>Atomics.sub()</strong>：将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</li>
<li><strong>Atomics.xor()</strong>：将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</li>
<li><strong>Atomics.wait()</strong>：检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</li>
<li><strong>Atomics.wake()</strong>：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</li>
<li><strong>Atomics.isLockFree(size)</strong>：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</li>
</ul>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  property1: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptors1 = <span class="built_in">Object</span>.getOwnPropertyDescriptors(object1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors1.property1.writable) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors1.property1.value) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝一个对象</span></span><br><span class="line"><span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj), </span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">superclass.prototype = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">subclass.prototype = <span class="built_in">Object</span>.create(superclass.prototype, <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h2 id="ES9-ES2018"><a href="#ES9-ES2018" class="headerlink" title="ES9(ES2018)"></a>ES9(ES2018)</h2><h3 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h3><p><code>for await...of</code> 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 <code>String</code>，<code>Array</code>，<code>Array-like</code> 对象（比如<code>arguments</code> 或者<code>NodeList</code>)，<code>TypedArray</code>，<code>Map</code>， <code>Set</code>和自定义的异步或者同步可迭代对象。其会调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p>配合迭代异步生成器，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> i++</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="keyword">await</span> (num <span class="keyword">of</span> asyncGenerator()) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(num)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（Template-string）-2"><a href="#模板字符串（Template-string）-2" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h3><p>ES9开始，模板字符串允许嵌套支持常见转义序列，移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。</p>
<p>不过，非法转义序列在”cooked”当中仍然会体现出来。它们将以<code>undefined</code>元素的形式存在于”cooked”之中，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="string">"cooked"</span>: str[<span class="number">0</span>], <span class="string">"raw"</span>: str.raw[<span class="number">0</span>] &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">latex<span class="string">`\unicode`</span> <span class="comment">// &#123; cooked: undefined, raw: "\\unicode" &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式反向-lookbehind-断言"><a href="#正则表达式反向-lookbehind-断言" class="headerlink" title="正则表达式反向(lookbehind)断言"></a>正则表达式反向(lookbehind)断言</h3><p>首先我们得先知道什么是<strong>断言(Assertion)</strong>。</p>
<p><strong>断言(Assertion)</strong>是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符，所以断言也被称为“非消耗性匹配”或“非获取匹配”。</p>
<p>正则表达式的断言一共有 4 种形式：</p>
<ul>
<li><code>(?=pattern)</code> 零宽正向肯定断言(zero-width positive lookahead assertion)</li>
<li><code>(?!pattern)</code> 零宽正向否定断言(zero-width negative lookahead assertion)</li>
<li><code>(?&lt;=pattern)</code> 零宽反向肯定断言(zero-width positive lookbehind assertion)</li>
<li><code>(?&lt;!pattern)</code> 零宽反向否定断言(zero-width negative lookbehind assertion)</li>
</ul>
<p>在ES9之前，JavaScript 正则表达式，只支持正向断言。正向断言的意思是：当前位置后面的字符串应该满足断言，但是并不捕获。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'fishHeadfishTail'</span>.match(<span class="regexp">/fish(?=Head)/g</span>) <span class="comment">// ["fish"]</span></span><br></pre></td></tr></table></figure>

<p>反向断言和正向断言的行为一样，只是方向相反。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc123'</span>.match(<span class="regexp">/(?&lt;=(\d+)(\d+))$/</span>) <span class="comment">//  ["", "1", "23", index: 6, input: "abc123", groups: undefined]</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>正则表达式中的Unicode转义符允许根据Unicode字符属性匹配Unicode字符。 它允许区分字符类型，例如大写和小写字母，数学符号和标点符号。</p>
<p>部分例子代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>具体的属性列表可查看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noopener">developer.mozilla.org/en-US/docs/…</a></p>
<h3 id="正则表达式-s-dotAll-模式"><a href="#正则表达式-s-dotAll-模式" class="headerlink" title="正则表达式 s/dotAll 模式"></a>正则表达式 s/dotAll 模式</h3><p>在以往的版本里，JS的正则的<code>.</code>只能匹配emoji跟行终结符以外的所有文本，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/./</span>;</span><br><span class="line"></span><br><span class="line">regex.test(<span class="string">'\n'</span>);       <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\r'</span>);       <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;2028&#125;'</span>); <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;2029&#125;'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">regex.test(<span class="string">'\v'</span>);       <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'\f'</span>);       <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;0085&#125;'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>);     <span class="comment">// false</span></span><br><span class="line">/foo[^]bar/.test(<span class="string">'foo\nbar'</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>);     <span class="comment">// false</span></span><br><span class="line">/foo[\s]bar/.test(<span class="string">'foo\nbar'</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是在ES9之后，JS正则增加了一个新的标志 <code>s</code> 用来表示 dotAll，这可以匹配任意字符。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;  <span class="comment">//  等价于 const re = new RegExp('foo.bar', 's');</span></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>);    <span class="comment">// true</span></span><br><span class="line">re.dotAll;      <span class="comment">// true</span></span><br><span class="line">re.flags;       <span class="comment">// "s"</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><p>在以往的版本里，JS的正则分组是无法命名的，所以容易混淆。例如下面获取年月日的例子，很容易让人搞不清哪个是月份，哪个是年份:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matched = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>.exec(<span class="string">'2019-01-01'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">0</span>]);    <span class="comment">// 2019-01-01</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">1</span>]);    <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">2</span>]);    <span class="comment">// 01</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">3</span>]);    <span class="comment">// 01</span></span><br></pre></td></tr></table></figure>

<p>ES9引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对象扩展操作符"><a href="#对象扩展操作符" class="headerlink" title="对象扩展操作符"></a>对象扩展操作符</h3><p>ES6中添加了数组的扩展操作符，让我们在操作数组时更加简便，美中不足的是并不支持对象扩展操作符，但是在ES9开始，这一功能也得到了支持，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面便是一个简便的浅拷贝。这里有一点小提示，就是<code>Object.assign()</code> 函数会触发 <code>setters</code>，而展开语法则不会。所以不能替换也不能模拟<code>Object.assign()</code> 。</p>
<p>如果存在相同的属性名，只有最后一个会生效。</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code>方法会返回一个<code>Promise</code>，当promise的状态变更，不管是变成<code>rejected</code>或者<code>fulfilled</code>，最终都会执行<code>finally()</code>的回调。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      &#125;)</span><br><span class="line">      .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ES10-ES2019"><a href="#ES10-ES2019" class="headerlink" title="ES10(ES2019)"></a>ES10(ES2019)</h2><h3 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat() / flatMap()"></a>Array.prototype.flat() / flatMap()</h3><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p><code>flatMap()</code>与 <code>map()</code> 方法和深度为1的 <code>flat()</code> 几乎相同.，不过它会首先使用映射函数映射每个元素，然后将结果压缩成一个新数组，这样效率会更高。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度为1</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]) <span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>可以代替<code>reduce()</code> 与 <code>concat()</code>，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>]) <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc.concat([x, x * <span class="number">2</span>]), []) <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>

<p>但这是非常低效的，在每次迭代中，它创建一个必须被垃圾收集的新临时数组，并且它将元素从当前的累加器数组复制到一个新的数组中，而不是将新的元素添加到现有的数组中。</p>
<h3 id="String-prototype-trimStart-trimLeft-trimEnd-trimRight"><a href="#String-prototype-trimStart-trimLeft-trimEnd-trimRight" class="headerlink" title="String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()"></a>String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()</h3><p>在ES5中，我们可以通过<code>trim()</code>来去掉字符首尾的空格，但是却无法只去掉单边的，但是在ES10之后，我们可以实现这个功能。</p>
<p>如果我们要去掉开头的空格，可以使用<code>trimStart()</code>或者它的别名<code>trimLeft()</code>，</p>
<p>同样的，如果我们要去掉结尾的空格，我们可以使用<code>trimEnd()</code>或者它的别名<code>trimRight()</code>。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Str = <span class="string">'   Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str) <span class="comment">// '   Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimStart()) <span class="comment">// 'Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimLeft()) <span class="comment">// 'Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimEnd()) <span class="comment">// '   Hello world!'</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimRight()) <span class="comment">// '   Hello world!'</span></span><br></pre></td></tr></table></figure>

<p>不过这里有一点要注意的是，<code>trimStart()</code>跟<code>trimEnd()</code>才是标准方法，<code>trimLeft()</code>跟<code>trimRight()</code>只是别名。</p>
<p>在某些引擎里（例如Chrome），有以下的等式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trimLeft.name === <span class="string">"trimStart"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.trimRight.name === <span class="string">"trimEnd"</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code> 方法把键值对列表转换为一个对象，它是<code>Object.entries()</code>的反函数。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// Object &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p><code>description</code> 是一个只读属性，它会返回<code>Symbol</code>对象的可选描述的字符串。与 <code>Symbol.prototype.toString()</code> 不同的是它不会包含<code>Symbol()</code>的字符串。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'desc'</span>).toString();   <span class="comment">// "Symbol(desc)"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'desc'</span>).description;  <span class="comment">// "desc"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">''</span>).description;      <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">Symbol</span>().description;        <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名 symbols</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator.toString();  <span class="comment">// "Symbol(Symbol.iterator)"</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator.description; <span class="comment">// "Symbol.iterator"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局 symbols</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>).toString();  <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>).description; <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'test1test2'</span></span><br><span class="line"></span><br><span class="line">str.match(regexp) <span class="comment">// ['test1', 'test2']</span></span><br><span class="line">str.matchAll(regexp) <span class="comment">// RegExpStringIterator &#123;&#125;</span></span><br><span class="line">[...str.matchAll(regexp)] <span class="comment">// [['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4], ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4]]</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-prototype-toString-返回注释与空格"><a href="#Function-prototype-toString-返回注释与空格" class="headerlink" title="Function.prototype.toString() 返回注释与空格"></a>Function.prototype.toString() 返回注释与空格</h3><p>在以往的版本中，<code>Function.prototype.toString()</code>得到的字符串是去掉空白符号的，但是从ES10开始会保留这些空格，如果是原生函数则返回你控制台看到的效果，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.toString())</span><br><span class="line"><span class="comment">// "function sum(a, b) &#123;</span></span><br><span class="line"><span class="comment">// 		return a + b;</span></span><br><span class="line"><span class="comment">//  &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs.toString()) <span class="comment">// "function abs() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>

<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>在以往的版本中，<code>try-catch</code>里<code>catch</code>后面必须带异常参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ES10之前</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// tryCode</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// catchCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在ES10之后，这个参数却不是必须的，如果用不到，我们可以不用传，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Foobar'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Bar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><strong>BigInt</strong> 是一种内置对象，它提供了一种方法来表示大于 <code>253 - 1</code> 的整数。这原本是 Javascript中可以用 <code>Number</code> 表示的最大数字。<strong>BigInt</strong> 可以表示任意大的整数。</p>
<p>可以用在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>BigInt</code> ，如：<code>10n</code>，或者调用函数<code>BigInt()</code>。</p>
<p>在以往的版本中，我们有以下的弊端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大于2的53次方的整数，无法保持精度</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">53</span> === (<span class="number">2</span> ** <span class="number">53</span> + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 超过2的1024次方的数值，无法表示</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">1024</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>但是在ES10引入<code>BigInt</code>之后，这个问题便得到了解决。</p>
<p>以下操作符可以和 <code>BigInt</code> 一起使用： <code>+</code>、<code>*</code>、<code>-</code>、<code>**</code>、<code>%</code> 。除 <code>&gt;&gt;&gt;</code> （无符号右移）之外的位操作也可以支持。因为 <code>BigInt</code> 都是有符号的， <code>&gt;&gt;&gt;</code> （无符号右移）不能用于 <code>BigInt</code>。<code>BigInt</code> 不支持单目 (<code>+</code>) 运算符。</p>
<p><code>/</code> 操作符对于整数的运算也没问题。可是因为这些变量是 <code>BigInt</code> 而不是 <code>BigDecimal</code> ，该操作符结果会向零取整，也就是说不会返回小数部分。</p>
<p><code>BigInt</code> 和 <code>Number</code>不是严格相等的，但是宽松相等的。</p>
<p>所以在<code>BigInt</code>出来以后，JS的原始类型便增加到了7个，如下：</p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ES6)</li>
<li>BigInt (ES10)</li>
</ul>
<h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p><code>globalThis</code>属性包含类似于全局对象 <code>this</code>值。所以在全局环境下，我们有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalThis === <span class="keyword">this</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h3><p>静态的<code>import</code> 语句用于导入由另一个模块导出的绑定。无论是否声明了 严格模式，导入的模块都运行在严格模式下。在浏览器中，<code>import</code> 语句只能在声明了 <code>type=&quot;module&quot;</code> 的 <code>script</code> 的标签中使用。</p>
<p>但是在ES10之后，我们有动态 <code>import()</code>，它不需要依赖 <code>type=&quot;module&quot;</code> 的script标签。</p>
<p>所以我们有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">"nav &gt; a"</span>)) &#123;</span><br><span class="line">      link.addEventListener(<span class="string">"click"</span>, e =&gt; &#123;</span><br><span class="line">            e.preventDefault()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">import</span>(<span class="string">'/modules/my-module.js'</span>)</span><br><span class="line">              .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">module</span>.loadPageInto(main);</span><br><span class="line">              &#125;)</span><br><span class="line">              .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    main.textContent = err.message;</span><br><span class="line">              &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="私有元素与方法"><a href="#私有元素与方法" class="headerlink" title="私有元素与方法"></a>私有元素与方法</h3><p>在ES10之前，如果我们要实现一个简单的计数器组件，我们可能会这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// web component 写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">      <span class="keyword">get</span> x() &#123; </span><br><span class="line">          	<span class="keyword">return</span> <span class="keyword">this</span>.xValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> x(value) &#123;</span><br><span class="line">              <span class="keyword">this</span>.xValue = value</span><br><span class="line">              <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      clicked() &#123;</span><br><span class="line">            <span class="keyword">this</span>.x++</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">super</span>()</span><br><span class="line">            <span class="keyword">this</span>.onclick = <span class="keyword">this</span>.clicked.bind(<span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">this</span>.xValue = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      connectedCallback() &#123; </span><br><span class="line">          	<span class="keyword">this</span>.render()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">            <span class="keyword">this</span>.textContent = <span class="keyword">this</span>.x.toString()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'num-counter'</span>, Counter)</span><br></pre></td></tr></table></figure>

<p>但是在ES10之后我们可以使用私有变量进行组件封装，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">      #xValue = 0</span><br><span class="line"></span><br><span class="line">      <span class="keyword">get</span> #x() &#123; </span><br><span class="line">          return #xValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> #x(value) &#123;</span><br><span class="line">            this.#xValue = value</span><br><span class="line">            window.requestAnimationFrame(this.#render.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      #clicked() &#123;</span><br><span class="line">            this.#x++</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            this.onclick = this.#clicked.bind(this)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      connectedCallback() &#123; </span><br><span class="line">          	this.#render()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      #render() &#123;</span><br><span class="line">            this.textContent = this.#x.toString()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'num-counter'</span>, Counter)</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://es6.ruanyifeng.com/#docs/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li>
<li><a href="https://juejin.im/post/5d9bf530518825427b27639d" target="_blank" rel="noopener">1.5万字概括ES6全部特性</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">MDN</a></li>
<li><a href="https://segmentfault.com/a/1190000013519526" target="_blank" rel="noopener">ES2018 新特征之：非转义序列的模板字符串</a></li>
<li><a href="https://esnext.justjavac.com/proposal/regexp-lookbehind.html" target="_blank" rel="noopener">正则表达式反向(lookbehind)断言</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noopener">Unicode property escapes</a></li>
<li><a href="https://esnext.justjavac.com/proposal/exponentiation-operator.html" target="_blank" rel="noopener">exnext提案</a></li>
<li><a href="https://mp.weixin.qq.com/s/JuWoahhnEunkOTi4qNtWQg" target="_blank" rel="noopener">ES7、ES8、ES9、ES10新特性大盘点</a></li>
<li><a href="https://github.com/tc39" target="_blank" rel="noopener">Ecma TC39</a></li>
<li><a href="https://www.jianshu.com/p/b0877d1fc2a4" target="_blank" rel="noopener">[ECMAScript] TC39 process</a></li>
<li><a href="https://tc39.es/process-document/" target="_blank" rel="noopener">The TC39 Process</a></li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/21/原生JS-灵魂拷问-下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/21/原生JS-灵魂拷问-下/" class="post-title-link" itemprop="url">原生JS-灵魂拷问-下</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-21 16:29:16 / 修改时间：18:50:00" itemprop="dateCreated datePublished" datetime="2019-12-21T16:29:16+08:00">2019-12-21</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第24篇-JavaScript内存机制之问——数据是如何存储的？"><a href="#第24篇-JavaScript内存机制之问——数据是如何存储的？" class="headerlink" title="第24篇: JavaScript内存机制之问——数据是如何存储的？"></a>第24篇: JavaScript内存机制之问——数据是如何存储的？</h2><p>网上的资料基本是这样说的: 基本数据类型用<code>栈</code>存储，引用数据类型用<code>堆</code>存储。</p>
<p>看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完<code>栈顶空间销毁</code>，闭包变量不就没了吗？</p>
<p>其实还是需要补充一句:</p>
<blockquote>
<p>闭包变量是存在堆内存中的。</p>
</blockquote>
<p>具体而言，以下数据类型存储在栈中:</p>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
<li>bigint</li>
</ul>
<p>而所有的对象数据类型存放在堆中。</p>
<p>值得注意的是，对于<code>赋值</code>操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。</p>
<p>因此会有下面的情况:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = obj;</span><br><span class="line">newObj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//变成了2</span></span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为 obj 和 newObj 是同一份堆空间的地址，改变newObj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。</p>
<p>当然，你可能会问: 为什么不全部用栈来保存呢？</p>
<p>首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  f(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：</p>
<ol>
<li>调用func, 将 func 函数的上下文压栈，ESP指向栈顶。</li>
<li>执行func，又调用f函数，将 f 函数的上下文压栈，ESP 指针上移。</li>
<li>执行完 f 函数，将ESP 下移，f函数对应的栈顶空间被回收。</li>
<li>执行完 func，ESP 下移，func对应的空间被回收。</li>
</ol>
<p>图示如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%9B%BE.webp" alt></p>
<p>因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！</p>
<p>不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销，下一篇就来分析一下堆内存到底是如何进行垃圾回收并进行优化的。</p>
<h2 id="第25篇：V8-引擎如何进行垃圾内存的回收？"><a href="#第25篇：V8-引擎如何进行垃圾内存的回收？" class="headerlink" title="第25篇：V8 引擎如何进行垃圾内存的回收？"></a>第25篇：V8 引擎如何进行垃圾内存的回收？</h2><p>JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解JS的闭包特性、以及对内存的高效使用，都有很大的帮助。</p>
<h3 id="V8-内存限制"><a href="#V8-内存限制" class="headerlink" title="V8 内存限制"></a>V8 内存限制</h3><p>在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在<code>64</code>位系统下，V8最多只能分配<code>1.4G</code>, 在 32 位系统中，最多只能分配<code>0.7G</code>。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。</p>
<p>我们知道对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。</p>
<p>上一篇我们提到过了，所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。</p>
<p>那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？</p>
<p>究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。</p>
<p>首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p>
<blockquote>
<p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。</p>
</blockquote>
<p>可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。</p>
<p>不过，如果你想调整这个内存的限制也不是不行。配置命令如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存</span></span><br><span class="line">node --max-old-space-size=<span class="number">2048</span> xxx.js</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是调整新生代这部分的内存，单位是 KB。</span></span><br><span class="line">node --max-<span class="keyword">new</span>-space-size=<span class="number">2048</span> xxx.js</span><br></pre></td></tr></table></figure>

<h3 id="新生代内存的回收"><a href="#新生代内存的回收" class="headerlink" title="新生代内存的回收"></a>新生代内存的回收</h3><p>V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61.webp" alt></p>
<p>根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。</p>
<p>首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。</p>
<p>那好了，新生代的垃圾回收是怎么做的呢？</p>
<p>首先将新生代内存空间一分为二:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62.webp" alt></p>
<p>其中From部分表示正在使用的内存，To 是目前闲置的内存。</p>
<p>当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。</p>
<p>当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色<code>对调</code>，From现在被闲置，To为正在使用，如此循环。</p>
<p>那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？</p>
<p>注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63.webp" alt></p>
<p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做<strong>内存碎片</strong>。刚刚介绍的新生代垃圾回收算法也叫<strong>Scavenge算法</strong>。</p>
<p>Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64.webp" alt></p>
<p>是不是整齐了许多？这样就大大方便了后续连续空间的分配。</p>
<p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象<code>一般很少</code>，因此<code>时间</code>性能非常优秀。</p>
<h3 id="老生代内存的回收"><a href="#老生代内存的回收" class="headerlink" title="老生代内存的回收"></a>老生代内存的回收</h3><p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到<code>老生代内存</code>中，这种现象就叫<code>晋升</code>。</p>
<p>发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p>
<ul>
<li>已经经历过一次 Scavenge 回收。</li>
<li>To（闲置）空间的内存占用超过25%。</li>
</ul>
<p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用<code>Scavenge</code>算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？</p>
<p>那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？</p>
<p>第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中<code>使用的变量</code>以及被<code>强引用</code>的变量取消标记，剩下的就是要删除的变量了，在随后的<code>清除阶段</code>对其进行空间的回收。</p>
<p>当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？</p>
<p>第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B65.webp" alt></p>
<p>由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。</p>
<h3 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h3><p>由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就”歇”一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。</p>
<p>经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。</p>
<p>JS垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它<code>为什么要这么做</code>，而不仅仅是<code>如何做的</code>，希望这篇总结能够对你有所启发。</p>
<h2 id="第26篇-描述一下-V8-执行一段JS代码的过程？"><a href="#第26篇-描述一下-V8-执行一段JS代码的过程？" class="headerlink" title="第26篇: 描述一下 V8 执行一段JS代码的过程？"></a>第26篇: 描述一下 V8 执行一段JS代码的过程？</h2><p>前端相对来说是一个比较新兴的领域，因此各种前端框架和工具层出不穷，让人眼花缭乱，尤其是各大厂商推出<code>小程序</code>之后<code>各自制定标准</code>，让前端开发的工作更加繁琐，在此背景下为了抹平平台之间的差异，诞生的各种<code>编译工具/框架</code>也数不胜数。但无论如何，想要赶上这些框架和工具的更新速度是非常难的，即使赶上了也很难产生自己的<code>技术积淀</code>，一个更好的方式便是学习那些<code>本质的知识</code>，抓住上层应用中不变的<code>底层机制</code>，这样我们便能轻松理解上层的框架而不仅仅是被动地使用，甚至能够在适当的场景下自己造出轮子，以满足开发效率的需求。</p>
<p>站在 V8 的角度，理解其中的执行机制，也能够帮助我们理解很多的上层应用，包括Babel、Eslint、前端框架的底层机制。那么，一段 JavaScript 代码放在 V8 当中究竟是如何执行的呢？</p>
<p>首先需要明白的是，机器是读不懂 JS 代码，机器只能理解特定的机器码，那如果要让 JS 的逻辑在机器上运行起来，就必须将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:</p>
<ul>
<li>通过词法分析和语法分析生成 AST(抽象语法树)</li>
<li>生成字节码</li>
</ul>
<p>然后解释器根据字节码来执行程序。但 JS 整个执行的过程其实会比这个更加复杂，接下来就来一一地拆解。</p>
<h3 id="1-生成-AST"><a href="#1-生成-AST" class="headerlink" title="1.生成 AST"></a>1.生成 AST</h3><p>生成 AST 分为两步——词法分析和语法分析。</p>
<p>词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'sanyuan'</span></span><br></pre></td></tr></table></figure>

<p>其中会把句子分解成四个部分:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.webp" alt></p>
<p>最后生成的 AST 是这样的:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B2.webp" alt></p>
<p>当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES6 的代码解析生成<code>ES6的AST</code>，然后将 ES6 的 AST 转换为 <code>ES5 的AST</code>,最后才将 ES5 的 AST 转化为具体的 ES5 代码。由于本文着重阐述原理，关于 babel 编译的细节就不展开了，推荐大家去读一读荒山的<a href="https://juejin.im/post/5d94bfbf5188256db95589be" target="_blank" rel="noopener">babel文章</a>, 帮你打开新世界的大门: )</p>
<p>回到 V8 本身，生成 AST 后，接下来会生成执行上下文，关于执行上下文，可以参考上上篇《JavaScript内存机制之问——数据是如何存储的？》中对于上下文压栈出栈过程的讲解。</p>
<h3 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2. 生成字节码"></a>2. 生成字节码</h3><p>开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是<code>字节码</code>并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。</p>
<p>给一张对比图让大家直观地感受以下三者代码量的差异:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B3.webp" alt></p>
<p>很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？</p>
<blockquote>
<p>子节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。</p>
</blockquote>
<p>字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。</p>
<h3 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h3><p>接下来，就进入到字节码解释执行的阶段啦！</p>
<p>在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做<code>热点代码</code>(HotSpot)，然后将这么代码编译成<code>机器码</code>保存起来，这个用来编译的工具就是V8的<code>编译器</code>(也叫做<code>TurboFan</code>) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为<code>热点代码</code>，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。</p>
<p>其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。</p>
<p>并且，这种字节码跟编译器和解释器结合的技术，我们称之为<code>即时编译</code>, 也就是我们经常听到的<code>JIT</code>。</p>
<p>这就是 V8 中执行一段JS代码的整个过程，梳理一下:</p>
<ol>
<li>首先通过词法分析和语法分析生成 <code>AST</code></li>
<li>将 AST 转换为字节码</li>
<li>由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率</li>
</ol>
<p>关于这个问题的拆解就到这里，希望对你有所启发。</p>
<h2 id="第28篇：如何理解EventLoop——宏任务和微任务篇"><a href="#第28篇：如何理解EventLoop——宏任务和微任务篇" class="headerlink" title="第28篇：如何理解EventLoop——宏任务和微任务篇"></a>第28篇：如何理解EventLoop——宏任务和微任务篇</h2><h3 id="宏任务-MacroTask-引入"><a href="#宏任务-MacroTask-引入" class="headerlink" title="宏任务(MacroTask)引入"></a>宏任务(MacroTask)引入</h3><p>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:</p>
<ol>
<li>渲染事件</li>
<li>用户交互事件</li>
<li>js脚本执行</li>
<li>网络请求、文件读写完成事件等等。</li>
</ol>
<p>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种<code>队列</code>的方式来存储这些任务， 即先进来的先执行。模拟如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">void</span> MainTherad()&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//执行队列中的任务</span></span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行延迟队列中的任务</span></span><br><span class="line">    ProcessDelayTask()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了一个 for 循环，将队列中的任务一一取出，然后执行，这个很好理解。但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如setTimeout/setInterval这样的定时器回调任务。</p>
<p>上述提到的，普通任务队列和延迟队列中的任务，都属于<strong>宏任务</strong>。</p>
<h3 id="微任务-MicroTask-引入"><a href="#微任务-MicroTask-引入" class="headerlink" title="微任务(MicroTask)引入"></a>微任务(MicroTask)引入</h3><p>对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？</p>
<p>其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:</p>
<ol>
<li>将异步回调进行宏任务队列的入队操作。</li>
<li>将异步回调放到当前宏任务的末尾。</li>
</ol>
<p>如果采用第一种方式，那么执行回调的时机应该是在前面<code>所有的宏任务</code>完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成<code>应用卡顿</code>。</p>
<p>为了规避这样的问题，V8 引入了第二种方式，这就是<code>微任务</code>的解决方式。在每一个宏任务中定义一个<strong>微任务队列</strong>，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则<code>依次执行微任务</code>，执行完成才去执行下一个宏任务。</p>
<p>常见的微任务有MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程。</p>
<p>Ok, 这便是<code>宏任务</code>和<code>微任务</code>的概念，接下来正式介绍JS非常重要的运行机制——EventLoop。</p>
<h2 id="第29篇-如何理解EventLoop——浏览器篇"><a href="#第29篇-如何理解EventLoop——浏览器篇" class="headerlink" title="第29篇: 如何理解EventLoop——浏览器篇"></a>第29篇: 如何理解EventLoop——浏览器篇</h2><p>干讲理论不容易理解，让我们直接以一个例子开始吧:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure>

<p>我们来分析一下:</p>
<ol>
<li>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈(关于执行栈，若不了解请移步之前的文章《JavaScript内存机制之问——数据是如何存储的？》)进行执行，因此<strong>先打印start和end</strong></li>
<li>setTimeout 作为一个宏任务放入宏任务队列</li>
<li>Promise.then作为一个为微任务放入到微任务队列</li>
<li>当本次宏任务执行完，检查微任务队列，发现一个Promise.then, <strong>执行</strong></li>
<li>接下来进入到下一个宏任务——setTimeout, <strong>执行</strong></li>
</ol>
<p>因此最后的顺序是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">resolve</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<p>这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结。</p>
<ol>
<li>一开始整段脚本作为第一个<strong>宏任务</strong>执行</li>
<li>执行过程中同步代码直接执行，<strong>宏任务</strong>进入宏任务队列，<strong>微任务</strong>进入微任务队列</li>
<li>当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空</li>
<li>执行浏览器 UI 线程的渲染工作</li>
<li>检查是否有Web worker任务，有则执行</li>
<li>执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</li>
</ol>
<p>最后给大家留一道题目练习:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// Promise2</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br></pre></td></tr></table></figure>

<h2 id="第30篇-如何理解EventLoop——nodejs篇"><a href="#第30篇-如何理解EventLoop——nodejs篇" class="headerlink" title="第30篇: 如何理解EventLoop——nodejs篇"></a>第30篇: 如何理解EventLoop——nodejs篇</h2><p>nodejs 和 浏览器的 eventLoop 还是有很大差别的，值得单独拿出来说一说。</p>
<p>不知你是否看过关于 nodejs 中 eventLoop 的一些文章, 是否被这些流程图搞得眼花缭乱、一头雾水:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-node1.webp" alt></p>
<p>看到这你不用紧张，这里会抛开这些晦涩的流程图，以最清晰浅显的方式来一步步拆解 nodejs 的事件循环机制。</p>
<h3 id="1-三大关键阶段"><a href="#1-三大关键阶段" class="headerlink" title="1. 三大关键阶段"></a>1. 三大关键阶段</h3><p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p>
<ol>
<li>执行 <code>定时器回调</code> 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它<code>timer</code>。</li>
<li>轮询(英文叫<code>poll</code>)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、 ‘connect’等事件使得事件循环到达 <code>poll</code> 阶段。到达了这个阶段后:</li>
</ol>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li><p>如果队列<code>不为空</code>，拿出队列中的方法依次执行</p>
</li>
<li><p>如果队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为空</span><br></pre></td></tr></table></figure>

<p>，检查是否有 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setImmdiate</span><br></pre></td></tr></table></figure>

<p> 的回调 </p>
<ul>
<li>有则前往<code>check阶段</code>(下面会说)</li>
<li><code>没有则继续等待</code>，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后<code>自动进入 check 阶段</code>。</li>
</ul>
</li>
</ul>
<ol>
<li>check 阶段。这是一个比较简单的阶段，直接<code>执行 setImmdiate</code> 的回调。</li>
</ol>
<p>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。</p>
<h3 id="2-完善"><a href="#2-完善" class="headerlink" title="2. 完善"></a>2. 完善</h3><p>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 <code>I/O异常的回调阶段</code>。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p>
<p>并且在 check 阶段结束后还会进入到 <code>关闭事件的回调阶段</code>。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， ‘close’ 事件的回调就会在这个阶段执行。</p>
<p>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</p>
<ol>
<li>timer 阶段</li>
<li>I/O 异常回调阶段</li>
<li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll 阶段</li>
<li>check 阶段</li>
<li>关闭事件的回调阶段</li>
</ol>
<p>是不是清晰了许多？</p>
<h3 id="3-实例演示"><a href="#3-实例演示" class="headerlink" title="3. 实例演示"></a>3. 实例演示</h3><p>好，我们以上次的练习题来实践一把:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这里我要说，node版本 &gt;= 11和在 11 以下的会有不同的表现。</p>
<p>首先说 node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">time2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>

<p>而 node 版本小于 11 的情况下，对于定时器的处理是:</p>
<blockquote>
<p>若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，<code>直接去执行</code>新的定时器任务，当新的定时器任务执行完后，<code>再一一执行</code>中途产生的微任务。</p>
</blockquote>
<p>因此会打印出这样的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>

<h3 id="4-nodejs-和-浏览器关于eventLoop的主要区别"><a href="#4-nodejs-和-浏览器关于eventLoop的主要区别" class="headerlink" title="4.nodejs 和 浏览器关于eventLoop的主要区别"></a>4.nodejs 和 浏览器关于eventLoop的主要区别</h3><p>两者最主要的区别在于浏览器中的微任务是在<code>每个相应的宏任务</code>中执行的，而nodejs中的微任务是在<code>不同阶段之间</code>执行的。</p>
<h3 id="5-关于process-nextTick的一点说明"><a href="#5-关于process-nextTick的一点说明" class="headerlink" title="5.关于process.nextTick的一点说明"></a>5.关于process.nextTick的一点说明</h3><p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p>
<p>在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<code>优先于微任务</code>执行。</p>
<h2 id="第31篇-nodejs中的异步、非阻塞I-O是如何实现的？"><a href="#第31篇-nodejs中的异步、非阻塞I-O是如何实现的？" class="headerlink" title="第31篇: nodejs中的异步、非阻塞I/O是如何实现的？"></a>第31篇: nodejs中的异步、非阻塞I/O是如何实现的？</h2><p>在听到 nodejs 相关的特性时，经常会对 <code>异步I/O</code>、<code>非阻塞I/O</code>有所耳闻，听起来好像是差不多的意思，但其实是两码事，下面我们就以原理的角度来剖析一下对 nodejs 来说，这两种技术底层是如何实现的？</p>
<h3 id="什么是I-O？"><a href="#什么是I-O？" class="headerlink" title="什么是I/O？"></a>什么是I/O？</h3><p>首先，我想有必要把 I/O 的概念解释一下。I/O 即Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于<code>网络I/O</code>。回到 nodejs 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:</p>
<ul>
<li>文件 I/O。比如用 fs 模块对文件进行读写操作。</li>
<li>网络 I/O。比如 http 模块发起网络请求。</li>
</ul>
<h3 id="阻塞和非阻塞I-O"><a href="#阻塞和非阻塞I-O" class="headerlink" title="阻塞和非阻塞I/O"></a>阻塞和非阻塞I/O</h3><p><code>阻塞</code>和<code>非阻塞</code> I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是一定要<strong>等到操作系统完成所有操作后才表示调用结束</strong>，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。</p>
<p>对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成<code>非阻塞I/O</code>，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 I/O 操作呢？</p>
<p>为了让 nodejs 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是<code>轮询</code>。对于轮询而言，有以下这么几种方案:</p>
<ol>
<li>一直轮询检查I/O状态，直到 I/O 完成。这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面。其实跟阻塞 I/O 的效果是一样的。</li>
<li>遍历文件描述符(即 文件I/O 时操作系统和 nodejs 之间的文件凭证)的方式来确定 I/O 是否完成，I/O完成则文件描述符的状态改变。但 CPU 轮询消耗还是很大。</li>
<li>epoll模式。即在进入轮询的时候如果I/O未完成CPU就休眠，完成之后唤醒CPU。</li>
</ol>
<p>总之，CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:</p>
<blockquote>
<p>nodejs 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。</p>
</blockquote>
<p>这是理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？</p>
<h3 id="异步-I-O-的本质"><a href="#异步-I-O-的本质" class="headerlink" title="异步 I/O 的本质"></a>异步 I/O 的本质</h3><p>Linux 原生存在这样的一种方式，即(AIO), 但两个致命的缺陷:</p>
<ol>
<li>只有 Linux 下存在，在其他系统中没有异步 I/O 支持。</li>
<li>无法利用系统缓存。</li>
</ol>
<h4 id="nodejs中的异步-I-O-方案"><a href="#nodejs中的异步-I-O-方案" class="headerlink" title="nodejs中的异步 I/O 方案"></a>nodejs中的异步 I/O 方案</h4><p>是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，<strong>异步 I/O 就是使用这样的线程池来实现的</strong>。</p>
<p>只不过在不同的系统下面表现会有所差异，在 Linux 下可以直接使用线程池来完成，在Window系统下则采用 IOCP 这个系统API(其内部还是用线程池完成的)。</p>
<p>有了操作系统的支持，那 nodejs 如何来对接这些操作系统从而实现异步 I/O 呢？</p>
<p>以文件为 I/O 我们以一段代码为例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'/test.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>执行代码的过程中大概发生了这些事情:</p>
<ol>
<li>首先，fs.readFile调用Node的核心模块fs.js ；</li>
<li>接下来，Node的核心模块调用内建模块node_file.cc，创建对应的文件I/O观察者对象(这个对象后面有大用！) ；</li>
<li>最后，根据不同平台（Linux或者window），内建模块通过libuv中间层进行系统调用</li>
</ol>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-node2.webp" alt></p>
<h4 id="ibuv调用过程拆解"><a href="#ibuv调用过程拆解" class="headerlink" title="ibuv调用过程拆解"></a>ibuv调用过程拆解</h4><p>重点来了！libuv 中是如何来进行进行系统调用的呢？也就是 uv_fs_open() 中做了些什么？</p>
<h5 id="1-创建请求对象"><a href="#1-创建请求对象" class="headerlink" title="1. 创建请求对象"></a>1. 创建请求对象</h5><p>以Windows系统为例来说，在这个函数的调用过程中，我们创建了一个文件I/O的<strong>请求对象</strong>，并往里面注入了回调函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback);</span><br></pre></td></tr></table></figure>

<p>req_wrap 便是这个请求对象，req_wrap 中 object_ 的 oncomplete_sym 属性对应的值便是我们 nodejs 应用程序代码中传入的回调函数。</p>
<h5 id="2-推入线程池，调用返回"><a href="#2-推入线程池，调用返回" class="headerlink" title="2. 推入线程池，调用返回"></a>2. 推入线程池，调用返回</h5><p>在这个对象包装完成后，QueueUserWorkItem() 方法将这个对象推进线程池中等待执行。</p>
<p>好，至此现在js的调用就直接返回了，我们的 js 应用程序代码可以<code>继续往下执行</code>，当然，当前的 <code>I/O</code> 操作同时也在线程池中将被执行，这不就完成了异步么：）</p>
<p>等等，别高兴太早，回调都还没执行呢！接下来便是执行回调通知的环节。</p>
<h5 id="3-回调通知"><a href="#3-回调通知" class="headerlink" title="3. 回调通知"></a>3. 回调通知</h5><p>事实上现在线程池中的 I/O 无论是阻塞还是非阻塞都已经无所谓了，因为异步的目的已经达成。重要的是 I/O 完成后会发生什么。</p>
<p>在介绍后续的故事之前，给大家介绍两个重要的方法: <code>GetQueuedCompletionStatus</code> 和 <code>PostQueuedCompletionStatus</code>。</p>
<ol>
<li>还记得之前讲过的 eventLoop 吗？在每一个Tick当中会调用<code>GetQueuedCompletionStatus</code>检查线程池中是否有执行完的请求，如果有则表示时机已经成熟，可以执行回调了。</li>
<li><code>PostQueuedCompletionStatus</code>方法则是向 IOCP 提交状态，告诉它当前I/O完成了。</li>
</ol>
<p>名字比较长，先介绍是为了让大家混个脸熟，至少后面出来不会感到太突兀：）</p>
<p>我们言归正传，把后面的过程串联起来。</p>
<p>当对应线程中的 I/O 完成后，会将获得的结果<code>存储</code>起来，保存到<code>相应的请求对象</code>中，然后调用<code>PostQueuedCompletionStatus()</code>向 IOCP 提交执行完成的状态，并且将线程还给操作系统。一旦 EventLoop 的轮询操作中，调用<code>GetQueuedCompletionStatus</code>检测到了完成的状态，就会把<code>请求对象</code>塞给I/O观察者(之前埋下伏笔，如今终于闪亮登场)。</p>
<p>I/O 观察者现在的行为就是取出<code>请求对象</code>的<code>存储结果</code>，同时也取出它的<code>oncomplete_sym</code>属性，即回调函数(不懂这个属性的回看第1步的操作)。将前者作为函数参数传入后者，并执行后者。 这里，回调函数就成功执行啦！</p>
<p>总结 :</p>
<ol>
<li><code>阻塞</code>和<code>非阻塞</code> I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要<strong>等到操作系统完成所有操作后才表示调用结束</strong>，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。</li>
<li>nodejs中的异步 I/O 采用多线程的方式，由 <code>EventLoop</code>、<code>I/O 观察者</code>，<code>请求对象</code>、<code>线程池</code>四大要素相互配合，共同实现。</li>
</ol>
<h2 id="第32篇：JS异步编程有哪些方案？为什么会出现这些方案？"><a href="#第32篇：JS异步编程有哪些方案？为什么会出现这些方案？" class="headerlink" title="第32篇：JS异步编程有哪些方案？为什么会出现这些方案？"></a>第32篇：JS异步编程有哪些方案？为什么会出现这些方案？</h2><p>关于 JS <code>单线程</code>、<code>EventLoop</code> 以及<code>异步 I/O</code> 这些底层的特性，我们之前做过了详细的拆解，不在赘述。在探究了底层机制之后，我们还需要对代码的组织方式有所理解，这是离我们最日常开发最接近的部分，异步代码的组织方式直接决定了<code>开发</code>和<code>维护</code>的<code>效率</code>，其重要性也不可小觑。尽管<strong>底层机制</strong>没变，但异步代码的组织方式却随着 ES 标准的发展，一步步发生了巨大的<code>变革</code>。接着让我们来一探究竟吧！</p>
<h3 id="回调函数时代"><a href="#回调函数时代" class="headerlink" title="回调函数时代"></a>回调函数时代</h3><p>相信很多 nodejs 的初学者都或多或少踩过这样的坑，node 中很多原生的 api 就是诸如这样的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'xxx'</span>, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>典型的高阶函数，将回调函数作为函数参数传给了readFile。但久而久之，就会发现，这种传入回调的方式也存在大坑, 比如下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'1.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    fs.readFile(<span class="string">'2.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">        fs.readFile(<span class="string">'3.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            fs.readFile(<span class="string">'4.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调当中嵌套回调，也称<code>回调地狱</code>。这种代码的可读性和可维护性都是非常差的，因为嵌套的层级太多。而且还有一个严重的问题，就是每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。</p>
<h3 id="Promise-时代"><a href="#Promise-时代" class="headerlink" title="Promise 时代"></a>Promise 时代</h3><p>ES6 中新增的 Promise 就很好了解决了<code>回调地狱</code>的问题，同时了合并了错误处理。写出来的代码类似于下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'3.json'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'4.json'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以链式调用的方式避免了大量的嵌套，也符合人的线性思维方式，大大方便了异步编程。</p>
<h3 id="co-Generator-方式"><a href="#co-Generator-方式" class="headerlink" title="co + Generator 方式"></a>co + Generator 方式</h3><p>利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> r1 = <span class="keyword">yield</span> readFilePromise(<span class="string">'1.json'</span>);</span><br><span class="line">  <span class="keyword">const</span> r2 = <span class="keyword">yield</span> readFilePromise(<span class="string">'2.json'</span>);</span><br><span class="line">  <span class="keyword">const</span> r3 = <span class="keyword">yield</span> readFilePromise(<span class="string">'3.json'</span>);</span><br><span class="line">  <span class="keyword">const</span> r4 = <span class="keyword">yield</span> readFilePromise(<span class="string">'4.json'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="async-await方式"><a href="#async-await方式" class="headerlink" title="async + await方式"></a>async + await方式</h3><p>这是 ES7 中新增的关键字，凡是加上 async 的函数都默认返回一个 Promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFileAsync = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFilePromise(<span class="string">'1.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFilePromise(<span class="string">'2.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> f3 = <span class="keyword">await</span> readFilePromise(<span class="string">'3.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> f4 = <span class="keyword">await</span> readFilePromise(<span class="string">'4.json'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四种经典的异步编程方式就简单回顾完了，由于是鸟瞰大局，我觉得<code>知道是什么</code>比<code>了解细节</code>要重要, 因此也没有展开。不过没关系，接下来，让我们针对这些具体的解决方案，一步步深入异步编程，理解其中的本质。</p>
<h2 id="第33篇-能不能简单实现一下-node-中回调函数的机制？"><a href="#第33篇-能不能简单实现一下-node-中回调函数的机制？" class="headerlink" title="第33篇: 能不能简单实现一下 node 中回调函数的机制？"></a>第33篇: 能不能简单实现一下 node 中回调函数的机制？</h2><p><code>回调函数</code>的方式其实内部利用了<code>发布-订阅</code>模式，在这里我们以模拟实现 node 中的 Event 模块为例来写实现回调函数的机制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.events = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 EventEmitter 一共需要实现这些方法: <code>addListener</code>, <code>removeListener</code>, <code>once</code>, <code>removeAllListener</code>, <code>emit</code>。</p>
<p>首先是addListener：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// once 参数表示是否只是触发一次</span></span><br><span class="line"><span class="keyword">const</span> wrapCallback = <span class="function">(<span class="params">fn, once = <span class="literal">false</span></span>) =&gt;</span> (&#123; <span class="attr">callback</span>: fn, once &#125;);</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn, once = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="comment">// 为 type 事件绑定回调</span></span><br><span class="line">    <span class="keyword">this</span>.events.set(type, wrapCallback(fn, once));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler.callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 目前 type 事件只有一个回调</span></span><br><span class="line">    <span class="keyword">this</span>.events.set(type, [handler, wrapCallback(fn, once)]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 目前 type 事件回调数 &gt;= 2</span></span><br><span class="line">    handler.push(wrapCallback(fn, once));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeLisener 的实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler.callback === listener.callback) <span class="keyword">this</span>.events.delete(type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = handler[i];</span><br><span class="line">    <span class="keyword">if</span> (item.callback === listener.callback) &#123;</span><br><span class="line">      <span class="comment">// 删除该回调，注意数组塌陷的问题，即后面的元素会往前挪一位。i 要 -- </span></span><br><span class="line">      handler.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--;</span><br><span class="line">      <span class="keyword">if</span> (handler.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 长度为 1 就不用数组存了</span></span><br><span class="line">        <span class="keyword">this</span>.events.set(type, handler[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>once 实现思路很简单，先调用 addListener 添加上了once标记的回调对象, 然后在 emit 的时候遍历回调列表，将标记了once: true的项remove掉即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.addListener(type, fn, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">    <span class="comment">// 遍历列表，执行回调</span></span><br><span class="line">    handler.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.callback.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="comment">// 标记的 once: true 的项直接移除</span></span><br><span class="line">      <span class="keyword">if</span> (item.once) <span class="keyword">this</span>.removeListener(type, item);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个回调则直接执行</span></span><br><span class="line">    handler.callback.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是 removeAllListener：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeAllListener = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.events.delete(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们测试一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">e.addListener(<span class="string">'type'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"type事件触发！"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">e.addListener(<span class="string">'type'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"WOW!type事件又触发了！"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"type事件我只触发一次"</span>); </span><br><span class="line">&#125;</span><br><span class="line">e.once(<span class="string">'type'</span>, f)</span><br><span class="line">e.emit(<span class="string">'type'</span>);</span><br><span class="line">e.emit(<span class="string">'type'</span>);</span><br><span class="line">e.removeAllListener(<span class="string">'type'</span>);</span><br><span class="line">e.emit(<span class="string">'type'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// type事件触发！</span></span><br><span class="line"><span class="comment">// WOW!type事件又触发了！</span></span><br><span class="line"><span class="comment">// type事件我只触发一次</span></span><br><span class="line"><span class="comment">// type事件触发！</span></span><br><span class="line"><span class="comment">// WOW!type事件又触发了！</span></span><br></pre></td></tr></table></figure>

<p>OK，一个简易的 Event 就这样实现完成了，为什么说它简易呢？因为还有很多细节的部分没有考虑:</p>
<ol>
<li>在<code>参数少</code>的情况下，call 的性能优于 apply，反之 apply 的性能更好。因此在执行回调时候可以根据情况调用 call 或者 apply。</li>
<li>考虑到内存容量，应该设置<code>回调列表的最大值</code>，当超过最大值的时候，应该选择部分回调进行删除操作。</li>
<li><code>鲁棒性</code>有待提高。对于<code>参数的校验</code>很多地方直接忽略掉了。</li>
</ol>
<p>不过，这个案例的目的只是带大家掌握核心的原理，如果在这里洋洋洒洒写三四百行意义也不大，有兴趣的可以去看看Node中 <a href="https://github.com/Gozala/events/blob/master/events.js" target="_blank" rel="noopener">Event 模块</a> 的源码，里面对各种细节和边界情况做了详细的处理。</p>
<h2 id="第34篇-Promise之问-一-——Promise-凭借什么消灭了回调地狱？"><a href="#第34篇-Promise之问-一-——Promise-凭借什么消灭了回调地狱？" class="headerlink" title="第34篇: Promise之问(一)——Promise 凭借什么消灭了回调地狱？"></a>第34篇: Promise之问(一)——Promise 凭借什么消灭了回调地狱？</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>首先，什么是回调地狱:</p>
<ol>
<li>多层嵌套的问题。</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<p>这两种问题在回调函数时代尤为突出。Promise 的诞生就是为了解决这两个问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Promise 利用了三大技术手段来解决<code>回调地狱</code>:</p>
<ul>
<li><strong>回调函数延迟绑定</strong>。</li>
<li><strong>返回值穿透</strong>。</li>
<li><strong>错误冒泡</strong>。</li>
</ul>
<p>首先来举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看到没有，回调函数不是直接声明的，而是在通过后面的 then 方法传入的，即延迟传入。这就是<code>回调函数延迟绑定</code>。</p>
<p>然后我们做以下微调:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>)<span class="comment">//这是返回的Promise</span></span><br><span class="line">&#125;);</span><br><span class="line">x.then(<span class="comment">/* 内部逻辑省略 */</span>)</span><br></pre></td></tr></table></figure>

<p>我们会根据 then 中回调函数的传入值创建不同类型的Promise, 然后把返回的 Promise 穿透到外层, 以供后续的调用。这里的 x 指的就是内部返回的 Promise，然后在 x 后面可以依次完成链式调用。</p>
<p>这便是<code>返回值穿透</code>的效果。</p>
<p>这两种技术一起作用便可以将深层的嵌套回调写成下面的形式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'3.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'4.json'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就显得清爽了许多，更重要的是，它更符合人的线性思维模式，开发体验也更好。</p>
<p>两种技术结合产生了<code>链式调用</code>的效果。</p>
<p>这解决的是多层嵌套的问题，那另一个问题，即每次任务执行结束后<code>分别处理成功和失败</code>的情况怎么解决的呢？</p>
<p>Promise 采用了<code>错误冒泡</code>的方式。其实很简单理解，我们来看看效果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'3.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'4.json'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。</p>
<h3 id="解决效果"><a href="#解决效果" class="headerlink" title="解决效果"></a>解决效果</h3><ul>
<li><ol>
<li>实现链式调用，解决多层嵌套问题</li>
</ol>
</li>
<li><ol>
<li>实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题</li>
</ol>
</li>
</ul>
<h2 id="第35篇-Promise之问-二-——为什么Promise要引入微任务？"><a href="#第35篇-Promise之问-二-——为什么Promise要引入微任务？" class="headerlink" title="第35篇: Promise之问(二)——为什么Promise要引入微任务？"></a>第35篇: Promise之问(二)——为什么Promise要引入微任务？</h2><p>在这里，如果你还没有接触过 Promise, 务必去看看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN 文档</a>，了解使用方式，不然后面很会懵。</p>
<p>Promise 中的执行函数是同步进行的，但是里面存在着异步操作，在异步操作结束后会调用 resolve 方法，或者中途遇到错误调用 reject 方法，这两者都是作为微任务进入到 EventLoop 中。但是你有没有想过，Promise 为什么要引入微任务的方式来进行回调操作？</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:</p>
<ol>
<li>使用同步回调，直到异步任务进行完，再进行后面的任务。</li>
<li>使用异步回调，将回调函数放在进行<code>宏任务队列</code>的队尾。</li>
<li>使用异步回调，将回调函数放到<code>当前宏任务中</code>的最后面。</li>
</ol>
<h3 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h3><p>第一种方式显然不可取，因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分<code>等待的时间</code>是可以拿来完成其他事情的，导致 CPU 的利用率非常低，而且还有另外一个致命的问题，就是无法实现<code>延迟绑定</code>的效果。</p>
<p>如果采用第二种方式，那么执行回调(resolve/reject)的时机应该是在前面<code>所有的宏任务</code>完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成<code>应用卡顿</code>。</p>
<p>为了解决上述方案的问题，另外也考虑到<code>延迟绑定</code>的需求，Promise 采取第三种方式, 即<code>引入微任务</code>, 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。</p>
<p>这样，利用<code>微任务</code>解决了两大痛点:</p>
<ul>
<li><ol>
<li>采用<strong>异步回调</strong>替代同步回调解决了浪费 CPU 性能的问题。</li>
</ol>
</li>
<li><ol>
<li>放到<strong>当前宏任务最后</strong>执行，解决了回调执行的实时性问题。</li>
</ol>
</li>
</ul>
<p>好，Promise 的基本实现思想已经讲清楚了，相信大家已经知道了它<code>为什么这么设计</code>，接下来就让我们一步步弄清楚它内部到底是<code>怎么设计的</code>。</p>
<h2 id="第36篇-Promise之问-三-——Promise-如何实现链式调用？"><a href="#第36篇-Promise之问-三-——Promise-如何实现链式调用？" class="headerlink" title="第36篇: Promise之问(三)——Promise 如何实现链式调用？"></a>第36篇: Promise之问(三)——Promise 如何实现链式调用？</h2><p>从现在开始，我们就来动手实现一个功能完整的Promise，一步步深挖其中的细节。我们先从链式调用开始。</p>
<h3 id="简易版实现"><a href="#简易版实现" class="headerlink" title="简易版实现"></a>简易版实现</h3><p>首先写出第一版的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>; <span class="comment">// 缓存当前promise实例</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  self.error = <span class="literal">null</span>; </span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.onFulfilled = <span class="literal">null</span>; <span class="comment">//成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="literal">null</span>; <span class="comment">//失败的回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.status = FULFILLED;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.onFulfilled(self.value);<span class="comment">//resolve时执行成功回调</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.status = REJECTED;</span><br><span class="line">      self.error = error;</span><br><span class="line">      self.onRejected(self.error);<span class="comment">//resolve时执行成功回调</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    <span class="comment">//如果状态是fulfilled，直接执行成功回调，并将成功值传入</span></span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果状态是rejected，直接执行失败回调，并将失败原因传入</span></span><br><span class="line">    onRejected(<span class="keyword">this</span>.error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Promise 的本质是一个<code>有限状态机</code>，存在三种状态:</p>
<ul>
<li>PENDING(等待)</li>
<li>FULFILLED(成功)</li>
<li>REJECTED(失败)</li>
</ul>
<p>状态改变规则如下图:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-Promise.webp" alt></p>
<p>对于 Promise 而言，状态的改变<code>不可逆</code>，即由等待态变为其他的状态后，就无法再改变了。</p>
<p>不过，回到目前这一版的 Promise, 还是存在一些问题的。</p>
<h3 id="设置回调数组"><a href="#设置回调数组" class="headerlink" title="设置回调数组"></a>设置回调数组</h3><p>首先只能执行一个回调函数，对于多个回调的绑定就无能为力，比如下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">'./001.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x1 = promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第一次展示"</span>, data.toString());    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x2 = promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第二次展示"</span>, data.toString());    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x3 = promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第三次展示"</span>, data.toString());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我绑定了三个回调，想要在 resolve() 之后一起执行，那怎么办呢？</p>
<p>需要将 <code>onFulfilled</code> 和 <code>onRejected</code> 改为数组，调用 resolve 时将其中的方法拿出来一一执行即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.onFulfilledCallbacks = [];</span><br><span class="line">self.onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将 resolve 和 reject 方法中执行回调的部分进行修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 中</span></span><br><span class="line">self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br><span class="line"><span class="comment">//reject 中</span></span><br><span class="line">self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.error));</span><br></pre></td></tr></table></figure>

<h3 id="链式调用完成"><a href="#链式调用完成" class="headerlink" title="链式调用完成"></a>链式调用完成</h3><p>我们采用目前的代码来进行测试:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFilePromise(<span class="string">'./001.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());    </span><br><span class="line">  <span class="keyword">return</span> readFilePromise(<span class="string">'./002.txt'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 001.txt的内容</span></span><br><span class="line"><span class="comment">// 001.txt的内容</span></span><br></pre></td></tr></table></figure>

<p>咦？怎么打印了两个 <code>001</code>，第二次不是读的 <code>002</code> 文件吗？</p>
<p>问题出在这里:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写每次返回的都是第一个 Promise。then 函数当中返回的第二个 Promise 直接被无视了！</p>
<p>说明 then 当中的实现还需要改进, 我们现在需要对 then 中返回值重视起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bridgePromise;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      self.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 看到了吗？要拿到 then 中回调返回的结果。</span></span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(error);</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假若当前状态为 PENDING，将回调数组中添加如上的函数，当 Promise 状态变化后，会遍历相应回调数组并执行回调。</p>
<p>但是这段程度还是存在一些问题:</p>
<ol>
<li>首先 then 中的两个参数不传的情况并没有处理，</li>
<li>假如 then 中的回调执行后返回的结果(也就是上面的<code>x</code>)是一个 Promise, 直接给 resolve 了，这是我们不希望看到的。</li>
</ol>
<p>怎么来解决这两个问题呢？</p>
<p>先对参数不传的情况做判断:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功回调不传给它一个默认函数</span></span><br><span class="line">onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">"function"</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">// 对于失败回调直接抛错</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;;</span><br></pre></td></tr></table></figure>

<p>然后对<code>返回Promise</code>的情况进行处理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">bridgePromise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果x是一个promise</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="comment">// 拆解这个 promise ，直到返回值不为 promise 为止</span></span><br><span class="line">    <span class="keyword">if</span> (x.status === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">        resolvePromise(bridgePromise, y, resolve, reject);</span><br><span class="line">      &#125;, error =&gt; &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非 Promise 的话直接 resolve 即可</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 then 的方法实现中作如下修改:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve(x)  -&gt;  resolvePromise(bridgePromise, x, resolve, reject);</span><br></pre></td></tr></table></figure>

<p>在这里大家好好体会一下拆解 Promise 的过程，其实不难理解，我要强调的是其中的递归调用始终传入的<code>resolve</code>和<code>reject</code>这两个参数是什么含义，其实他们控制的是最开始传入的<code>bridgePromise</code>的状态，这一点非常重要。</p>
<p>紧接着，我们实现一下当 Promise 状态不为 PENDING 时的逻辑。</p>
<p>成功状态下调用then：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 状态变为成功，会有相应的 self.value</span></span><br><span class="line">      <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">      <span class="comment">// 暂时可以理解为 resolve(x)，后面具体实现中有拆解的过程</span></span><br><span class="line">      resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败状态下调用then：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 状态变为失败，会有相应的 self.error</span></span><br><span class="line">      <span class="keyword">let</span> x = onRejected(self.error);</span><br><span class="line">      resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise A+中规定成功和失败的回调都是微任务，由于浏览器中 JS 触碰不到底层微任务的分配，可以直接拿 <code>setTimeout</code>(属于<strong>宏任务</strong>的范畴) 来模拟，用 <code>setTimeout</code>将需要执行的任务包裹 ，当然，上面的 resolve 实现也是同理, 大家注意一下即可，其实并不是真正的微任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到这里, 我们基本实现了 then 方法，现在我们拿刚刚的测试代码做一下测试, 依次打印如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br></pre></td></tr></table></figure>

<p>可以看到，已经可以顺利地完成链式调用。</p>
<h3 id="错误捕获及冒泡机制分析"><a href="#错误捕获及冒泡机制分析" class="headerlink" title="错误捕获及冒泡机制分析"></a>错误捕获及冒泡机制分析</h3><p>现在来实现 catch 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对，就是这么几行，catch 原本就是 then 方法的语法糖。</p>
<p>相比于实现来讲，更重要的是理解其中错误冒泡的机制，即中途一旦发生错误，可以在最后用 catch 捕获错误。</p>
<p>我们回顾一下 Promise 的运作流程也不难理解，贴上一行关键的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then 的实现中</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;;</span><br></pre></td></tr></table></figure>

<p>一旦其中有一个<code>PENDING状态</code>的 Promise 出现错误后状态必然会变为<code>失败</code>, 然后执行 <code>onRejected</code>函数，而这个 onRejected 执行又会抛错，把新的 Promise 状态变为<code>失败</code>，新的 Promise 状态变为失败后又会执行<code>onRejected</code>……就这样一直抛下去，直到用<code>catch</code> 捕获到这个错误，才停止往下抛。</p>
<p>这就是 Promise 的<code>错误冒泡机制</code>。</p>
<p>至此，Promise 三大法宝: <code>回调函数延迟绑定</code>、<code>回调返回值穿透</code>和<code>错误冒泡</code>。</p>
<h2 id="第37篇-Promise-之问-四-——实现Promise的-resolve、reject-和-finally"><a href="#第37篇-Promise-之问-四-——实现Promise的-resolve、reject-和-finally" class="headerlink" title="第37篇: Promise 之问(四)——实现Promise的 resolve、reject 和 finally"></a>第37篇: Promise 之问(四)——实现Promise的 resolve、reject 和 finally</h2><h3 id="实现-Promise-resolve"><a href="#实现-Promise-resolve" class="headerlink" title="实现 Promise.resolve"></a>实现 Promise.resolve</h3><p>实现 resolve 静态方法有三个要点:</p>
<ul>
<li><ol>
<li>传参为一个 Promise, 则直接返回它。</li>
</ol>
</li>
<li><ol>
<li>传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，<code>采用它的最终状态</code>作为<code>自己的状态</code>。</li>
</ol>
</li>
<li><ol>
<li>其他情况，直接返回以该值为成功状态的promise对象。</li>
</ol>
</li>
</ul>
<p>具体实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(param <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="keyword">return</span> param;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(param &amp;&amp; param.then &amp;&amp; <span class="keyword">typeof</span> param.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span></span><br><span class="line">      param.then(resolve, reject);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(param);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Promise-reject"><a href="#实现-Promise-reject" class="headerlink" title="实现 Promise.reject"></a>实现 Promise.reject</h3><p>Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Promise-prototype-finally"><a href="#实现-Promise-prototype-finally" class="headerlink" title="实现 Promise.prototype.finally"></a>实现 Promise.prototype.finally</h3><p>无论当前 Promise 是成功还是失败，调用<code>finally</code>之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第38篇-Promise-之问-五-——实现Promise的-all-和-race"><a href="#第38篇-Promise-之问-五-——实现Promise的-all-和-race" class="headerlink" title="第38篇: Promise 之问(五)——实现Promise的 all 和 race"></a>第38篇: Promise 之问(五)——实现Promise的 all 和 race</h2><h3 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h3><p>对于 all 方法而言，需要完成下面的核心功能:</p>
<ol>
<li>传入参数为一个空的可迭代对象，则<code>直接进行resolve</code>。</li>
<li>如果参数中<code>有一个</code>promise失败，那么Promise.all返回的promise对象失败。</li>
<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个<code>数组</code></li>
</ol>
<p>具体实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index === len) resolve(result);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Promise-race"><a href="#实现-Promise-race" class="headerlink" title="实现 Promise.race"></a>实现 Promise.race</h3><p>race 的实现相比之下就简单一些，只要有一个 promise 执行完，直接 resolve 并停止执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，一个完整的 Promise 就被我们实现完啦。从原理到细节，我们一步步拆解和实现，希望大家在知道 Promise 设计上的几大亮点之后，也能自己手动实现一个Promise，让自己的思维层次和动手能力更上一层楼！</p>
<h2 id="第39篇-谈谈你对生成器以及协程的理解。"><a href="#第39篇-谈谈你对生成器以及协程的理解。" class="headerlink" title="第39篇: 谈谈你对生成器以及协程的理解。"></a>第39篇: 谈谈你对生成器以及协程的理解。</h2><p>生成器(Generator)是 ES6 中的新语法，相对于之前的异步语法，上手的难度还是比较大的。因此这里我们先来好好熟悉一下 Generator 语法。</p>
<h3 id="生成器执行流程"><a href="#生成器执行流程" class="headerlink" title="生成器执行流程"></a>生成器执行流程</h3><p>上面是生成器函数？</p>
<p>生成器是一个带<code>星号</code>的”函数”(注意：它并不是真正的函数)，可以通过<code>yield</code>关键字<code>暂停执行</code>和<code>恢复执行</code>的</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"enter"</span>);</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2</span>&#125;)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen() <span class="comment">// 阻塞住，不会执行任何语句</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> g)  <span class="comment">// object  看到了吗？不是"function"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next())  </span><br><span class="line"><span class="built_in">console</span>.log(g.next())  </span><br><span class="line"><span class="built_in">console</span>.log(g.next())  </span><br><span class="line"><span class="built_in">console</span>.log(g.next()) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// enter</span></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">// &#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>由此可以看到，生成器的执行有这样几个关键点:</p>
<ol>
<li>调用 gen() 后，程序会阻塞住，不会执行任何语句。</li>
<li>调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。</li>
<li>next 方法返回一个对象， 有两个属性: <code>value</code> 和 <code>done</code>。value 为<code>当前 yield 后面的结果</code>，done 表示<code>是否执行完</code>，遇到了<code>return</code> 后，<code>done</code> 会由<code>false</code>变为<code>true</code>。</li>
</ol>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>当一个生成器要调用另一个生成器时，使用 yield* 就变得十分方便。比如下面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要按照<code>1234</code>的顺序执行，如何来做呢？</p>
<p>在 <code>gen1</code> 中，修改如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* gen2();</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改之后，之后依次调用<code>next</code>即可。</p>
<h3 id="生成器实现机制——协程"><a href="#生成器实现机制——协程" class="headerlink" title="生成器实现机制——协程"></a>生成器实现机制——协程</h3><p>可能你会比较好奇，生成器究竟是如何让函数暂停, 又会如何恢复的呢？接下来我们就来对其中的执行机制——<code>协程</code>一探究竟。</p>
<h4 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h4><p>协程是一种比线程更加轻量级的存在，协程处在线程的环境中，<code>一个线程可以存在多个协程</code>，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。</p>
<h4 id="协程的运作过程"><a href="#协程的运作过程" class="headerlink" title="协程的运作过程"></a>协程的运作过程</h4><p>那你可能要问了，JS 不是单线程执行的吗，开这么多协程难道可以一起执行吗？</p>
<p>答案是：并不能。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将<code>JS 线程的控制权转交给 B协程</code>，那么现在 B 执行，A 就相当于处于暂停的状态。</p>
<p>举个具体的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是A"</span>);</span><br><span class="line">  <span class="keyword">yield</span> B(); <span class="comment">// A停住，在这里转交线程执行权给B</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"结束了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是B"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;<span class="comment">// 返回，并且将线程执行权还给A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = A();</span><br><span class="line">gen.next();</span><br><span class="line">gen.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是A</span></span><br><span class="line"><span class="comment">// 我是B</span></span><br><span class="line"><span class="comment">// 结束了</span></span><br></pre></td></tr></table></figure>

<p>在这个过程中，A 将执行权交给 B，也就是 <code>A 启动 B</code>，我们也称 A 是 B 的<strong>父协程</strong>。因此 B 当中最后<code>return 100</code>其实是将 100 传给了父协程。</p>
<p>需要强调的是，对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程<code>上下文切换</code>的开销，这是<code>高性能</code>的重要原因。</p>
<p>OK, 原理就说到这里。可能你还会有疑问: 这个生成器不就暂停-恢复、暂停-恢复这样执行的吗？它和异步有什么关系？而且，每次执行都要调用next，能不能让它一次性执行完毕呢？下一节我们就来仔细拆解这些问题。</p>
<h2 id="第40篇-如何让-Generator-的异步代码按顺序执行完毕？"><a href="#第40篇-如何让-Generator-的异步代码按顺序执行完毕？" class="headerlink" title="第40篇: 如何让 Generator 的异步代码按顺序执行完毕？"></a>第40篇: 如何让 Generator 的异步代码按顺序执行完毕？</h2><p>这里面其实有两个问题:</p>
<ol>
<li><code>Generator</code> 如何跟<code>异步</code>产生关系？</li>
<li>怎么把 <code>Generator</code> 按顺序执行完毕？</li>
</ol>
<h3 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h3><p>要想知道 <code>Generator</code> 跟异步的关系，首先带大家搞清楚一个概念——thunk函数(即<code>偏函数</code>)，虽然这只是实现两者关系的方式之一。(另一种方式是<code>Promise</code>, 后面会讲到)</p>
<p>举个例子，比如我们现在要判断数据类型。可以写如下的判断逻辑:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object String]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> isFunction = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> isArray = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> isSet = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Set]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以看到，出现了非常多重复的逻辑。我们将它们做一下封装:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们这样做即可:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">let</span> isFunction = isType(<span class="string">'Function'</span>);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>相应的 <code>isString</code>和<code>isFunction</code>是由<code>isType</code>生产出来的函数，但它们依然可以判断出参数是否为String（Function），而且代码简洁了不少。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isString(<span class="string">"123"</span>);</span><br><span class="line">isFunction(<span class="function"><span class="params">val</span> =&gt;</span> val);</span><br></pre></td></tr></table></figure>

<p><strong>isType</strong>这样的函数我们称为<strong>thunk 函数</strong>。它的核心逻辑是接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能。thunk函数的实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作。</p>
<h3 id="Generator-和-异步"><a href="#Generator-和-异步" class="headerlink" title="Generator 和 异步"></a>Generator 和 异步</h3><h4 id="thunk-版本"><a href="#thunk-版本" class="headerlink" title="thunk 版本"></a>thunk 版本</h4><p>以<code>文件操作</code>为例，我们来看看 <strong>异步操作</strong> 如何应用于<code>Generator</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFileThunk = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readFileThunk</code>就是一个<code>thunk函数</code>。异步操作核心的一环就是绑定回调函数，而<code>thunk函数</code>可以帮我们做到。首先传入文件名，然后生成一个针对某个文件的定制化函数。这个函数中传入回调，这个回调就会成为异步操作的回调。这样就让 <code>Generator</code> 和<code>异步</code>关联起来了。</p>
<p>紧接者我们做如下的操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'001.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1.toString())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'002.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们让它执行完:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="comment">// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。</span></span><br><span class="line"><span class="comment">// next返回值中有一个value值，这个value是yield后面的结果，放在这里也就是是thunk函数生成的定制化函数，里面需要传一个回调函数作为参数</span></span><br><span class="line">g.next().value(<span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第二步: 拿到上一次得到的结果，调用next, 将结果作为参数传入，程序继续执行。</span></span><br><span class="line">  <span class="comment">// 同理，value传入回调</span></span><br><span class="line">  g.next(data1).value(<span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">    g.next(data2);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br></pre></td></tr></table></figure>

<p>上面嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可操作性不强，有必要把执行的代码封装一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span>;</span><br><span class="line">    res.value(next);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<p>Ok,再次执行，依然打印正确的结果。代码虽然就这么几行，但包含了递归的过程，好好体会一下。</p>
<p>这是通过<code>thunk</code>完成异步操作的情况。</p>
<h4 id="Promise-版本"><a href="#Promise-版本" class="headerlink" title="Promise 版本"></a>Promise 版本</h4><p>还是拿上面的例子，用<code>Promise</code>来实现就轻松一些:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFilePromise(<span class="string">'001.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1.toString())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFilePromise(<span class="string">'002.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGenPromise</span>(<span class="params">gen, data</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> gen.next(data).value;</span><br><span class="line">&#125;</span><br><span class="line">getGenPromise(g).then(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getGenPromise(g, data1);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getGenPromise(g, data2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br></pre></td></tr></table></figure>

<p>同样，我们可以对执行<code>Generator</code>的代码加以封装:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = g.next();</span><br><span class="line">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span>;</span><br><span class="line">    res.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样能输出正确的结果。代码非常精炼，希望能参照刚刚链式调用的例子，仔细体会一下递归调用的过程。</p>
<h3 id="采用-co-库"><a href="#采用-co-库" class="headerlink" title="采用 co 库"></a>采用 co 库</h3><p>以上我们针对 <code>thunk 函数</code>和<code>Promise</code>两种<code>Generator异步操作</code>的一次性执行完毕做了封装，但实际场景中已经存在成熟的工具包了，如果大名鼎鼎的<strong>co</strong>库, 其实核心原理就是我们已经手写过了（就是刚刚封装的Promise情况下的执行代码），只不过源码会各种边界情况做了处理。使用起来非常简单:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">co(g).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>简单几行代码就完成了<code>Generator</code>所有的操作，真不愧<code>co</code>和<code>Generator</code>天生一对啊！</p>
<h2 id="第41篇-解释一下async-await的运行机制。"><a href="#第41篇-解释一下async-await的运行机制。" class="headerlink" title="第41篇: 解释一下async/await的运行机制。"></a>第41篇: 解释一下async/await的运行机制。</h2><p><code>async/await</code>被称为 JS 中<strong>异步终极解决方案</strong>。它既能够像 co + Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库。接下来，我们从原理的角度来重新审视这个语法糖背后究竟做了些什么。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>什么是 async ?</p>
<blockquote>
<p>MDN 的定义: async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p>
</blockquote>
<p>注意重点: <strong>返回结果为Promise</strong>。</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func());</span><br><span class="line"><span class="comment">// Promise &#123;&lt;resolved&gt;: 100&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就是隐式返回 Promise 的效果。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>我们来看看 <code>await</code>做了些什么事情。</p>
<p>以一段代码为例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">await</span> <span class="number">200</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<p>我们来分析一下这段程序。首先代码同步执行，打印出<code>0</code>，然后将<code>test</code>压入执行栈，打印出<code>100</code>, 下面注意了，遇到了关键角色<strong>await</strong>。</p>
<p>放个慢镜头:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>被 JS 引擎转换成一个 Promise :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">   resolve(<span class="number">100</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里调用了 resolve，resolve的任务进入微任务队列。</p>
<p>然后，JS 引擎将暂停当前协程的运行，把线程的执行权交给<code>父协程</code>(父协程不懂是什么的，上上篇才讲，回去补课)。</p>
<p>回到父协程中，父协程的第一件事情就是对<code>await</code>返回的<code>Promise</code>调用<code>then</code>, 来监听这个 Promise 的状态改变 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 相关逻辑，在resolve 执行之后来调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后往下执行，打印出<code>300</code>。</p>
<p>根据<code>EventLoop</code>机制，当前主线程的宏任务完成，现在检查<code>微任务队列</code>, 发现还有一个Promise的 resolve，执行，现在父协程在<code>then</code>中传入的回调执行。我们来看看这个回调具体做的是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 将线程的执行权交给test协程</span></span><br><span class="line">  <span class="comment">// 2. 把 value 值传递给 test 协程</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Ok, 现在执行权到了<code>test协程</code>手上，test 接收到<code>父协程</code>传来的<strong>200</strong>, 赋值给 a ,然后依次执行后面的语句，打印<code>200</code>、<code>200</code>。</p>
<p>最后的输出为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>总结一下，<code>async/await</code>利用<code>协程</code>和<code>Promise</code>实现了同步方式编写异步代码的效果，其中<code>Generator</code>是对<code>协程</code>的一种实现，虽然语法简单，但引擎在背后做了大量的工作，我们也对这些工作做了一一的拆解。用<code>async/await</code>写出的代码也更加优雅、美观，相比于之前的<code>Promise</code>不断调用then的方式，语义化更加明显，相比于<code>co + Generator</code>性能更高，上手成本也更低，不愧是JS异步终极解决方案！</p>
<h2 id="第42篇-forEach-中用-await-会产生什么问题-怎么解决这个问题？"><a href="#第42篇-forEach-中用-await-会产生什么问题-怎么解决这个问题？" class="headerlink" title="第42篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？"></a>第42篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>问题:<strong>对于异步代码，forEach 并不能保证按顺序执行。</strong></p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">	arr.forEach(<span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> res = <span class="keyword">await</span> handle(item)</span><br><span class="line">		<span class="built_in">console</span>.log(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			resolve(x)</span><br><span class="line">		&#125;, <span class="number">1000</span> * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>我们期望的结果是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<p>但是实际上会输出:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>这是为什么呢？我想我们有必要看看<code>forEach</code>底层怎么实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心逻辑</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = array[i];</span><br><span class="line">    callback(element, i, array);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，forEach 拿过来直接执行了，这就导致它无法保证异步任务的执行顺序。比如后面的任务用时短，那么就又可能抢在前面的任务之前执行。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如何来解决这个问题呢？</p>
<p>其实也很简单, 我们利用<code>for...of</code>就能轻松解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="keyword">const</span> res = <span class="keyword">await</span> handle(item)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决原理——Iterator"><a href="#解决原理——Iterator" class="headerlink" title="解决原理——Iterator"></a>解决原理——Iterator</h3><p>好了，这个问题看起来好像很简单就能搞定，你有想过这么做为什么可以成功吗？</p>
<p>其实，for…of并不像forEach那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——<code>迭代器</code>去遍历。</p>
<p>首先，对于数组来讲，它是一种<code>可迭代数据类型</code>。那什么是<code>可迭代数据类型</code>呢？</p>
<blockquote>
<p>原生具有[Symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如arguments、NodeList）、Set和Map。</p>
</blockquote>
<p>可迭代对象可以通过迭代器进行遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 这就是迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>因此，我们的代码可以这样来组织:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">  <span class="keyword">let</span> res = iterator.next();</span><br><span class="line">  <span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = res.value;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">await</span> handle(value);</span><br><span class="line">    res = iterater.next();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 结束</span></span><br></pre></td></tr></table></figure>

<p>多个任务成功地按顺序执行！其实刚刚的for…of循环代码就是这段代码的语法糖。</p>
<h3 id="重新认识生成器"><a href="#重新认识生成器" class="headerlink" title="重新认识生成器"></a>重新认识生成器</h3><p>回头再看看用iterator遍历[4,2,1]这个数组的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>咦？返回值有<code>value</code>和<code>done</code>属性，生成器也可以调用 next,返回的也是这样的数据结构，这么巧?!</p>
<p>没错，<strong>生成器</strong>本身就是一个<strong>迭代器</strong>。</p>
<p>既然属于迭代器，那它就可以用for…of遍历了吧？</p>
<p>当然没错，不信来写一个简单的斐波那契数列(50以内)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, cur] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(cur);</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    [prev, cur] = [cur, prev + cur];</span><br><span class="line">    <span class="keyword">yield</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; <span class="number">50</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 34</span></span><br></pre></td></tr></table></figure>

<p>是不是非常酷炫？这就是迭代器的魅力：）同时又对<code>生成器</code>有了更深入的理解，没想到我们的老熟人<code>Generator</code>还有这样的身份。</p>
<p>以上便是本文的全部内容，希望对你有所启发。</p>
<h1 id="作者寄语"><a href="#作者寄语" class="headerlink" title="作者寄语"></a>作者寄语</h1><h2 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h2><h3 id="读者灵魂之问"><a href="#读者灵魂之问" class="headerlink" title="读者灵魂之问"></a>读者灵魂之问</h3><p>当你看到这里的时候，可能会吐槽，JS 就这么点内容吗，就这么几篇就讲完了？</p>
<p>首先我要说的是，看完这个系列，我并不能<code>保证你能掌握掉JS的所有内容</code>，我也相信没有哪一个系列会涵盖一门语言所有的知识点，而且学习本来就是一个不断循环和迭代的过程，倘若哪天你觉得自己精通了，全部了如指掌，没有必要继续学了，那才是真正的悲哀。</p>
<p>因此，如果这个系列对你能<code>产生某种启发</code>，弥补你的一部分<code>知识盲区</code>，或者对之前模糊的概念重新理解，从而有了<code>深刻的认识</code>，我觉得这些文章的价值也就真正发挥出来了。</p>
<p>另外就是这个系列还会不断的增添内容，将之前有所疏漏的地方一一补充上来，把这个系列打造得更加完整和系统，也欢迎大家给我提提后续内容方面的需求。</p>
<h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><p>在<code>前端</code>这条路摸爬滚打也有一段时间了，接下来，给大家分享一下我这些年的心得和体会吧。</p>
<p>首先，对前端来讲，不像 Java，C++这些编程领域中科班出身的人那么多，一部分原因是前端领域的知识学校基本不教，另一方面科班毕业的大部分并不想做这一块的工作。</p>
<p>这就导致<code>半路出家</code>的前端er非常多。但是也并不用气馁，我是这么觉得的:</p>
<blockquote>
<p>成为一个真正专业的人，不在于你是不是拿到了科班文凭，甚至不在于你掌握了多少亮眼的技术，而在于你的大脑中是否有<strong>完整的知识体系</strong>。</p>
</blockquote>
<p>这一点非常重要，这份知识体系相当于是你大脑中的操作系统，有了这个系统，用当今比较时髦的词来形容就是有了<code>体系化的思考能力</code>，在应对复杂的问题才会站在更高的高度对各个方面采取综合性的权衡和取舍，或者在应对新技术的时候有足够的自信和能力去快速拿下，让这个系统更加坚固，总之这个系统会在很长一段时间伴随和影响自己，如果不好好建设一下，如蜻蜓点水一般随便学一堆技术栈，或者<code>三天打鱼两天晒网</code>, 没有<strong>持续深入学习</strong>的毅力，结果就是大脑中相当于缺少一个完整的操作系统，其实是挺可悲的一件事情。以前的我总是对各种技术趋之若鹜，恨不得掌握所有的技术栈，因此也总是因为时间不够、效果不好而焦虑。最后的结论就是：从一开始关注点就错了，<strong>关注点不应在于眼花缭乱的技术，而在于自身系统的建设</strong>，这样就并不会为xxx技术我不会而感到焦虑了，相反会为自己点滴的顿悟和进步感到兴奋和满足。</p>
<p>不知道什么时候想通了这件事情，可能是以前踩过太多的坑，另外一个原因也在于本人的危机感是比较强的，才会有一系列的挣扎和思考。</p>
<p>基于以上的<code>信念</code>, 我开始了这份知识体系的建设，进度每天不断地推进，进而也就让大家能够看到眼前的原生JS灵魂之问了。这个系列的由来我应该说清楚了，可能你又要问了，不是每天进度都在推进么？那完成的东西放在哪呢？</p>
<p>OK，这就得具体介绍一下我这份知识体系了，我把它放在了GitHub上，虽然是一个并不起眼的开源项目，但是也将是凝聚我很长一段时间心血的<code>系统建设工程</code>。</p>
<p><a href="https://github.com/sanyuan0704/frontend_daily_question/blob/master/README.md" target="_blank" rel="noopener">点击查看GitHub仓库</a></p>
<p>目前的大纲梳理如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BD%9C%E8%80%85%E5%AF%84%E8%AF%AD.webp" alt></p>
<p>图中用红旗标记了已经完成的部分，即使如此，在之后也会做更多的补充，让知识结构更加完善。</p>
<p>如果这个项目对你有那么一丝启发或者帮助，也请帮忙给项目点一个<code>star</code>, 非常感谢！</p>
<p>参考文献:</p>
<p>《深入浅出nodejs》朴灵著。</p>
<p>极客时间《浏览器工作原理与实践》</p>
<p><a href="https://github.com/wangfupeng1988/js-async-tutorial" target="_blank" rel="noopener">双越《深入理解JavaScript异步》</a></p>
<p><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></p>
<p>《JavaScript高级程序设计(第三版)》</p>
<p><a href="https://yuchengkai.cn/blog/" target="_blank" rel="noopener">《yck个人博客》</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/09/原生JS-灵魂拷问-中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/09/原生JS-灵魂拷问-中/" class="post-title-link" itemprop="url">原生JS-灵魂拷问-中</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-09 22:43:07" itemprop="dateCreated datePublished" datetime="2019-12-09T22:43:07+08:00">2019-12-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-21 19:34:12" itemprop="dateModified" datetime="2019-12-21T19:34:12+08:00">2019-12-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原生JS-灵魂拷问-中"><a href="#原生JS-灵魂拷问-中" class="headerlink" title="原生JS-灵魂拷问-中"></a>原生JS-灵魂拷问-中</h1><h2 id="第七篇-函数的arguments为什么不是数组？如何转化成数组？"><a href="#第七篇-函数的arguments为什么不是数组？如何转化成数组？" class="headerlink" title="第七篇: 函数的arguments为什么不是数组？如何转化成数组？"></a>第七篇: 函数的arguments为什么不是数组？如何转化成数组？</h2><p>因为argument是一个对象，只不过它的属性从0开始排，依次为0，1，2…最后还有callee和length属性。我们也把这样的对象称为类数组。</p>
<p>常见的类数组还有：</p>
<ul>
<li><ul>
<li>用getElementByTagName/ClassName/Name（）获得的HTMLCollection</li>
<li>用querySlector获得的nodeList</li>
</ul>
</li>
</ul>
<p>那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？</p>
<h3 id="1-Array-prototype-slice-call"><a href="#1-Array-prototype-slice-call" class="headerlink" title="1. Array.prototype.slice.call()"></a>1. Array.prototype.slice.call()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>这种方法也可以用来转换Set和Map哦！</p>
<h3 id="3-ES6展开运算符"><a href="#3-ES6展开运算符" class="headerlink" title="3. ES6展开运算符"></a>3. ES6展开运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments]</span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-利用concat-apply"><a href="#4-利用concat-apply" class="headerlink" title="4. 利用concat+apply"></a>4. 利用concat+apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.concat.apply([], <span class="built_in">arguments</span>) <span class="comment">// appaly 方法会把第二个参数展开</span></span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>当然，最原始的方法就是再创建一个数组，用for循环把类数组的每个属性值放在里面，过于简单，就不浪费篇幅了。</p>
<h2 id="第七篇-forEach中return有效果吗？如何中断forEach循环？"><a href="#第七篇-forEach中return有效果吗？如何中断forEach循环？" class="headerlink" title="第七篇: forEach中return有效果吗？如何中断forEach循环？"></a>第七篇: forEach中return有效果吗？如何中断forEach循环？</h2><p>在forEach中用return不会返回，函数会继续执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nums.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 无效</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>中断方法：</p>
<ol>
<li>使用try监视代码块，在需要中断的地方抛出异常。</li>
<li>官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return ture的时候，中止循环</li>
</ol>
<h2 id="第八篇-JS判断数组中是否包含某个值"><a href="#第八篇-JS判断数组中是否包含某个值" class="headerlink" title="第八篇: JS判断数组中是否包含某个值"></a>第八篇: JS判断数组中是否包含某个值</h2><h3 id="方法一：array-indexOf"><a href="#方法一：array-indexOf" class="headerlink" title="方法一：array.indexOf"></a>方法一：array.indexOf</h3><blockquote>
<p>此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> index = arr.indexOf(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二：array-includes-searcElement-fromIndex"><a href="#方法二：array-includes-searcElement-fromIndex" class="headerlink" title="方法二：array.includes(searcElement[,fromIndex])"></a>方法二：array.includes(searcElement[,fromIndex])</h3><p>此方法判断数组中是否存在某个值，如果存在返回true，否则返回false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'存在'</span>)  <span class="comment">//存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'不存在'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：array-find-callback-thisArg"><a href="#方法三：array-find-callback-thisArg" class="headerlink" title="方法三：array.find(callback[,thisArg])"></a>方法三：array.find(callback[,thisArg])</h3><p>返回数组中满足条件的<strong>第一个元素的值</strong>，如果没有，返回undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="方法四：array-findeIndex-callback-thisArg"><a href="#方法四：array-findeIndex-callback-thisArg" class="headerlink" title="方法四：array.findeIndex(callback[,thisArg])"></a>方法四：array.findeIndex(callback[,thisArg])</h3><p>返回数组中满足条件的第一个元素的下标，如果没有找到，返回 <code>-1</code>]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>当然，for循环当然是没有问题的，这里讨论的是数组方法，就不再展开了。</p>
<h2 id="第九篇-JS中flat—数组扁平化"><a href="#第九篇-JS中flat—数组扁平化" class="headerlink" title="第九篇: JS中flat—数组扁平化"></a>第九篇: JS中flat—数组扁平化</h2><p>对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？</p>
<p>需求:多维数组=&gt;一维数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]],<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(arr)</span><br></pre></td></tr></table></figure>

<h3 id="1-调用ES6中的flat方法"><a href="#1-调用ES6中的flat方法" class="headerlink" title="1. 调用ES6中的flat方法"></a>1. 调用ES6中的flat方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-replace-split"><a href="#2-replace-split" class="headerlink" title="2. replace + split"></a>2. replace + split</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-replace-JSON-parse"><a href="#3-replace-JSON-parse" class="headerlink" title="3. replace + JSON.parse"></a>3. replace + JSON.parse</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>)</span><br><span class="line"><span class="keyword">let</span> ary1 = <span class="string">'['</span> + ary + <span class="string">']'</span></span><br><span class="line">res = <span class="built_in">JSON</span>.parse(ary1)</span><br></pre></td></tr></table></figure>

<h3 id="4-普通递归"><a href="#4-普通递归" class="headerlink" title="4. 普通递归"></a>4. 普通递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">ary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = ary[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            fn(item)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(arr)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>

<h3 id="5-利用reduce函数迭代"><a href="#5-利用reduce函数迭代" class="headerlink" title="5. 利用reduce函数迭代"></a>5. 利用reduce函数迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">ary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ary.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure>

<h3 id="6：扩展运算符"><a href="#6：扩展运算符" class="headerlink" title="6：扩展运算符"></a>6：扩展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]],<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(arr.some(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">Array</span>.isArray(_))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="第十篇-JS数组的高阶函数——基础篇"><a href="#第十篇-JS数组的高阶函数——基础篇" class="headerlink" title="第十篇: JS数组的高阶函数——基础篇"></a>第十篇: JS数组的高阶函数——基础篇</h2><h3 id="1-什么是高阶函数"><a href="#1-什么是高阶函数" class="headerlink" title="1.什么是高阶函数"></a>1.什么是高阶函数</h3><p>概念非常简单，如下:</p>
<blockquote>
<p><code>一个函数</code>就可以接收另一个函数作为参数或者返回值为一个函数， <code>这种函数</code>就称之为高阶函数。</p>
</blockquote>
<p>那对应到数组中有哪些方法呢？</p>
<h3 id="2-数组中的高阶函数"><a href="#2-数组中的高阶函数" class="headerlink" title="2.数组中的高阶函数"></a>2.数组中的高阶函数</h3><h4 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h4><ul>
<li><input checked disabled type="checkbox"> 参数:接受两个参数，一个是回调函数，一个是回调函数的this值(可选)。</li>
</ul>
<p>其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。</p>
<ul>
<li><input checked disabled type="checkbox"> 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果</li>
<li><input checked disabled type="checkbox"> 对原来的数组没有影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">val</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newNums = nums.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + index + array[index] + <span class="keyword">this</span>.val</span><br><span class="line">    <span class="comment">// 对第一个元素， 1 + 0 + 1 + 5 = 7</span></span><br><span class="line">    <span class="comment">// 对第二个元素， 2 + 1 + 2 + 5 = 10</span></span><br><span class="line">    <span class="comment">// 对第三个元素， 3 + 2 + 3 + 5 = 13 </span></span><br><span class="line">&#125;, obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums) <span class="comment">// 7, 10, 3</span></span><br></pre></td></tr></table></figure>

<p>当然，后面的参数都是可选的 ，不用的话可以省略。</p>
<h4 id="2-reduce"><a href="#2-reduce" class="headerlink" title="2. reduce"></a>2. reduce</h4><ul>
<li><input checked disabled type="checkbox"> <p>参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中三个默认参数，依次为积累值、当前值、整个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 多个数的加和</span></span><br><span class="line"><span class="keyword">let</span> newNums = nums.reduce(<span class="function">(<span class="params">pre, cur, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums)</span><br></pre></td></tr></table></figure>

<p>不传默认值会怎样？</p>
<p>不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。</p>
</li>
</ul>
<h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter"></a>3. filter</h4><p>参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。</p>
<p>filter方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 保留奇数项</span></span><br><span class="line"><span class="keyword">let</span> oldNums = nums.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oldNums)  <span class="number">1</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="4-sort"><a href="#4-sort" class="headerlink" title="4. sort"></a>4. sort</h4><p>参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 两个比较的元素分别为a, b</span></span><br><span class="line"><span class="keyword">const</span> res = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>

<p>当比较函数返回值大于0，则 a 在 b 的后面，即a的下标应该比b大。</p>
<p>反之，则 a 在 b 的后面，即 a 的下标比 b 小。</p>
<p>整个过程就完成了一次升序的排列。</p>
<p>当然还有一个需要注意的情况，就是比较函数不传的时候，是如何进行排序的？</p>
<blockquote>
<p>答案是将数字转换为字符串，然后根据字母unicode值进行升序排序，也就是根据字符串的比较规则进行升序排序。</p>
</blockquote>
<h2 id="第十一篇-能不能手动实现数组的map方法"><a href="#第十一篇-能不能手动实现数组的map方法" class="headerlink" title="第十一篇: 能不能手动实现数组的map方法 ?"></a>第十一篇: 能不能手动实现数组的map方法 ?</h2><p>依照 <a href="https://tc39.es/ecma262/#sec-array.prototype.map" target="_blank" rel="noopener">ecma262 草案</a>，实现的map的规范如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-map.webp" alt></p>
<p>下面根据草案的规定一步步来模拟实现map函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">callbackFn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot read property 'map' of null or undefined"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 草案中提到要先转换为对象</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> T = thisArg;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="comment">// 还记得原型链那一节提到的 in 吗？in 表示在原型链查找</span></span><br><span class="line">    <span class="comment">// 如果用 hasOwnProperty 是有问题的，它只能找私有属性</span></span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = O[k];</span><br><span class="line">      <span class="comment">// 依次传入this, 当前项，当前索引，整个数组</span></span><br><span class="line">      <span class="keyword">let</span> mappedValue = callbackfn.call(T, KValue, k, O);</span><br><span class="line">      A[k] = mappedValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下, length &gt;&gt;&gt; 0, 字面意思是指”右移 0 位”，但实际上是把前面的空位用0填充，这里的作用是保证len为数字且为整数。</p>
<p>举几个特例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>) &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;;  a &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">[] &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;; a &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="number">123123</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//123123</span></span><br><span class="line"></span><br><span class="line"><span class="number">45.2</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//45</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="number">-0</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="number">-1</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="number">-1212</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//4294966084</span></span><br></pre></td></tr></table></figure>

<p>总体实现起来并没那么难，需要注意的就是使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况。</p>
<p>最后给大家奉上V8源码，参照源码检查一下，其实还是实现得很完整了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayMap</span>(<span class="params">f, receiver</span>) </span>&#123;</span><br><span class="line">  CHECK_OBJECT_COERCIBLE(<span class="keyword">this</span>, <span class="string">"Array.prototype.map"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pull out the length so that modifications to the length in the</span></span><br><span class="line">  <span class="comment">// loop will not affect the looping and side effects are visible.</span></span><br><span class="line">  <span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> length = TO_LENGTH(array.length);</span><br><span class="line">  <span class="keyword">if</span> (!IS_CALLABLE(f)) <span class="keyword">throw</span> %make_type_error(kCalledNonCallable, f);</span><br><span class="line">  <span class="keyword">var</span> result = ArraySpeciesCreate(array, length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">var</span> element = array[i];</span><br><span class="line">      %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L1132" target="_blank" rel="noopener">V8源码</a></p>
<p><a href="https://juejin.im/post/5d76f08ef265da03970be192#comment" target="_blank" rel="noopener">Array 原型方法源码实现大揭秘</a></p>
<p><a href="https://tc39.es/ecma262/#sec-array.prototype.map" target="_blank" rel="noopener">ecma262草案</a></p>
<h2 id="第十二篇-能不能手动实现数组的reduce方法"><a href="#第十二篇-能不能手动实现数组的reduce方法" class="headerlink" title="第十二篇: 能不能手动实现数组的reduce方法 ?"></a>第十二篇: 能不能手动实现数组的reduce方法 ?</h2><p>依照 <a href="https://tc39.es/ecma262/#sec-array.prototype.reduce" target="_blank" rel="noopener">ecma262 草案</a>，实现的reduce的规范如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/reduce.webp" alt></p>
<p>其中有几个核心要点:</p>
<p>1、初始值不传怎么处理</p>
<p>2、回调函数的参数有哪些，返回值如何处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce  = <span class="function"><span class="keyword">function</span>(<span class="params">callbackfn, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异常处理，和 map 一样</span></span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot read property 'reduce' of null or undefined"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue;</span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(; k &lt; len ; k++) &#123;</span><br><span class="line">      <span class="comment">// 查找原型链</span></span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        accumulator = O[k];</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 表示数组全为空</span></span><br><span class="line">  <span class="keyword">if</span>(k === len &amp;&amp; accumulator === <span class="literal">undefined</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Each element of the array is empty'</span>);</span><br><span class="line">  <span class="keyword">for</span>(;k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="comment">// 注意，核心！</span></span><br><span class="line">      accumulator = callbackfn.call(<span class="literal">undefined</span>, accumulator, O[k], k, O);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是从最后一项开始遍历，通过原型链查找跳过空项。</p>
<p>最后给大家奉上V8源码，以供大家检查:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayReduce</span>(<span class="params">callback, current</span>) </span>&#123;</span><br><span class="line">  CHECK_OBJECT_COERCIBLE(<span class="keyword">this</span>, <span class="string">"Array.prototype.reduce"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pull out the length so that modifications to the length in the</span></span><br><span class="line">  <span class="comment">// loop will not affect the looping and side effects are visible.</span></span><br><span class="line">  <span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> length = TO_LENGTH(array.length);</span><br><span class="line">  <span class="keyword">return</span> InnerArrayReduce(callback, current, array, length,</span><br><span class="line">                          <span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InnerArrayReduce</span>(<span class="params">callback, current, array, length, argumentsLength</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!IS_CALLABLE(callback)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %make_type_error(kCalledNonCallable, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  find_initial: <span class="keyword">if</span> (argumentsLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">        current = array[i++];</span><br><span class="line">        <span class="keyword">break</span> find_initial;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> %make_type_error(kReduceNoInitial);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">var</span> element = array[i];</span><br><span class="line">      current = callback(current, element, i, array);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L1132" target="_blank" rel="noopener">V8源码</a></p>
<p><a href="https://tc39.es/ecma262/#sec-array.prototype.map" target="_blank" rel="noopener">ecma262草案</a></p>
<h2 id="第十四篇-能不能实现数组-push、pop-方法"><a href="#第十四篇-能不能实现数组-push、pop-方法" class="headerlink" title="第十四篇: 能不能实现数组 push、pop 方法 ?"></a>第十四篇: 能不能实现数组 push、pop 方法 ?</h2><p>参照 ecma262 草案的规定，关于 push 和 pop 的规范如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-push%E5%92%8Cpop.webp" alt></p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-push%E5%92%8Cpop2.webp" alt></p>
<p>首先来实现一下 push 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">...items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> argCount = items.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 2 ** 53 - 1 为JS能表示的最大正整数</span></span><br><span class="line">  <span class="keyword">if</span> (len + argCount &gt; <span class="number">2</span> ** <span class="number">53</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"The number of array is over the max value restricted!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; argCount; i++) &#123;</span><br><span class="line">    O[len + i] = items[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newLength = len + argCount;</span><br><span class="line">  O.length = newLength;</span><br><span class="line">  <span class="keyword">return</span> newLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>亲测已通过MDN上所有测试用例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">MDN链接</a></p>
<p>然后来实现 pop 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">    O.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  len --;</span><br><span class="line">  <span class="keyword">let</span> value = O[len];</span><br><span class="line">  <span class="keyword">delete</span> O[len];</span><br><span class="line">  O.length = len;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>亲测已通过MDN上所有测试用例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">MDN链接</a></p>
<p>参考链接:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener">V8数组源码</a></p>
<p><a href="https://tc39.es/ecma262" target="_blank" rel="noopener">ecma262规范草案</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">MDN文档</a></p>
<h2 id="第十五篇-能不能实现数组filter方法"><a href="#第十五篇-能不能实现数组filter方法" class="headerlink" title="第十五篇: 能不能实现数组filter方法 ?"></a>第十五篇: 能不能实现数组filter方法 ?</h2><p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-filter.webp" alt></p>
<p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span>(<span class="params">callbackfn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot read property 'filter' of null or undefined"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> resLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = O[i];</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.call(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res[resLen++] = element;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MDN上所有测试用例亲测通过。</p>
<p>参考:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener">V8数组部分源码第1025行</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">MDN中filter文档</a></p>
<h2 id="第十六篇-能不能实现数组splice方法"><a href="#第十六篇-能不能实现数组splice方法" class="headerlink" title="第十六篇: 能不能实现数组splice方法 ?"></a>第十六篇: 能不能实现数组splice方法 ?</h2><p>splice 可以说是最受欢迎的数组方法之一，api 灵活，使用方便。现在来梳理一下用法:</p>
<ul>
<li><ol>
<li>splice(position, count) 表示从 position 索引的位置开始，删除count个元素</li>
</ol>
</li>
<li><ol>
<li>splice(position, 0, ele1, ele2, …) 表示从 position 索引的元素后面插入一系列的元素</li>
</ol>
</li>
<li><ol>
<li>splice(postion, count, ele1, ele2, …) 表示从 position 索引的位置开始，删除 count 个元素，然后再插入一系列的元素</li>
</ol>
</li>
<li><ol>
<li>返回值为<code>被删除元素</code>组成的<code>数组</code>。</li>
</ol>
</li>
</ul>
<p>接下来我们实现这个方法。</p>
<p>参照ecma262草案的规定，详情请<a href="https://tc39.es/ecma262/#sec-array.prototype.splice" target="_blank" rel="noopener">点击</a>。</p>
<p>首先我们梳理一下实现的思路。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-splice.webp" alt></p>
<h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice = <span class="function"><span class="keyword">function</span>(<span class="params">startIndex, deleteCount, ...addElements</span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> argumentsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">let</span> deleteArr = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);</span><br><span class="line">  <span class="comment">// 移动删除元素后面的元素</span></span><br><span class="line">  movePostElements(array, startIndex, len, deleteCount, addElements);</span><br><span class="line">  <span class="comment">// 插入新元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; addElements.length; i++) &#123;</span><br><span class="line">    array[startIndex + i] = addElements[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array.length = len - deleteCount + addElements.length;</span><br><span class="line">  <span class="keyword">return</span> deleteArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先拷贝删除的元素，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceDeleteElements = <span class="function">(<span class="params">array, startIndex, deleteCount, deleteArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = startIndex + i;</span><br><span class="line">    <span class="keyword">if</span> (index <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = array[index];</span><br><span class="line">      deleteArr[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对删除元素后面的元素进行挪动, 挪动分为三种情况:</p>
<ol>
<li>添加的元素和删除的元素个数相等</li>
<li>添加的元素个数小于删除的元素</li>
<li>添加的元素个数大于删除的元素</li>
</ol>
<p>当两者相等时，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (deleteCount === addElements.length) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当添加的元素个数小于删除的元素时, 如图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-splice2.webp" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 如果添加的元素和删除的元素个数不相等，则移动后面的元素</span></span><br><span class="line">  <span class="keyword">if</span>(deleteCount &gt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素多，那么后面的元素整体向前挪动</span></span><br><span class="line">    <span class="comment">// 一共需要挪动 len - startIndex - deleteCount 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex + deleteCount; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i - (deleteCount - addElements.length);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素</span></span><br><span class="line">    <span class="comment">// 目前长度为 len + addElements - deleteCount</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= len + addElements.length - deleteCount; i --) &#123;</span><br><span class="line">      <span class="keyword">delete</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当添加的元素个数大于删除的元素时, 如图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-splice3.webp" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span>(deleteCount &lt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素少，那么后面的元素整体向后挪动</span></span><br><span class="line">    <span class="comment">// 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= startIndex + deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i + (addElements.length - deleteCount);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化一-参数的边界情况"><a href="#优化一-参数的边界情况" class="headerlink" title="优化一: 参数的边界情况"></a>优化一: 参数的边界情况</h3><p>当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computeStartIndex = <span class="function">(<span class="params">startIndex, len</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理索引负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> startIndex + len &gt; <span class="number">0</span> ? startIndex + len: <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> startIndex &gt;= len ? len: startIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeDeleteCount = <span class="function">(<span class="params">startIndex, len, deleteCount, argumentsLen</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除数目没有传，默认删除startIndex及后面所有的</span></span><br><span class="line">  <span class="keyword">if</span> (argumentsLen === <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="comment">// 删除数目过小</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 删除数目过大</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; len - startIndex) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="keyword">return</span> deleteCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice = <span class="function"><span class="keyword">function</span> (<span class="params">startIndex, deleteCount, ...addElements</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//,...</span></span><br><span class="line">  <span class="keyword">let</span> deleteArr = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面参数的清洗工作</span></span><br><span class="line">  startIndex = computeStartIndex(startIndex, len);</span><br><span class="line">  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化二-数组为密封对象或冻结对象"><a href="#优化二-数组为密封对象或冻结对象" class="headerlink" title="优化二: 数组为密封对象或冻结对象"></a>优化二: 数组为密封对象或冻结对象</h3><p>什么是密封对象?</p>
<blockquote>
<p>密封对象是不可扩展的对象，而且已有成员的[[Configurable]]属性被设置为false，这意味着不能添加、删除方法和属性。但是属性值是可以修改的。</p>
</blockquote>
<p>什么是冻结对象？</p>
<blockquote>
<p>冻结对象是最严格的防篡改级别，除了包含密封对象的限制外，还不能修改属性值。</p>
</blockquote>
<p>接下来，我们来把这两种情况一一排除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.isSealed(array) &amp;&amp; deleteCount !== addElements.length) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a sealed object!'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.isFrozen(array) &amp;&amp; (deleteCount &gt; <span class="number">0</span> || addElements.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a frozen object!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在就写了一个比较完整的splice，如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceDeleteElements = <span class="function">(<span class="params">array, startIndex, deleteCount, deleteArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = startIndex + i;</span><br><span class="line">    <span class="keyword">if</span> (index <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = array[index];</span><br><span class="line">      deleteArr[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果添加的元素和删除的元素个数相等，相当于元素的替换，数组长度不变，被删除元素后面的元素不需要挪动</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount === addElements.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 如果添加的元素和删除的元素个数不相等，则移动后面的元素</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(deleteCount &gt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素多，那么后面的元素整体向前挪动</span></span><br><span class="line">    <span class="comment">// 一共需要挪动 len - startIndex - deleteCount 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex + deleteCount; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i - (deleteCount - addElements.length);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素</span></span><br><span class="line">    <span class="comment">// 目前长度为 len + addElements - deleteCount</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= len + addElements.length - deleteCount; i --) &#123;</span><br><span class="line">      <span class="keyword">delete</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(deleteCount &lt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素少，那么后面的元素整体向后挪动</span></span><br><span class="line">    <span class="comment">// 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= startIndex + deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i + (addElements.length - deleteCount);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeStartIndex = <span class="function">(<span class="params">startIndex, len</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理索引负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> startIndex + len &gt; <span class="number">0</span> ? startIndex + len: <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> startIndex &gt;= len ? len: startIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeDeleteCount = <span class="function">(<span class="params">startIndex, len, deleteCount, argumentsLen</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除数目没有传，默认删除startIndex及后面所有的</span></span><br><span class="line">  <span class="keyword">if</span> (argumentsLen === <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="comment">// 删除数目过小</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 删除数目过大</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; len - startIndex) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="keyword">return</span> deleteCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice = <span class="function"><span class="keyword">function</span>(<span class="params">startIndex, deleteCount, ...addElements</span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> argumentsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = array.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> deleteArr = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount);</span><br><span class="line"></span><br><span class="line">  startIndex = computeStartIndex(startIndex, len);</span><br><span class="line">  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.isSealed(array) &amp;&amp; deleteCount !== addElements.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a sealed object!'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.isFrozen(array) &amp;&amp; (deleteCount &gt; <span class="number">0</span> || addElements.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a frozen object!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);</span><br><span class="line">  <span class="comment">// 移动删除元素后面的元素</span></span><br><span class="line">  movePostElements(array, startIndex, len, deleteCount, addElements);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入新元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; addElements.length; i++) &#123;</span><br><span class="line">    array[startIndex + i] = addElements[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  array.length = len - deleteCount + addElements.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> deleteArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对照<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">MDN文档</a>中的所有测试用例亲测通过。</p>
<p>相关测试代码请前往: <a href="https://github.com/sanyuan0704/frontend_daily_question/blob/master/test_splice.js" target="_blank" rel="noopener">传送门</a></p>
<p>最后给大家奉上V8源码，供大家检查： <a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L660" target="_blank" rel="noopener">V8数组 splice 源码第 660 行</a></p>
<h2 id="第十七篇-能不能实现数组sort方法？"><a href="#第十七篇-能不能实现数组sort方法？" class="headerlink" title="第十七篇: 能不能实现数组sort方法？"></a>第十七篇: 能不能实现数组sort方法？</h2><p>估计大家对 JS 数组的sort 方法已经不陌生了，之前也对它的用法做了详细的总结。那，它的内部是如何来实现的呢？如果说我们能够进入它的内部去看一看， 理解背后的设计，会使我们的思维和素养得到不错的提升。</p>
<p>sort 方法在 V8 内部相对与其他方法而言是一个比较高深的算法，对于很多边界情况做了反复的优化，但是这里我们不会直接拿源码来干讲。我们会来根据源码的思路，实现一个 跟引擎性能<strong>一样</strong>的排序算法，并且一步步拆解其中的奥秘。</p>
<h3 id="V8-引擎的思路分析"><a href="#V8-引擎的思路分析" class="headerlink" title="V8 引擎的思路分析"></a>V8 引擎的思路分析</h3><p>首先大概梳理一下源码中排序的思路:</p>
<p>设要排序的元素个数是n：</p>
<p>当 n &lt;= 10 时，采用<code>插入排序</code></p>
<p>当 n &gt; 10 时，采用<code>三路快速排序</code></p>
<ul>
<li>10 &lt; n &lt;= 1000, 采用中位数作为哨兵元素</li>
<li>n &gt; 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数</li>
</ul>
<p>在动手之前，我觉得我们有必要<strong>为什么</strong>这么做搞清楚。</p>
<p>第一、为什么元素个数少的时候要采用插入排序？</p>
<p>虽然<code>插入排序</code>理论上说是O(n^2)的算法，<code>快速排序</code>是一个O(nlogn)级别的算法。但是别忘了，这只是理论上的估算，在实际情况中两者的算法复杂度前面都会有一个系数的， 当 n 足够小的时候，快速排序<code>nlogn</code>的优势会越来越小，倘若插入排序O(n^2)前面的系数足够小，那么就会超过快排。而事实上正是如此，<code>插入排序</code>经过优化以后对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。</p>
<p>因此，对于很小的数据量，应用<code>插入排序</code>是一个非常不错的选择。</p>
<p>第二、为什么要花这么大的力气选择哨兵元素？</p>
<p>因为<code>快速排序</code>的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行partition(一边是小于哨兵的元素，另一边是大于哨兵的元素)时，就会有一边是空的，那么这么排下去，递归的层数就达到了n, 而每一层的复杂度是O(n)，因此快排这时候会退化成O(n^2)级别。</p>
<p>这种情况是要尽力避免的！如果来避免？</p>
<p>就是让哨兵元素进可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的种种优化了。</p>
<p>接下来，我们来一步步实现的这样的官方排序算法。</p>
<h3 id="插入排序及优化"><a href="#插入排序及优化" class="headerlink" title="插入排序及优化"></a>插入排序及优化</h3><p>最初的插入排序可能是这样写的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">  end = end || arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; arr[j]; j --) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">      arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看似可以正确的完成排序，但实际上交换元素会有相当大的性能消耗，我们完全可以用变量覆盖的方式来完成，如图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort1.webp" alt></p>
<p>优化后代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">  end = end || arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> e = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j --)</span><br><span class="line">      arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">    arr[j] = e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来正式进入到 sort 方法。</p>
<h3 id="寻找哨兵元素"><a href="#寻找哨兵元素" class="headerlink" title="寻找哨兵元素"></a>寻找哨兵元素</h3><p>sort的骨架大致如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sort = <span class="function">(<span class="params">comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> length = array.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> InnerArraySort(array, length, comparefn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InnerArraySort = <span class="function">(<span class="params">array, length, comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 比较函数未传入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) !== <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x === y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      x = x.toString();</span><br><span class="line">      y = y.toString();</span><br><span class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> insertSort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> getThirdIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数大于1000时寻找哨兵元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//哨兵位置</span></span><br><span class="line">    <span class="keyword">let</span> thirdIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(to - <span class="keyword">from</span> &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        insertSort(a, <span class="keyword">from</span>, to);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(to - <span class="keyword">from</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        thirdIndex = getThirdIndex(a, <span class="keyword">from</span> , to);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于1000 直接取中点</span></span><br><span class="line">        thirdIndex = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面开始快排</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来把求取哨兵位置的代码实现一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getThirdIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmpArr = [];</span><br><span class="line">  <span class="comment">// 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的</span></span><br><span class="line">  <span class="keyword">let</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">from</span> += <span class="number">1</span>;</span><br><span class="line">  to -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">    tmpArr[j] = [i, a[i]];</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把临时数组排序，取中间的值，确保哨兵的值接近平均位置</span></span><br><span class="line">  tmpArr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> thirdIndex = tmpArr[tmpArr.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> thirdIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成快排"><a href="#完成快排" class="headerlink" title="完成快排"></a>完成快排</h3><p>接下来我们来完成快排的具体代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _sort = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [a, b, c];</span><br><span class="line">  insertSort(arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 上面我们拿到了thirdIndex</span></span><br><span class="line">  <span class="comment">// 现在我们拥有三个元素，from, thirdIndex, to</span></span><br><span class="line">  <span class="comment">// 为了再次确保 thirdIndex 不是最值，把这三个值排序</span></span><br><span class="line">  [a[<span class="keyword">from</span>], a[thirdIndex], a[to - <span class="number">1</span>]] = _sort(a[<span class="keyword">from</span>], a[thirdIndex], a[to - <span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 现在正式把 thirdIndex 作为哨兵</span></span><br><span class="line">  <span class="keyword">let</span> pivot = a[thirdIndex];</span><br><span class="line">  <span class="comment">// 正式进入快排</span></span><br><span class="line">  <span class="keyword">let</span> lowEnd = <span class="keyword">from</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> highStart = to - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 现在正式把 thirdIndex 作为哨兵, 并且lowEnd和thirdIndex交换</span></span><br><span class="line">  <span class="keyword">let</span> pivot = a[thirdIndex];</span><br><span class="line">  a[thirdIndex] = a[lowEnd];</span><br><span class="line">  a[lowEnd] = pivot;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// [lowEnd, i)的元素是和pivot相等的</span></span><br><span class="line">  <span class="comment">// [i, highStart) 的元素是需要处理的</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = lowEnd + <span class="number">1</span>; i &lt; highStart; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> element = a[i];</span><br><span class="line">    <span class="keyword">let</span> order = comparefn(element, pivot);</span><br><span class="line">    <span class="keyword">if</span> (order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      a[i] = a[lowEnd];</span><br><span class="line">      a[lowEnd] = element;</span><br><span class="line">      lowEnd++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(order &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">        highStart--;</span><br><span class="line">        <span class="keyword">if</span>(highStart === i) <span class="keyword">break</span>;</span><br><span class="line">        order = comparefn(a[highStart], pivot);</span><br><span class="line">      &#125;<span class="keyword">while</span>(order &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 现在 a[highStart] &lt;= pivot</span></span><br><span class="line">      <span class="comment">// a[i] &gt; pivot</span></span><br><span class="line">      <span class="comment">// 两者交换</span></span><br><span class="line">      a[i] = a[highStart];</span><br><span class="line">      a[highStart] = element;</span><br><span class="line">      <span class="keyword">if</span>(order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// a[i] 和 a[lowEnd] 交换</span></span><br><span class="line">        element = a[i];</span><br><span class="line">        a[i] = a[lowEnd];</span><br><span class="line">        a[lowEnd] = element;</span><br><span class="line">        lowEnd++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 永远切分大区间</span></span><br><span class="line">  <span class="keyword">if</span> (lowEnd - <span class="keyword">from</span> &gt; to - highStart) &#123;</span><br><span class="line">    <span class="comment">// 继续切分lowEnd ~ from 这个区间</span></span><br><span class="line">    to = lowEnd;</span><br><span class="line">    <span class="comment">// 单独处理小区间</span></span><br><span class="line">    quickSort(a, highStart, to);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(lowEnd - <span class="keyword">from</span> &lt;= to - highStart) &#123;</span><br><span class="line">    <span class="keyword">from</span> = highStart;</span><br><span class="line">    quickSort(a, <span class="keyword">from</span>, lowEnd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试结果如下:</p>
<p>一万条数据:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort2.webp" alt></p>
<p>一百万条数据:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort3.webp" alt></p>
<p>一千万条数据：</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort4.webp" alt></p>
<p>结果仅供大家参考，因为不同的node版本对于部分细节的实现可能不一样，我现在的版本是v10.15。</p>
<p>从结果可以看到，目前版本的 node 对于有序程度较高的数据是处理的不够好的，而我们刚刚实现的排序通过反复确定哨兵的位置就能 有效的规避快排在这一场景下的劣势。</p>
<p>最后给大家完整版的sort代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="function">(<span class="params">arr, comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(arr);</span><br><span class="line">  <span class="keyword">let</span> length = array.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> InnerArraySort(array, length, comparefn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InnerArraySort = <span class="function">(<span class="params">array, length, comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 比较函数未传入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(comparefn) !== <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x === y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      x = x.toString();</span><br><span class="line">      y = y.toString();</span><br><span class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">    end = end || arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> e = arr[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = i; j &gt; start &amp;&amp; comparefn(arr[j - <span class="number">1</span>], e) &gt; <span class="number">0</span>; j--)</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">      arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> getThirdIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmpArr = [];</span><br><span class="line">    <span class="comment">// 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的</span></span><br><span class="line">    <span class="keyword">let</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">from</span> += <span class="number">1</span>;</span><br><span class="line">    to -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">      tmpArr[j] = [i, a[i]];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把临时数组排序，取中间的值，确保哨兵的值接近平均位置</span></span><br><span class="line">    tmpArr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> thirdIndex = tmpArr[tmpArr.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> thirdIndex;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _sort = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    arr.push(a, b, c);</span><br><span class="line">    insertSort(arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//哨兵位置</span></span><br><span class="line">    <span class="keyword">let</span> thirdIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (to - <span class="keyword">from</span> &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        insertSort(a, <span class="keyword">from</span>, to);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (to - <span class="keyword">from</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        thirdIndex = getThirdIndex(a, <span class="keyword">from</span>, to);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于1000 直接取中点</span></span><br><span class="line">        thirdIndex = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> tmpArr = _sort(a[<span class="keyword">from</span>], a[thirdIndex], a[to - <span class="number">1</span>]);</span><br><span class="line">      a[<span class="keyword">from</span>] = tmpArr[<span class="number">0</span>]; a[thirdIndex] = tmpArr[<span class="number">1</span>]; a[to - <span class="number">1</span>] = tmpArr[<span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 现在正式把 thirdIndex 作为哨兵</span></span><br><span class="line">      <span class="keyword">let</span> pivot = a[thirdIndex];</span><br><span class="line">      [a[<span class="keyword">from</span>], a[thirdIndex]] = [a[thirdIndex], a[<span class="keyword">from</span>]];</span><br><span class="line">      <span class="comment">// 正式进入快排</span></span><br><span class="line">      <span class="keyword">let</span> lowEnd = <span class="keyword">from</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> highStart = to - <span class="number">1</span>;</span><br><span class="line">      a[thirdIndex] = a[lowEnd];</span><br><span class="line">      a[lowEnd] = pivot;</span><br><span class="line">      <span class="comment">// [lowEnd, i)的元素是和pivot相等的</span></span><br><span class="line">      <span class="comment">// [i, highStart) 的元素是需要处理的</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = lowEnd + <span class="number">1</span>; i &lt; highStart; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> element = a[i];</span><br><span class="line">        <span class="keyword">let</span> order = comparefn(element, pivot);</span><br><span class="line">        <span class="keyword">if</span> (order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          a[i] = a[lowEnd];</span><br><span class="line">          a[lowEnd] = element;</span><br><span class="line">          lowEnd++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (order &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">do</span>&#123;</span><br><span class="line">            highStart--;</span><br><span class="line">            <span class="keyword">if</span> (highStart === i) <span class="keyword">break</span>;</span><br><span class="line">            order = comparefn(a[highStart], pivot);</span><br><span class="line">          &#125;<span class="keyword">while</span> (order &gt; <span class="number">0</span>) ;</span><br><span class="line">          <span class="comment">// 现在 a[highStart] &lt;= pivot</span></span><br><span class="line">          <span class="comment">// a[i] &gt; pivot</span></span><br><span class="line">          <span class="comment">// 两者交换</span></span><br><span class="line">          a[i] = a[highStart];</span><br><span class="line">          a[highStart] = element;</span><br><span class="line">          <span class="keyword">if</span> (order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a[i] 和 a[lowEnd] 交换</span></span><br><span class="line">            element = a[i];</span><br><span class="line">            a[i] = a[lowEnd];</span><br><span class="line">            a[lowEnd] = element;</span><br><span class="line">            lowEnd++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 永远切分大区间</span></span><br><span class="line">      <span class="keyword">if</span> (lowEnd - <span class="keyword">from</span> &gt; to - highStart) &#123;</span><br><span class="line">        <span class="comment">// 单独处理小区间</span></span><br><span class="line">        quickSort(a, highStart, to);</span><br><span class="line">        <span class="comment">// 继续切分lowEnd ~ from 这个区间</span></span><br><span class="line">        to = lowEnd;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowEnd - <span class="keyword">from</span> &lt;= to - highStart) &#123;</span><br><span class="line">        quickSort(a, <span class="keyword">from</span>, lowEnd);</span><br><span class="line">        <span class="keyword">from</span> = highStart;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(array, <span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#997" target="_blank" rel="noopener">V8 sort源码(点开第997行)</a></p>
<p><a href="https://juejin.im/post/59e80dc6f265da432a7aaf15" target="_blank" rel="noopener">冴羽排序源码专题</a></p>
<h2 id="第十八篇-能不能模拟实现一个new的效果？"><a href="#第十八篇-能不能模拟实现一个new的效果？" class="headerlink" title="第十八篇: 能不能模拟实现一个new的效果？"></a>第十八篇: 能不能模拟实现一个new的效果？</h2><p><code>new</code>被调用后做了三件事情:</p>
<ol>
<li>让实例可以访问到私有属性</li>
<li>让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性</li>
<li>如果构造函数返回的结果不是引用数据类型</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span>(<span class="params">ctor, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'newOperator function the first param must be a function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = ctor.apply(obj, args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; res !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> isFunction = typoof res === <span class="string">'function'</span>;</span><br><span class="line">    <span class="keyword">return</span> isObect || isFunction ? res : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第十九篇-能不能模拟实现一个-bind-的效果？"><a href="#第十九篇-能不能模拟实现一个-bind-的效果？" class="headerlink" title="第十九篇: 能不能模拟实现一个 bind 的效果？"></a>第十九篇: 能不能模拟实现一个 bind 的效果？</h2><p>实现bind之前，我们首先要知道它做了哪些事情。</p>
<ol>
<li>对于普通函数，绑定this指向</li>
<li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存this的值，它代表调用 bind 的函数</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? </span><br><span class="line">            <span class="keyword">this</span> : </span><br><span class="line">            context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fbound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以这么用 Object.create 来处理原型:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? </span><br><span class="line">            <span class="keyword">this</span> : </span><br><span class="line">            context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fbound.prototype = <span class="built_in">Object</span>.create(self.prototype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二十篇-能不能实现一个-call-apply-函数？"><a href="#第二十篇-能不能实现一个-call-apply-函数？" class="headerlink" title="第二十篇: 能不能实现一个 call/apply 函数？"></a>第二十篇: 能不能实现一个 call/apply 函数？</h2><p>引自<code>冴羽</code>大佬的代码，可以说比较完整了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>);</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过我认为换成 ES6 的语法会更精炼一些:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">'fn'</span>);</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，有apply的对应实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二十一篇-谈谈你对JS中this的理解。"><a href="#第二十一篇-谈谈你对JS中this的理解。" class="headerlink" title="第二十一篇: 谈谈你对JS中this的理解。"></a>第二十一篇: 谈谈你对JS中this的理解。</h2><p>其实JS中的this是一个非常简单的东西，只需要理解它的执行规则就OK。</p>
<p>在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。</p>
<p>call/apply/bind可以显示绑定, 这里就不说了。</p>
<p>主要这些场隐式绑定的场景讨论:</p>
<ol>
<li>全局上下文</li>
<li>直接调用函数</li>
<li>对象.方法的形式调用</li>
<li>DOM事件绑定(特殊)</li>
<li>new构造函数绑定</li>
<li>箭头函数</li>
</ol>
<h3 id="1-全局上下文"><a href="#1-全局上下文" class="headerlink" title="1. 全局上下文"></a>1. 全局上下文</h3><p>全局上下文默认this指向window, 严格模式下指向undefined。</p>
<h3 id="2-直接调用函数"><a href="#2-直接调用函数" class="headerlink" title="2. 直接调用函数"></a>2. 直接调用函数</h3><p>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = obj.a</span><br><span class="line">func()  <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<p>这种情况是直接调用。this相当于全局上下文的情况。</p>
<h3 id="3-对象-方法的形式调用"><a href="#3-对象-方法的形式调用" class="headerlink" title="3. 对象.方法的形式调用"></a>3. 对象.方法的形式调用</h3><p>还是刚刚的例子，我如果这样写:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.a() <span class="comment">// 指向obj</span></span><br></pre></td></tr></table></figure>

<p>这就是 <code>对象.方法</code>的情况，this指向这个对象</p>
<h3 id="4-DOM事件绑定"><a href="#4-DOM事件绑定" class="headerlink" title="4. DOM事件绑定"></a>4. DOM事件绑定</h3><p>onclick和addEventerListener中 this 默认指向绑定事件的元素。</p>
<p>IE比较奇异，使用attachEvent，里面的this默认指向window。</p>
<h3 id="5-new-构造函数"><a href="#5-new-构造函数" class="headerlink" title="5. new+构造函数"></a>5. new+构造函数</h3><p>此时构造函数中的this指向实例对象。</p>
<h3 id="6-箭头函数？"><a href="#6-箭头函数？" class="headerlink" title="6. 箭头函数？"></a>6. 箭头函数？</h3><p>箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        func()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.a() <span class="comment">// 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj</span></span><br></pre></td></tr></table></figure>

<p>优先级: new &gt; call、apply、bind &gt; 对象.方法 &gt; 直接调用。</p>
<h2 id="第二十二篇-JS中浅拷贝的手段有哪些？"><a href="#第二十二篇-JS中浅拷贝的手段有哪些？" class="headerlink" title="第二十二篇: JS中浅拷贝的手段有哪些？"></a>第二十二篇: JS中浅拷贝的手段有哪些？</h2><h3 id="重要-什么是拷贝？"><a href="#重要-什么是拷贝？" class="headerlink" title="重要: 什么是拷贝？"></a>重要: 什么是拷贝？</h3><p>首先来直观的感受一下什么是拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>这是直接赋值的情况，不涉及任何拷贝。当改变newArr的时候，由于是同一个引用，arr指向的值也跟着改变。</p>
<p>现在进行浅拷贝:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice()</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！</p>
<p>这就是浅拷贝！</p>
<p>但是这又会带来一个潜在的问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice()</span><br><span class="line">newArr[<span class="number">3</span>].val = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3 &#123;val: 1000&#125;]</span></span><br></pre></td></tr></table></figure>

<p>咦!不是已经不是同一块空间的引用了吗？为什么改变了newArr改变了第二个元素的val值，arr也跟着变了。</p>
<p>这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。现在先让大家有一个基本的概念。</p>
<p>接下来，我们来研究一下JS中实现浅拷贝到底有多少种方式？</p>
<h3 id="1-手动实现"><a href="#1-手动实现" class="headerlink" title="1. 手动实现"></a>1. 手动实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">                cloneTarget[prop] = target[prop]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> newArr = shallowClone(arr)</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1,2,&#123;val: 1000&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2. Object.assign"></a>2. Object.assign</h3><p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'arr'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">'sss'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2) </span><br><span class="line"><span class="comment">//&#123; name: 'sss', age: 18 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-concat浅拷贝数组"><a href="#3-concat浅拷贝数组" class="headerlink" title="3. concat浅拷贝数组"></a>3. concat浅拷贝数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat()</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">2</span>] = <span class="number">30</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-slice浅拷贝"><a href="#4-slice浅拷贝" class="headerlink" title="4. slice浅拷贝"></a>4. slice浅拷贝</h3><p>开头的例子不就说的这个嘛！</p>
<h3 id="5-…展开运算符"><a href="#5-…展开运算符" class="headerlink" title="5. …展开运算符"></a>5. …展开运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr] <span class="comment">// 跟arr.slice() 是一样的效果</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十三篇-能不能写一个完整的深拷贝？"><a href="#第二十三篇-能不能写一个完整的深拷贝？" class="headerlink" title="第二十三篇: 能不能写一个完整的深拷贝？"></a>第二十三篇: 能不能写一个完整的深拷贝？</h2><p>上一篇已经解释了什么是深拷贝，现在我们来一起实现一个完整且专业的深拷贝。</p>
<h3 id="1-简易版及问题"><a href="#1-简易版及问题" class="headerlink" title="1. 简易版及问题"></a>1. 简易版及问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify());</span><br></pre></td></tr></table></figure>

<p>估计这个api能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：</p>
<blockquote>
<p>无法解决<code>循环引用</code>的问题。举个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br></pre></td></tr></table></figure>

<p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况</p>
<blockquote>
<p>无法拷贝一写<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</p>
<p>无法拷贝<code>函数</code>(划重点)。</p>
</blockquote>
<p>因此这个api先pass掉，我们重新写一个深拷贝，简易版如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">          cloneTarget[prop] = deepClone(target[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们以刚刚发现的三个问题为导向，一步步来完善、优化我们的深拷贝代码。</p>
<h3 id="2-解决循环引用"><a href="#2-解决循环引用" class="headerlink" title="2. 解决循环引用"></a>2. 解决循环引用</h3><p>现在问题如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">val</span> : <span class="number">100</span>&#125;;</span><br><span class="line">obj.target = obj;</span><br><span class="line"></span><br><span class="line">deepClone(obj);<span class="comment">//报错: RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<p>这就是循环引用。我们怎么来解决这个问题呢？</p>
<p>创建一个Map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>(</span>)) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span>(map.get(target))  </span><br><span class="line">    <span class="keyword">return</span> target; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (isObject(target)) &#123; </span><br><span class="line">    map.set(target, <span class="literal">true</span>); </span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123; </span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123; </span><br><span class="line">          cloneTarget[prop] = deepClone(target[prop],map); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cloneTarget; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> target; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来试一试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> newA = deepClone(a);</span><br><span class="line"><span class="built_in">console</span>.log(newA)<span class="comment">//&#123; val: 2, target: &#123; val: 2, target: [Circular] &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是map 上的 key 和 map 构成了<code>强引用关系</code>，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了：</p>
<blockquote>
<p>在计算机程序设计中，弱引用与强引用相对， 是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 –百度百科</p>
</blockquote>
<p>说的有一点绕，我用大白话解释一下，被弱引用的对象可以在<code>任何时候被回收</code>，而对于强引用来说，只要这个强引用还在，那么对象<code>无法被回收</code>。拿上面的例子说，map 和 a一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直<code>不会被释放</code>。</p>
<p>怎么解决这个问题？</p>
<p>很简单，让 map 的 key 和 map 构成<code>弱引用</code>即可。ES6给我们提供了这样的数据结构，它的名字叫<code>WeakMap</code>，它是一种特殊的Map, 其中的键是<code>弱引用</code>的。其键必须是对象，而值可以是任意的。</p>
<p>稍微改造一下即可:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-拷贝特殊对象"><a href="#3-拷贝特殊对象" class="headerlink" title="3. 拷贝特殊对象"></a>3. 拷贝特殊对象</h3><h4 id="可继续遍历"><a href="#可继续遍历" class="headerlink" title="可继续遍历"></a>可继续遍历</h4><p>对于特殊的对象，我们使用以下方式来鉴别:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj);</span><br></pre></td></tr></table></figure>

<p>梳理一下对于可遍历对象会有什么结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"object Map"</span>]</span><br><span class="line">[<span class="string">"object Set"</span>]</span><br><span class="line">[<span class="string">"object Array"</span>]</span><br><span class="line">[<span class="string">"object Object"</span>]</span><br><span class="line">[<span class="string">"object Arguments"</span>]</span><br></pre></td></tr></table></figure>

<p>好，以这些不同的字符串为依据，我们就可以成功地鉴别这些对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">'[object Map]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Set]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Arguments]'</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.prototype;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.put(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key), deepClone(item));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      target.add(deepClone(item));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可遍历的对象"><a href="#不可遍历的对象" class="headerlink" title="不可遍历的对象"></a>不可遍历的对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">'[object Function]'</span>;</span><br></pre></td></tr></table></figure>

<p>对于不可遍历的对象，不同的对象有不同的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 待会的重点部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-拷贝函数"><a href="#4-拷贝函数" class="headerlink" title="4. 拷贝函数"></a>4. 拷贝函数</h3><p>虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。</p>
<p>提到函数，在JS种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是 Function的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要 处理普通函数的情况，箭头函数直接返回它本身就好了。</p>
<p>那么如何来区分两者呢？</p>
<p>答案是: 利用原型。箭头函数是不存在原型的。</p>
<p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在，我们的深拷贝就实现地比较完善了。不过在测试的过程中，我也发现了一个小小的bug。</p>
<h3 id="5-小小的bug"><a href="#5-小小的bug" class="headerlink" title="5. 小小的bug"></a>5. 小小的bug</h3><p>如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line"><span class="keyword">new</span> Ctor(target); <span class="comment">// 结果为 Boolean &#123;true&#125; 而不是 false。</span></span><br></pre></td></tr></table></figure>

<p>对于这样一个bug，我们可以对 Boolean 拷贝做最简单的修改， 调用valueOf: new target.constructor(target.valueOf())。</p>
<p>但实际上，这种写法是不推荐的。因为在ES6后不推荐使用【new 基本类型()】这 样的语法，所以es6中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)。</p>
<p>因此我们接下来统一一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-完整代码展示"><a href="#6-完整代码展示" class="headerlink" title="6. 完整代码展示"></a>6. 完整代码展示</h3><p>OK!是时候给大家放出完整版的深拷贝啦:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">'[object Map]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Set]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Arguments]'</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">'[object Map]'</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">'[object Set]'</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">'[object Symbol]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">'[object Function]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span> handleNotTraverse(target, type);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.constructor;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key, map), deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/niuxinyublog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/niuxinyublog/">1</a><span class="page-number current">2</span><a class="page-number" href="/niuxinyublog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/niuxinyublog/page/6/">6</a><a class="extend next" rel="next" href="/niuxinyublog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Niu</p>
  <div class="site-description" itemprop="description">文章</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/niuxinyublog/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Niu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/niuxinyublog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/niuxinyublog/js/utils.js?v=7.4.0"></script><script src="/niuxinyublog/js/motion.js?v=7.4.0"></script>
<script src="/niuxinyublog/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/niuxinyublog/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
