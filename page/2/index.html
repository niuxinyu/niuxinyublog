<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/niuxinyublog/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/niuxinyublog/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/niuxinyublog/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/niuxinyublog/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/niuxinyublog/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/niuxinyublog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/niuxinyublog/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="文章">
<meta property="og:type" content="website">
<meta property="og:title" content="niu的blog">
<meta property="og:url" content="https://niuxinyu.github.io/niuxinyublog/page/2/index.html">
<meta property="og:site_name" content="niu的blog">
<meta property="og:description" content="文章">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="niu的blog">
<meta name="twitter:description" content="文章">
  <link rel="canonical" href="https://niuxinyu.github.io/niuxinyublog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>niu的blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/niuxinyublog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">niu的blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/niuxinyublog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/niuxinyublog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/08/eslint-使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/08/eslint-使用/" class="post-title-link" itemprop="url">eslint 使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-08 19:41:25 / 修改时间：19:55:50" itemprop="dateCreated datePublished" datetime="2020-02-08T19:41:25+08:00">2020-02-08</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装-ESLint"><a href="#安装-ESLint" class="headerlink" title="安装 ESLint"></a>安装 ESLint</h2><p>如果你仅仅想让 ESLint 成为你项目构建系统的一部分，我们可以在项目根目录进行本地安装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure>

<p>如果想使 ESLint 适用于你所有的项目，我们建议使用全局安装，使用全局安装 ESLint 后，你使用的任何 ESLint 插件或可分享的配置也都必须在全局安装。</p>
<p>这里我们使用全局安装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g eslint</span><br></pre></td></tr></table></figure>

<p>安装完毕后，我们使用 <code>eslint --init</code> 命令在用户目录中生成一个配置文件（也可以在任何你喜欢的位置进行生成）</p>
<p>我们在第一个选项中选择自定义代码风格，之后根据需要自行选择。(这里最后一步的询问是否安装依赖可以不安装，因为会导致报错的问题)</p>
<p>设置完成后我们会得到一份文件名为 <code>.eslintrc.js</code> 的配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"commonjs"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"es6"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"eslint:recommended"</span>,</span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"indent"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="number">4</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"linebreak-style"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"windows"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"quotes"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"single"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"semi"</span>: [</span><br><span class="line">            <span class="string">"error"</span>,</span><br><span class="line">            <span class="string">"never"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="配置-ESLint"><a href="#配置-ESLint" class="headerlink" title="配置 ESLint"></a>配置 ESLint</h2><p>配置文件生成之后，我们接着可以进行自定义修改，这里我们只粗略讲解常用的配置项，完整的可配置项可访问<a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>在上文生成的配置文件中可以使用 <code>env</code> 属性来指定要启用的环境，将其设置为 <code>true</code>，以保证在进行代码检测时不会把<a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments" target="_blank" rel="noopener">这些环境</a>预定义的全局变量识别成未定义的变量而报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"commonjs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置语言选项"><a href="#设置语言选项" class="headerlink" title="设置语言选项"></a>设置语言选项</h3><p>默认情况下，ESLint 支持 ECMAScript 5 语法，如果你想启用对 ECMAScript 其它版本和 JSX 等的支持，ESLint 允许你使用 <code>parserOptions</code> 属性进行指定想要支持的 JavaScript <a href="http://eslint.cn/docs/user-guide/configuring#specifying-parser-options" target="_blank" rel="noopener">语言选项</a>，不过你可能需要自行安装 <code>eslint-plugin-react</code> 等插件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"ecmaVersion"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"sourceType"</span>: <span class="string">"module"</span>,</span><br><span class="line">    <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">        <span class="string">"jsx"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p>在上文的配置文件中， <code>&quot;extends&quot;: &quot;eslint:recommended&quot;</code> 选项表示启用推荐规则，在推荐规则的基础上我们还可以根据需要使用 <code>rules</code> 新增自定义规则，每个规则的第一个值都是代表该规则检测后显示的错误级别：</p>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 将规则视为一个警告</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 将规则视为一个错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"indent"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"linebreak-style"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"windows"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"quotes"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"single"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"semi"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"never"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的可配置规则列表可访问：<a href="http://eslint.cn/docs/rules/" target="_blank" rel="noopener">http://eslint.cn/docs/rules/</a></p>
<p>其中带 <code>√</code> 标记的表示该规则为推荐规则。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/02/06/5个提升你js编码水平的实例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/02/06/5个提升你js编码水平的实例/" class="post-title-link" itemprop="url">5个提升你js编码水平的实例</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-06 18:16:50" itemprop="dateCreated datePublished" datetime="2020-02-06T18:16:50+08:00">2020-02-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-08 19:36:04" itemprop="dateModified" datetime="2020-02-08T19:36:04+08:00">2020-02-08</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5个提升你js编码水平的实例"><a href="#5个提升你js编码水平的实例" class="headerlink" title="5个提升你js编码水平的实例"></a>5个提升你js编码水平的实例</h1><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><p>首先来提问一个， <code>typeof</code>是否能正确判断类型？</p>
<p>答案是：不可以，因为由于历史原因，在判断原始类型时，<code>typeof null</code>会等于<code>object</code>。而且对于对象来说，除了函数，都会转换成<code>object</code>。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"1"</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>.alert <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>

<p>再来提问一个，<code>instanceof</code>是否能正确判断类型？</p>
<p>答案是：还是不可以，虽然<code>instanceof</code>是通过原型链来判断的，但是对于对象来说，<code>Array</code>也会被转换成<code>Object</code>，而且也不能区分基本类型<code>string</code>和<code>boolean</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> Func()</span><br><span class="line"><span class="built_in">console</span>.log(func <span class="keyword">instanceof</span> Func) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>)</span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以该怎么办呢？</p>
<p>这时候我们可以使用：<code>Object.prototype.toString.call()</code></p>
<p>所以为什么？</p>
<p>因为每个对象都有一个<code>toString()</code>方法，当要将对象表示为文本值或以预期字符串的方式引用对象时，会自动调用该方法。默认情况下，从<code>Object</code>派生的每个对象都会继承<code>toString()</code>方法。如果此方法未在自定义对象中被覆盖，则<code>toString()</code>返回<code>[Object type]</code>，其中<code>type</code>是对象类型。所以就有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">"1"</span>) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// [object Numer]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p>所以综合上述知识点，我们可以封装出以下通用类型判断方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line">    <span class="keyword">var</span> dataType =</span><br><span class="line">        data <span class="keyword">instanceof</span> Element</span><br><span class="line">            ? <span class="string">"element"</span></span><br><span class="line">            : toString</span><br><span class="line">                .call(data)</span><br><span class="line">                .replace(<span class="regexp">/\[object\s(.+)]/</span>, <span class="string">'$1'</span>)</span><br><span class="line">                .toLowerCase()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type(<span class="string">''</span>)) <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="string">"a"</span>) <span class="comment">// string</span></span><br><span class="line">type(<span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line">type(<span class="built_in">window</span>) <span class="comment">// window</span></span><br><span class="line">type(<span class="built_in">document</span>.querySelector(<span class="string">"h1"</span>)) <span class="comment">// element</span></span><br></pre></td></tr></table></figure>

<h2 id="通用的数组-类数组对象封装"><a href="#通用的数组-类数组对象封装" class="headerlink" title="通用的数组/类数组对象封装"></a>通用的数组/类数组对象封装</h2><p>类数组对象介绍：<a href="https://segmentfault.com/a/1190000000415572" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000415572</a></p>
<p>如果我们使用 ES5/ES6+的数组 API，很容易就能够对数组进行各类的循环操作，但是如果我们要循环一个类数组对象呢？</p>
<p>例如<code>NodeList</code>。直接循环是会报错的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>).map(<span class="function"><span class="params">e</span> =&gt;</span> e) <span class="comment">// Uncaught TypeError: document.querySelectorAll(...).map is not a function</span></span><br></pre></td></tr></table></figure>

<p>当然我们可以用扩展运算符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...document.querySelectorAll(<span class="string">"div"</span>)].map(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br></pre></td></tr></table></figure>

<p>那如果我们不用扩展运算符呢？</p>
<p>那么我们就可以利用<code>call</code>的特性，将<code>NodeList</code>里的元素一个一个的插入到数组中，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listMap = <span class="function"><span class="keyword">function</span>(<span class="params">array, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !fn ? array : <span class="built_in">Array</span>.prototype[type][<span class="string">"call"</span>](array, fn)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>);</span><br><span class="line">listMap(divs, <span class="string">"forEach"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="获取-dom-元素节点的偏移量"><a href="#获取-dom-元素节点的偏移量" class="headerlink" title="获取 dom 元素节点的偏移量"></a>获取 dom 元素节点的偏移量</h2><p>如果有用过<code>jQuery</code>的童鞋，就一定不会忘记<code>$(&#39;&#39;).offset()</code>这个 api 的强大功能，这个 api 可以轻易获取元素的偏移量，那么如果我们不用<code>jQuery</code>该怎么实现呢？</p>
<p>我们先来看看例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getOffset = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> scrollTop =</span><br><span class="line">        el.getBoundingClientRect().top +</span><br><span class="line">        <span class="built_in">document</span>.body.scrollTop +</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">      <span class="keyword">var</span> scrollLeft =</span><br><span class="line">        el.getBoundingClientRect().left +</span><br><span class="line">        <span class="built_in">document</span>.body.scrollLeft +</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">            top: scrollTop,</span><br><span class="line">            left: scrollLeft</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先来看<code>getBoundingClientRect()</code>这个方法。</p>
<p><code>getBoundingClientRect()</code>方法返回元素的大小及其相对于视口的位置。返回值是一个 <code>DOMRect</code> 对象，是与该元素相关的 CSS 边框集合 。</p>
<p>然后就是<code>document.body.scrollTop</code> 跟 <code>document.documentElement.scrollTop</code>这两个是一个功能，只不过在不同的浏览器下会有一个始终为 0，所以做了以上的兼容性处理。所以当我们做拖拽功能的时候，就可以依赖上以上属性。</p>
<p>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">".moveBox"</span>)</span><br><span class="line">getOffset(el) <span class="comment">// &#123;top: xxx, left: xxx&#125;</span></span><br></pre></td></tr></table></figure>

<p>一个摇杆功能的实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle parent"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"circle child"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">		<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">140px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">		<span class="attribute">position</span>: relative;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">45px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">45px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> touchObj = &#123;</span><br><span class="line">		$parent: $(<span class="string">'.parent'</span>),</span><br><span class="line">		$target: $(<span class="string">'.child'</span>),</span><br><span class="line">		startX: <span class="number">0</span>,</span><br><span class="line">		startY: <span class="number">0</span>,</span><br><span class="line">		moveX: <span class="number">0</span>,</span><br><span class="line">		moveY: <span class="number">0</span>,</span><br><span class="line">		endX: <span class="number">0</span>,</span><br><span class="line">		endY: <span class="number">0</span>,</span><br><span class="line">		istouchStart: <span class="literal">false</span>,</span><br><span class="line">		boundary(&#123;</span><br><span class="line">				origin,</span><br><span class="line">				radius</span><br><span class="line">		&#125;) &#123;</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						sin,</span><br><span class="line">						cos,</span><br><span class="line">						atan2</span><br><span class="line">				&#125; = <span class="built_in">Math</span></span><br><span class="line">				<span class="keyword">const</span> angle = atan2(origin.y, origin.x)</span><br><span class="line">				<span class="keyword">const</span> limitX = (cos(angle) + <span class="number">1</span>) * radius</span><br><span class="line">				<span class="keyword">const</span> limitY = (sin(angle) + <span class="number">1</span>) * radius</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">						limitX,</span><br><span class="line">						limitY</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		getPos(ev) &#123;</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						changedTouches,</span><br><span class="line">						touches</span><br><span class="line">				&#125; = ev</span><br><span class="line">				<span class="keyword">let</span> posX</span><br><span class="line">				<span class="keyword">let</span> posY</span><br><span class="line">				<span class="keyword">if</span> (ev.type.indexOf(<span class="string">'mouse'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						posX = ev.pageX</span><br><span class="line">						posY = ev.pageY</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">const</span> touchData = touches.length ? touches : changedTouches</span><br><span class="line">						<span class="keyword">const</span> [&#123;</span><br><span class="line">								pageX,</span><br><span class="line">								pageY</span><br><span class="line">						&#125;] = touchData</span><br><span class="line">						posX = pageX</span><br><span class="line">						posY = pageY</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">						x: posX,</span><br><span class="line">						y: posY</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		start(ev) &#123;</span><br><span class="line">				touchObj.$parent = $(<span class="string">'.parent'</span>)</span><br><span class="line">				touchObj.$target = $(<span class="string">'.child'</span>)</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						target</span><br><span class="line">				&#125; = ev</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (touchObj.$target[<span class="number">0</span>] !== target) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">let</span> &#123;</span><br><span class="line">						getPos</span><br><span class="line">				&#125; = touchObj</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						x,</span><br><span class="line">						y</span><br><span class="line">				&#125; = getPos(ev)</span><br><span class="line"></span><br><span class="line">				touchObj.startX = x</span><br><span class="line">				touchObj.startY = y</span><br><span class="line"></span><br><span class="line">				touchObj.istouchStart = <span class="literal">true</span></span><br><span class="line">		&#125;,</span><br><span class="line">		move(ev) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!touchObj.istouchStart) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">let</span> &#123;</span><br><span class="line">						$parent,</span><br><span class="line">						$target,</span><br><span class="line">						boundary,</span><br><span class="line">						getPos</span><br><span class="line">				&#125; = touchObj</span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						x,</span><br><span class="line">						y</span><br><span class="line">				&#125; = getPos(ev)</span><br><span class="line"></span><br><span class="line">				touchObj.moveX = x</span><br><span class="line">				touchObj.moveY = y</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						top: $parentOffsetTop,</span><br><span class="line">						left: $parentOffsetLeft</span><br><span class="line">				&#125; = $parent.offset()</span><br><span class="line">				<span class="keyword">const</span> $parentWidth = <span class="built_in">parseFloat</span>($parent.css(<span class="string">'width'</span>))</span><br><span class="line">				<span class="keyword">const</span> $parentR = ($parentWidth / <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">const</span> $parentY = ($parentOffsetTop + $parentR)</span><br><span class="line">				<span class="keyword">const</span> $parentX = ($parentOffsetLeft + $parentR)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						top: $targetOffsetTop,</span><br><span class="line">						left: $targetOffsetLeft</span><br><span class="line">				&#125; = $target.offset()</span><br><span class="line">				<span class="keyword">const</span> $targetWidth = <span class="built_in">parseFloat</span>($target.css(<span class="string">'width'</span>))</span><br><span class="line">				<span class="keyword">const</span> $targetR = ($targetWidth / <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">const</span> $targetY = ($targetOffsetTop + $targetR)</span><br><span class="line">				<span class="keyword">const</span> $targetX = ($targetOffsetLeft + $targetR)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> $radius = $parentR - $targetR</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> $SquareR =  $radius ** <span class="number">2</span></span><br><span class="line">				<span class="keyword">const</span> $SquareX = (touchObj.moveX - $parentX) ** <span class="number">2</span></span><br><span class="line">				<span class="keyword">const</span> $SquareY = (touchObj.moveY - $parentY) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> $X = touchObj.moveX - $parentOffsetLeft - $targetR</span><br><span class="line">				<span class="keyword">const</span> $Y = touchObj.moveY - $parentOffsetTop - $targetR</span><br><span class="line"></span><br><span class="line">				<span class="keyword">let</span> $targetLeft = $X</span><br><span class="line">				<span class="keyword">let</span> $targetTop = $Y</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						limitX,</span><br><span class="line">						limitY</span><br><span class="line">				&#125; = boundary(&#123;</span><br><span class="line">						origin: &#123;</span><br><span class="line">								x: $X - $parentR + $targetR,</span><br><span class="line">								y: $Y - $parentR + $targetR</span><br><span class="line">						&#125;,</span><br><span class="line">						radius: $radius</span><br><span class="line">				&#125;)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 圆: 坐标 = (a, b), 半径 = r</span></span><br><span class="line">				<span class="comment">// 点P: 坐标 = (x1, y1)</span></span><br><span class="line">				<span class="comment">// 圆上: (x1 - a) ** 2 + (y - b) ** 2 = r ** 2</span></span><br><span class="line">				<span class="comment">// 圆外: (x1 - a) ** 2 + (y - b) ** 2 &gt; r ** 2</span></span><br><span class="line">				<span class="comment">// 圆内: (x1 - a) ** 2 + (y - b) ** 2 &lt; r ** 2</span></span><br><span class="line">				<span class="keyword">if</span> (($SquareX + $SquareY) &gt; $SquareR) &#123;</span><br><span class="line">						<span class="built_in">console</span>.log(<span class="string">'圆外'</span>)</span><br><span class="line">						$targetLeft = limitX</span><br><span class="line">						$targetTop = limitY</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				$target.css(&#123;</span><br><span class="line">						left: $targetLeft + <span class="string">'px'</span>,</span><br><span class="line">						top: $targetTop + <span class="string">'px'</span></span><br><span class="line">				&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		end(ev) &#123;</span><br><span class="line">				<span class="keyword">let</span> &#123;</span><br><span class="line">						getPos,</span><br><span class="line">						$target</span><br><span class="line">				&#125; = touchObj</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> &#123;</span><br><span class="line">						x,</span><br><span class="line">						y</span><br><span class="line">				&#125; = getPos(ev)</span><br><span class="line"></span><br><span class="line">				touchObj.endX = x</span><br><span class="line">				touchObj.endY = y</span><br><span class="line"></span><br><span class="line">				$target.css(&#123;</span><br><span class="line">						left: <span class="string">'45px'</span>,</span><br><span class="line">						top: <span class="string">'45px'</span></span><br><span class="line">				&#125;)</span><br><span class="line"></span><br><span class="line">				touchObj.istouchStart = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startEvent = <span class="string">'mousedown'</span>, moveEvent = <span class="string">'mousemove'</span>, endEvent = <span class="string">'mouseup'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="string">'ontouchstart'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? (</span><br><span class="line">				startEvent = <span class="string">'touchstart'</span>,</span><br><span class="line">				moveEvent = <span class="string">'touchmove'</span>,</span><br><span class="line">				endEvent = <span class="string">'touchend'</span></span><br><span class="line">		) : <span class="string">''</span></span><br><span class="line">		<span class="built_in">window</span>.addEventListener(startEvent, touchObj.start)</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(moveEvent, touchObj.move)</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(endEvent, touchObj.end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, init)</span><br></pre></td></tr></table></figure>

<h2 id="Fade-特效"><a href="#Fade-特效" class="headerlink" title="Fade 特效"></a>Fade 特效</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fade in</span></span><br><span class="line"><span class="keyword">var</span> fadeIn = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.style.opacity = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">var</span> tick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        el.style.opacity = +el.style.opacity + (<span class="keyword">new</span> <span class="built_in">Date</span>() - last) / <span class="number">400</span></span><br><span class="line">        last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (+el.style.opacity &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            requestAnimationFrame(tick)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tick()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fade out</span></span><br><span class="line"><span class="keyword">var</span> fadeOut = <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.style.opacity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">var</span> tick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        el.style.opacity = +el.style.opacity - (<span class="keyword">new</span> <span class="built_in">Date</span>() - last) / <span class="number">400</span></span><br><span class="line">        last = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (+el.style.opacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            requestAnimationFrame(tick)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是淡入淡出效果的具体实现，这里是利用<code>requestAnimationFrame</code>对<code>opacity</code>通过递归的方式进行修改。</p>
<p>其实这里需要提一个概念，就是<strong>时间分片</strong>。</p>
<p>这是一个非常重要的概念，例如 <strong>React</strong> 的 <strong>Fiber</strong> 核心实现就是<strong>时间分片</strong>。它会将一个长任务切分成一个含有若干小任务的任务队列，然后一个接着一个的执行。</p>
<p><code>requestAnimationFrame</code>就是这样一个 API，它可以根据系统来决定回调函数的执行时机，其实也就是在下一次重绘之前更新动画帧，因为有这样的机制，所以能防止丢帧。</p>
<h2 id="利用队列的概念进行数据操作"><a href="#利用队列的概念进行数据操作" class="headerlink" title="利用队列的概念进行数据操作"></a>利用队列的概念进行数据操作</h2><p>队列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为 rear）进行插入操作，在前端（称为 front）进行删除操作。</p>
<p>虽然很多人觉得了解数据结构对前端作用不大，但是如果我们懂一些基础的概念，是否在编码时能够更加扩散我们的思维呢？我们看下面两个例子：</p>
<h3 id="获取节点在该父节点下的坐标"><a href="#获取节点在该父节点下的坐标" class="headerlink" title="获取节点在该父节点下的坐标"></a>获取节点在该父节点下的坐标</h3><p>如果我们要操作原生 DOM，那么是绕不开获取节点在该父节点的下标的这个功能的，那么我们该如何实现呢？</p>
<p>当然就是利用我们的循环啦，对子元素集合进行遍历，直到确定下标为止，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> index = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> ((el = el.previousElementSibling)) &#123;</span><br><span class="line">        i++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空子节点"><a href="#清空子节点" class="headerlink" title="清空子节点"></a>清空子节点</h3><p>如果我们要清空某个 DOM 节点的子节点，我们有以下的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (el.firstChild) &#123;</span><br><span class="line">            el.removeChild(el.firstChild);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面只是提供一个思路，其实el.innerHTML = ‘’会更简洁。</strong></p>
<h2 id="利用-reduce-进行数据优化"><a href="#利用-reduce-进行数据优化" class="headerlink" title="利用 reduce 进行数据优化"></a>利用 reduce 进行数据优化</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>没错，又是一个老生常谈的问题，数组去重，但是我们这次去除的不仅仅是单个的数据，而是拥有某个相同键值的对象集合。例如下面的例子，我们有以下的数据：</p>
<h2 id="牛逼的-reduce"><a href="#牛逼的-reduce" class="headerlink" title="牛逼的 reduce"></a>牛逼的 reduce</h2><h3 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h3><p>首先我们来看看一个老生常谈的问题，我们假设有这样的一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kris"</span>,</span><br><span class="line">            age: <span class="string">"24"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Andy"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kitty"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Andy"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kitty"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Andy"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            name: <span class="string">"Kitty"</span>,</span><br><span class="line">            age: <span class="string">"25"</span></span><br><span class="line">      &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在我们要去重里面<code>name</code>重复的对象，这时候我们可以利用<code>reduce</code>，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onst dataReducer = <span class="function">(<span class="params">prev, cur, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// let obj = &#123;&#125;</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = cur;</span><br><span class="line">    prev[name] = cur;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    <span class="comment">// 这样利用初始时传进的对象来搜集即可，并且 prev 描述为 total 更容易理解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducedData = data.reduce(dataReducer, &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> newData = <span class="built_in">Object</span>.values(reducedData);</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2020/01/25/JavaScript-中this的指向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2020/01/25/JavaScript-中this的指向/" class="post-title-link" itemprop="url">JavaScript 中this的指向</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-01-25 11:52:53 / 修改时间：12:57:58" itemprop="dateCreated datePublished" datetime="2020-01-25T11:52:53+08:00">2020-01-25</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript-中-this-的指向问题"><a href="#JavaScript-中-this-的指向问题" class="headerlink" title="JavaScript 中 this 的指向问题"></a>JavaScript 中 this 的指向问题</h1><h3 id="场景-1：全局环境下的-this"><a href="#场景-1：全局环境下的-this" class="headerlink" title="场景 1：全局环境下的 this"></a>场景 1：全局环境下的 this</h3><p>这种情况相对简单直接，函数在浏览器全局环境中被简单调用，非严格模式下<code>this</code>指向<code>window</code>; 在<code>use strict</code>指明严格模式的情况下就是<code>undefined</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// window</span></span><br><span class="line">f2() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>对于该问题的变种问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">10</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = foo.fn</span><br><span class="line">fn1() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<p>这里<code>this</code>仍然指向的是<code>window</code>。虽然<code>fn</code>函数在<code>foo</code>对象中作为方法被引用，但是在赋值给<code>fn1</code>之后，<code>fn1</code>的执行仍然是在<code>window</code>的全局环境中。因此输出<code>window</code>和<code>undefined</code>，还是上面这道题目，如果调用改变为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">10</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.fn()</span><br></pre></td></tr></table></figure>

<p>将会输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">bar</span>: <span class="number">10</span>, <span class="attr">fn</span>: ƒ&#125;</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这其实属于第二种情况了，因为这个时候<code>this</code>指向的是最后调用它的对象，在<code>foo.fn()</code>语句中<code>this</code>指向<code>foo</code>对象。请记住：<strong>在执行函数时，如果函数中的this是被上一级的对象所调用，那么this指向的就是上一级的对象；否则指向全局环境。</strong></p>
<h3 id="场景2：上下文对象调用中的-this"><a href="#场景2：上下文对象调用中的-this" class="headerlink" title="场景2：上下文对象调用中的 this"></a>场景2：上下文对象调用中的 this</h3><p>我们直接来看“难”一点的：当存在更复杂的调用关系时，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Lucas'</span>,</span><br><span class="line">    brother: &#123;</span><br><span class="line">        name: <span class="string">'Mike'</span>,</span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.brother.fn())</span><br></pre></td></tr></table></figure>

<p>在这种嵌套的关系中，<code>this</code>指向<strong>最后</strong>调用它的对象，因此输出将会是：<code>Mike</code></p>
<p>下边是更为复杂的嵌套关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    text: <span class="string">'o1'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    text: <span class="string">'o2'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">    text: <span class="string">'o3'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = o1.fn</span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1.fn())</span><br><span class="line"><span class="built_in">console</span>.log(o2.fn())</span><br><span class="line"><span class="built_in">console</span>.log(o3.fn())</span><br></pre></td></tr></table></figure>

<p>答案是：<code>o1</code>、<code>o1</code>、<code>undefined</code></p>
<p>我们来一一分析。</p>
<ul>
<li>第一个 <code>console</code> 最简单，<code>o1</code> 没有问题。难点在第二个和第三个上面，关键还是看调用 <code>this</code> 的那个函数。</li>
<li>第二个 <code>console</code> 的 <code>o2.fn()</code>，最终还是调用 <code>o1.fn()</code>，因此答案仍然是 <code>o1</code>。</li>
<li>最后一个，在进行 <code>var fn = o1.fn</code> 赋值之后，是“裸奔”调用，因此这里的 <code>this</code> 指向 <code>window</code>，答案当然是 <code>undefined</code>。</li>
</ul>
<p>如果是在面试中，我作为面试官，就会追问：如果我们需要让：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(o2.fn())</span><br></pre></td></tr></table></figure>

<p>输出 <code>o2</code>，该怎么做？</p>
<p>一般开发者可能会想到使用<code>bind/call/apply</code>来对<code>this</code>的指向进行干预，这确实是一种思路。但是我接着问，<strong>如果不能使用bind/call/apply，有别的方法吗？</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    text: <span class="string">'o1'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    text: <span class="string">'o2'</span>,</span><br><span class="line">    fn: o1.fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o2.fn())</span><br></pre></td></tr></table></figure>

<p>还是应用那个重要的结论：<code>this</code> 指向<strong>最后</strong>调用它的对象，在 <code>fn</code> 执行时，挂到 <code>o2</code> 对象上即可，我们提前进行了类似赋值的操作。</p>
<h2 id="场景3：bind-call-apply-改变-this-指向"><a href="#场景3：bind-call-apply-改变-this-指向" class="headerlink" title="场景3：bind/call/apply 改变 this 指向"></a>场景3：bind/call/apply 改变 this 指向</h2><p>上文提到 bind/call/apply：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'lucas'</span>,</span><br><span class="line">    logName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">    name: <span class="string">'mike'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.logName.call(bar))</span><br></pre></td></tr></table></figure>

<p>将会输出<code>mike</code>，这不难理解。<strong>但是对 call/apply/bind 的高级考察往往会结合构造函数以及组合式实现继承。实现继承的话题，我们会单独讲到。构造函数的使用案例，我们结合下面的场景进行分析。</strong></p>
<h2 id="场景-4：构造函数和-this"><a href="#场景-4：构造函数和-this" class="headerlink" title="场景 4：构造函数和 this"></a>场景 4：构造函数和 this</h2><p>这方面最直接的例题为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bar = <span class="string">"Lucas"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.bar)</span><br></pre></td></tr></table></figure>

<p>答案将会输出 <code>Lucas</code>。但是这样的场景往往伴随着下一个问题：<code>**new**</code> <strong>操作符调用构造函数，具体做了什么？</strong>以下供参考：</p>
<ul>
<li>创建一个新的对象；</li>
<li>将构造函数的 <code>this</code> 指向这个新对象；</li>
<li>为这个对象添加属性、方法等；</li>
<li>最终返回新对象。</li>
</ul>
<p>以上过程，也可以用代码表述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;</span><br><span class="line">obj.__proto__ = Foo.prototype</span><br><span class="line">Foo.call(obj)</span><br></pre></td></tr></table></figure>

<p>当然，这里对 <code>new</code> 的模拟是一个简单基本版的，更复杂的情况这个问题下我不会赘述。</p>
<p>需要指出的是，如果在构造函数中出现了显式 <code>return</code> 的情况，那么需要注意分为两种场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">"Lucas"</span></span><br><span class="line">    <span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.user)</span><br></pre></td></tr></table></figure>

<p>将会输出 <code>undefined</code>，此时 <code>instance</code> 是返回的空对象 <code>o</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">"Lucas"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(instance.user)</span><br></pre></td></tr></table></figure>

<p>将会输出 <code>Lucas</code>，也就是说此时 <code>instance</code> 是返回的目标对象实例 <code>this</code>。</p>
<p><strong>结论：</strong>如果构造函数中显式返回一个值，且返回的是一个对象，那么 <code>this</code> 就指向这个返回的对象；如果返回的不是一个对象，那么 <code>this</code> 仍然指向实例。</p>
<h2 id="场景-5：箭头函数中的-this-指向"><a href="#场景-5：箭头函数中的-this-指向" class="headerlink" title="场景 5：箭头函数中的 this 指向"></a>场景 5：箭头函数中的 this 指向</h2><p>箭头函数使用<code>this</code>不适用以上标准规则，而是根据外层（函数或者全局）上下文作用域来决定。</p>
<p>来看题目：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;  </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(foo.fn())</span><br></pre></td></tr></table></figure>

<p>这道题中，<code>this</code> 出现在 <code>setTimeout()</code> 中的匿名函数里，因此 <code>this</code> 指向 <code>window</code> 对象。如果需要 <code>this</code> 指向 <code>foo</code> 这个 object 对象，可以巧用箭头函数解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;  </span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(foo.fn())</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;fn: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>单纯箭头函数中的 <code>this</code> 非常简单，<strong>但是综合所有情况，结合</strong> <code>**this**</code> <strong>的优先级考察，这时候</strong> <code>**this**</code> <strong>指向并不好确定。请继续阅读。</strong></p>
<h2 id="终极场景-6：this-优先级相关"><a href="#终极场景-6：this-优先级相关" class="headerlink" title="终极场景 6：this 优先级相关"></a>终极场景 6：this 优先级相关</h2><p>我们常常把通过 <code>call</code>、<code>apply</code>、<code>bind</code>、<code>new</code> 对 <code>this</code> 绑定的情况称为显式绑定；根据调用关系确定的 <code>this</code> 指向称为隐式绑定。</p>
<p><strong>那么显式绑定和隐式绑定谁的优先级更高呢？</strong></p>
<p>请看例题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2)</span><br><span class="line">obj2.foo.call(obj1)</span><br></pre></td></tr></table></figure>

<p>输出分别为 2、1，也就是说 <code>call</code>、<code>apply</code> 的显式绑定一般来说优先级比隐式绑定更高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</span><br><span class="line">bar(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a)</span><br></pre></td></tr></table></figure>

<p>上述代码通过 <code>bind</code>，将 <code>bar</code> 函数中的 <code>this</code> 绑定为 <code>obj1</code> 对象。执行 <code>bar(2)</code> 后，<code>obj1.a</code> 值为 2。即经过 <code>bar(2)</code> 执行后，<code>obj1</code> 对象为：<code>{a: 2}</code>。</p>
<p>当再使用 <code>bar</code> 作为构造函数时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(baz.a)</span><br></pre></td></tr></table></figure>

<p>将会输出 3。我们看 <code>bar</code> 函数本身是通过 <code>bind</code> 方法构造的函数，其内部已经对将 <code>this</code> 绑定为 <code>obj1</code>，它再作为构造函数，通过 <code>new</code> 调用时，返回的实例已经与 <code>obj1</code> 解绑。 也就是说：</p>
<p><strong>new</strong> <strong>绑定修改了</strong> <strong>bind</strong> <strong>绑定中的</strong> <strong>this，因此</strong> <strong>new</strong> <strong>绑定的优先级比显式</strong> <strong>bind</strong> <strong>绑定更高。</strong></p>
<p>我们再看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))</span><br></pre></td></tr></table></figure>

<p>将会输出 2。由于 <code>foo()</code> 的 <code>this</code> 绑定到 <code>obj1</code>，<code>bar</code>（引用箭头函数）的 <code>this</code> 也会绑定到 <code>obj1</code>，箭头函数的绑定无法被修改。</p>
<p>如果将 <code>foo</code> 完全写成箭头函数的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))</span><br></pre></td></tr></table></figure>

<p>将会输出 <code>123</code>。</p>
<p>这里我再“抖个机灵”，仅仅将上述代码的第一处变量 <code>a</code> 的赋值改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(bar.call(obj2))</span><br></pre></td></tr></table></figure>

<p>答案将会输出为 <code>undefined</code>，原因是因为使用 <code>const</code> 声明的变量不会挂载到 <code>window</code> 全局对象当中。因此 <code>this</code> 指向 <code>window</code> 时，自然也找不到 <code>a</code> 变量了。关于 <code>const</code> 或者 <code>let</code> 等声明变量的方式不再本课的主题当中，我们后续也将专门进行介绍。</p>
<p>在ES5中，全局变量直接挂载到全局对象的属性上，所以能在window上看到var声明的变量<br>在ES6中，全局对象的属性和全局变量脱钩，但是为了保持兼容性，旧的不变，所以var、function声明的全局变量依然可以在window对象上看到，而let、const声明的全局变量在window对象上看不到</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/21/从ES6到ES10的新特性万字大总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/21/从ES6到ES10的新特性万字大总结/" class="post-title-link" itemprop="url">从ES6到ES10的新特性万字大总结</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-21 19:41:40 / 修改时间：21:00:56" itemprop="dateCreated datePublished" datetime="2019-12-21T19:41:40+08:00">2019-12-21</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从ES6到ES10的新特性万字大总结"><a href="#从ES6到ES10的新特性万字大总结" class="headerlink" title="从ES6到ES10的新特性万字大总结"></a>从ES6到ES10的新特性万字大总结</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）在标准ECMA-262中定义的脚本语言规范。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p>至发稿日为止有九个ECMA-262版本发表。其历史版本如下：</p>
<ol>
<li>1997年6月：第一版</li>
<li>1998年6月：修改格式，使其与ISO/IEC16262国际标准一样</li>
<li>1999年12月：强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变</li>
<li>2009年12月：添加严格模式(<code>&quot;use strict&quot;</code>)。修改了前面版本模糊不清的概念。增加了getters，setters，JSON以及在对象属性上更完整的反射。</li>
<li>2011年6月：ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。</li>
<li>2015年6月：ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。</li>
<li>2016年6月：ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性。</li>
<li>2017年6月：ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性。</li>
<li>2018年6月：ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。</li>
<li>2019年6月：ECMAScript 2019 （ES2019），第 10 版。</li>
</ol>
<h3 id="发展标准"><a href="#发展标准" class="headerlink" title="发展标准"></a>发展标准</h3><p>TC39（Technical Committee 39）是一个推动JavaScript发展的委员会，它的成语来自各个主流浏览器的代表成语。会议实行多数决，每一项决策只有大部分人同意且没有强烈反对才能去实现。</p>
<p>TC39成员制定着ECMAScript的未来。</p>
<p>每一项新特性最终要进入到ECMAScript规范里，需要经历5个阶段，这5个阶段如下：</p>
<ul>
<li><p><strong>Stage 0</strong>: Strawperson</p>
<p>只要是TC39成员或者贡献者，都可以提交想法</p>
</li>
<li><p><strong>Stage 1</strong>: Proposal</p>
<p>这个阶段确定一个正式的提案</p>
</li>
<li><p><strong>Stage 2</strong>: draft</p>
<p>规范的第一个版本，进入此阶段的提案大概率会成为标准</p>
</li>
<li><p><strong>Stage 3</strong>: Candidate</p>
<p>进一步完善提案细则</p>
</li>
<li><p><strong>Stage 4</strong>: Finished</p>
<p>表示已准备好将其添加到正式的ECMAScript标准中</p>
</li>
</ul>
<p><strong>由于ES6以前的属性诞生年底久远，我们使用也比较普遍，遂不进行说明，ES6之后的语言风格跟ES5以前的差异比较大，所以单独拎出来做个记录。</strong></p>
<h2 id="ES6-ES2015"><a href="#ES6-ES2015" class="headerlink" title="ES6(ES2015)"></a>ES6(ES2015)</h2><blockquote>
<p>ES6是一次重大的革新，比起过去的版本，改动比较大，本文仅对常用的API以及语法糖进行讲解。</p>
</blockquote>
<h3 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h3><p>在ES6以前，<code>JS</code>只有<code>var</code>一种声明方式，但是在ES6之后，就多了<code>let</code>跟<code>const</code>这两种方式。用<code>var</code>定义的变量没有块级作用域的概念，而<code>let</code>跟<code>const</code>则会有，因为这三个关键字创建是不一样的。</p>
<p>区别如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// 10</span></span><br><span class="line">b <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line">c <span class="comment">// c is not defined</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">40</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">50</span></span><br><span class="line">d = <span class="number">60</span></span><br><span class="line">d <span class="comment">// 60</span></span><br><span class="line">e = <span class="number">70</span> <span class="comment">// VM231:1 Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>var</th>
<th>let</th>
<th>const</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>变量提升</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>全局变量</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>重复声明</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>重新赋值</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>暂时死区</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>块作用域</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>只声明不初始化</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><p>在ES6之前，如果我们要生成一个实例对象，传统的方法就是写一个构造函数，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.information = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在ES6之后，我们只需要写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    information() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数（Arrow-function）"><a href="#箭头函数（Arrow-function）" class="headerlink" title="箭头函数（Arrow function）"></a>箭头函数（Arrow function）</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或 <code>new.target</code>。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p>
<p>在ES6以前，我们写函数一般是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> newList = list.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是在ES6里，我们可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> newList = list.map(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br></pre></td></tr></table></figure>

<h3 id="函数参数默认值（Function-parameter-defaults）"><a href="#函数参数默认值（Function-parameter-defaults）" class="headerlink" title="函数参数默认值（Function parameter defaults）"></a>函数参数默认值（Function parameter defaults）</h3><p>在ES6之前，如果我们写函数需要定义初始值的时候，需要这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">config</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = data || <span class="string">'data is empty'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来也没有问题，但是如果参数的布尔值为<strong>falsy</strong>时就会出问题，例如我们这样调用config：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config(<span class="number">0</span>)</span><br><span class="line">config(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>那么结果就永远是后面的值</p>
<p>如果我们用函数参数默认值就没有这个问题，写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="function">(<span class="params">data = <span class="string">'data is empty'</span></span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（Template-string）"><a href="#模板字符串（Template-string）" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h3><p>在ES6之前，如果我们要拼接字符串，则需要像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'kris'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br></pre></td></tr></table></figure>

<p>但是在ES6之后，我们只需要写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'kris'</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, I am <span class="subst">$&#123;age&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<h3 id="解构赋值（Destructuring-assignment）"><a href="#解构赋值（Destructuring-assignment）" class="headerlink" title="解构赋值（Destructuring assignment）"></a>解构赋值（Destructuring assignment）</h3><p>我们通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>
<p>比如我们需要交换两个变量的值，在ES6之前我们可能需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure>

<p>但是在ES6里，我们有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>

<h3 id="模块化（Module）"><a href="#模块化（Module）" class="headerlink" title="模块化（Module）"></a>模块化（Module）</h3><p>在ES6之前，JS并没有模块化的概念，有的也只是社区定制的类似CommonJS和AMD之类的规则。例如基于CommonJS的NodeJS：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是 <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<p>在ES6之后我们则可以写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    area</span><br><span class="line">&#125; = <span class="string">'./circle.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是: <span class="subst">$&#123;area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<h3 id="扩展操作符（Spread-operator）"><a href="#扩展操作符（Spread-operator）" class="headerlink" title="扩展操作符（Spread operator）"></a>扩展操作符（Spread operator）</h3><p>扩展操作符可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p>
<p>比如在ES5的时候，我们要对一个数组的元素进行相加，在不使用<code>reduce</code>或者<code>reduceRight</code>的场合，我们需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> total = sum.apply(<span class="literal">null</span>, list)</span><br></pre></td></tr></table></figure>

<p>但是如果我们使用扩展操作符，只需要如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z</span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> total = sum(...list)</span><br></pre></td></tr></table></figure>

<p>非常的简单，但是要注意的是扩展操作符只能用于可迭代对象</p>
<p>如果是下面的情况，是会报错的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> array = [...obj] <span class="comment">// TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<h3 id="对象属性简写（Object-attribute-shorthand）"><a href="#对象属性简写（Object-attribute-shorthand）" class="headerlink" title="对象属性简写（Object attribute shorthand）"></a>对象属性简写（Object attribute shorthand）</h3><p>在ES6之前，如果我们要将某个变量赋值为同样名称的对象元素，则需要：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="string">'Miaow'</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="string">'Woof'</span></span><br><span class="line"><span class="keyword">var</span> bird = <span class="string">'Peet peet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someObject = &#123;</span><br><span class="line">  cat: cat,</span><br><span class="line">  dog: dog,</span><br><span class="line">  bird: bird</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在ES6里我们就方便很多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'Miaow'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'Woof'</span></span><br><span class="line"><span class="keyword">let</span> bird = <span class="string">'Peet peet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someObject = &#123;</span><br><span class="line">  cat,</span><br><span class="line">  dog,</span><br><span class="line">  bird</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someObject)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  cat: "Miaow",</span></span><br><span class="line"><span class="comment">//  dog: "Woof",</span></span><br><span class="line"><span class="comment">//  bird: "Peet peet"</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 是ES6提供的一种异步解决方案，比回调函数更加清晰明了。</p>
<p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p>
<ol>
<li>等待中（pending）</li>
<li>完成了 （resolved）</li>
<li>拒绝了（rejected）</li>
</ol>
<p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="comment">// 无效</span></span><br><span class="line">  reject(<span class="string">'reject'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finifsh'</span>)</span><br><span class="line"><span class="comment">// new Promise -&gt; finifsh</span></span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code>，并且是一个全新的 <code>Promise</code>，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code>，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>当然了，<code>Promise</code> 也很好地解决了回调地狱的问题，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以改写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url1)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url2)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>

<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p><code>for...of</code>语句在可迭代对象（包括 <code>Array，Map，Set，String，TypedArray，arguments</code> 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> array1) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "c"</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p><strong>symbol</strong> 是一种基本数据类型，<code>Symbol()</code>函数会返回<strong>symbol</strong>类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”<code>new Symbol()</code>“。</p>
<p>每个从<code>Symbol()</code>返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> symbol2 = <span class="built_in">Symbol</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> symbol3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol1); <span class="comment">// "symbol"</span></span><br><span class="line"><span class="built_in">console</span>.log(symbol3.toString()); <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器（Iterator）-生成器（Generator）"><a href="#迭代器（Iterator）-生成器（Generator）" class="headerlink" title="迭代器（Iterator）/ 生成器（Generator）"></a>迭代器（Iterator）/ 生成器（Generator）</h3><p>迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。</p>
<p>一旦创建，迭代器对象可以通过重复调用next()显式地迭代，从而获取该对象每一级的值，直到迭代完，返回<code>{ value: undefined, done: true }</code></p>
<p>虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 生成器函数使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener"><code>function*</code></a>语法编写。 最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。 通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。</p>
<p>可以根据需要多次调用该函数，并且每次都返回一个新的Generator，但每个Generator只能迭代一次。</p>
<p>所以我们可以有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeRangeIterator</span>(<span class="params">start = <span class="number">0</span>, end = Infinity, step = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i += step) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = makeRangeIterator(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">a.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 7, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 9, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-WeakSet"><a href="#Set-WeakSet" class="headerlink" title="Set/WeakSet"></a>Set/WeakSet</h3><p><code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>所以我们可以通过<code>Set</code>实现数组去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(numbers)]) </span><br><span class="line"><span class="comment">// [2, 3, 4, 5, 6, 7, 32]</span></span><br></pre></td></tr></table></figure>

<p><code>WeakSet</code> 结构与 <code>Set</code> 类似，但区别有以下两点：</p>
<ul>
<li><code>WeakSet</code> 对象中只能存放对象引用, 不能存放值, 而 <code>Set</code> 对象都可以。</li>
<li><code>WeakSet</code> 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code>WeakSet</code> 对象是无法被枚举的, 没有办法拿到它包含的所有元素。</li>
</ul>
<p>所以代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">ws.has(foo)    <span class="comment">// false, 对象 foo 并没有被添加进 ws 中 </span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>) <span class="comment">// 从集合中删除 window 对象</span></span><br><span class="line">ws.has(<span class="built_in">window</span>)    <span class="comment">// false, window 对象已经被删除了</span></span><br><span class="line"></span><br><span class="line">ws.clear() <span class="comment">// 清空整个 WeakSet 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-WeakMap"><a href="#Map-WeakMap" class="headerlink" title="Map/WeakMap"></a>Map/WeakMap</h3><p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>例子如下，我们甚至可以使用<code>NaN</code>来作为键值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">"not a number"</span>);</span><br><span class="line"></span><br><span class="line">myMap.get(<span class="literal">NaN</span>); <span class="comment">// "not a number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherNaN = <span class="built_in">Number</span>(<span class="string">"foo"</span>);</span><br><span class="line">myMap.get(otherNaN); <span class="comment">// "not a number"</span></span><br></pre></td></tr></table></figure>

<p><code>WeakMap</code> 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<p>跟<code>Map</code>的区别与<code>Set</code>跟<code>WeakSet</code>的区别相似，具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">    wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;,</span><br><span class="line">    o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    o3 = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">wm1.set(o1, <span class="number">37</span>);</span><br><span class="line">wm1.set(o2, <span class="string">"azerty"</span>);</span><br><span class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象</span></span><br><span class="line">wm2.set(o3, <span class="literal">undefined</span>);</span><br><span class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class="line">wm1.get(o2); <span class="comment">// "azerty"</span></span><br><span class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></span><br><span class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></span><br><span class="line"></span><br><span class="line">wm1.has(o2); <span class="comment">// true</span></span><br><span class="line">wm2.has(o2); <span class="comment">// false</span></span><br><span class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></span><br><span class="line"></span><br><span class="line">wm3.set(o1, <span class="number">37</span>);</span><br><span class="line">wm3.get(o1); <span class="comment">// 37</span></span><br><span class="line">wm3.clear();</span><br><span class="line">wm3.get(o1); <span class="comment">// undefined,wm3已被清空</span></span><br><span class="line">wm1.has(o1);   <span class="comment">// true</span></span><br><span class="line">wm1.delete(o1);</span><br><span class="line">wm1.has(o1);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy/Reflect"></a>Proxy/Reflect</h3><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p>
<p><code>Reflect</code> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 <code>Proxy</code> 的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p>
<p><code>Proxy</code>跟<code>Reflect</code>是非常完美的配合，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observe = <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">            <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">                  callback(key, value);</span><br><span class="line">                  target[key] = value;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy)</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FooBar = &#123; <span class="attr">open</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> FooBarObserver = observe(FooBar, (property, value) =&gt; &#123;</span><br><span class="line">  property === <span class="string">'open'</span> &amp;&amp; value </span><br><span class="line">          ? <span class="built_in">console</span>.log(<span class="string">'FooBar is open!!!'</span>) </span><br><span class="line">          : <span class="built_in">console</span>.log(<span class="string">'keep waiting'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(FooBarObserver.open) <span class="comment">// false</span></span><br><span class="line">FooBarObserver.open = <span class="literal">true</span> <span class="comment">// FooBar is open!!!</span></span><br></pre></td></tr></table></figure>

<p>当然也不是什么都可以被代理的，如果对象带有<code>configurable: false</code> 跟<code>writable: false</code> 属性，则代理失效。</p>
<h3 id="Regex对象的扩展"><a href="#Regex对象的扩展" class="headerlink" title="Regex对象的扩展"></a>Regex对象的扩展</h3><h4 id="正则新增符号"><a href="#正则新增符号" class="headerlink" title="正则新增符号"></a>正则新增符号</h4><ul>
<li><code>i</code> 修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 修饰符</span></span><br><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>y</code>修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y修饰符</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>String.prototype.flags</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看RegExp构造函数的修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>)</span><br><span class="line">regex.flags <span class="comment">// 'i'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>unicode模式</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span></span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>u转义</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u转义</span></span><br><span class="line">/\,/ <span class="comment">// /\,/</span></span><br><span class="line">/\,/u <span class="comment">// 报错 没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串方法的实现改为调用RegExp方法"><a href="#字符串方法的实现改为调用RegExp方法" class="headerlink" title="字符串方法的实现改为调用RegExp方法"></a>字符串方法的实现改为调用<code>RegExp</code>方法</h4><ul>
<li>String.prototype.match<code>调用</code>RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace<code>调用</code>RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search<code>调用</code>RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split<code>调用</code>RegExp.prototype[Symbol.split]</li>
</ul>
<h4 id="正则新增属性"><a href="#正则新增属性" class="headerlink" title="正则新增属性"></a>正则新增属性</h4><ul>
<li><code>RegExp.prototype.sticky</code> 表示是否有<code>y</code>修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hello\d/y.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>RegExp.prototype.flags</code>获取修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/abc/ig.flags <span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>

<h3 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h3><ul>
<li><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><code>八进制表示法</code> : <code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><code>Number.EPSILON</code> : 数值最小精度</li>
<li><code>Number.MIN_SAFE_INTEGER</code> : 最小安全数值(<code>-2^53</code>)</li>
<li><code>Number.MAX_SAFE_INTEGER</code> : 最大安全数值(<code>2^53</code>)</li>
<li><code>Number.parseInt()</code> : 返回转换值的整数部分</li>
<li><code>Number.parseFloat()</code> : 返回转换值的浮点数部分</li>
<li><code>Number.isFinite()</code> : 是否为有限数值</li>
<li><code>Number.isNaN()</code> : 是否为NaN</li>
<li><code>Number.isInteger()</code> : 是否为整数</li>
<li><code>Number.isSafeInteger()</code> : 是否在数值安全范围内</li>
<li><code>Math.trunc()</code> : 返回数值整数部分</li>
<li><code>Math.sign()</code> : 返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li>
<li><code>Math.cbrt()</code> : 返回数值立方根</li>
<li><code>Math.clz32()</code> : 返回数值的32位无符号整数形式</li>
<li><code>Math.imul()</code> : 返回两个数值相乘</li>
<li><code>Math.fround()</code> : 返回数值的32位单精度浮点数形式</li>
<li><code>Math.hypot()</code> : 返回所有数值平方和的平方根</li>
<li><code>Math.expm1()</code> : 返回<code>e^n - 1</code></li>
<li><code>Math.log1p()</code> : 返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><code>Math.log10()</code> : 返回以10为底的n的对数</li>
<li><code>Math.log2()</code> : 返回以2为底的n的对数</li>
<li><code>Math.sinh()</code> : 返回n的双曲正弦</li>
<li><code>Math.cosh()</code> : 返回n的双曲余弦</li>
<li><code>Math.tanh()</code> : 返回n的双曲正切</li>
<li><code>Math.asinh()</code> : 返回n的反双曲正弦</li>
<li><code>Math.acosh()</code> : 返回n的反双曲余弦</li>
<li><code>Math.atanh()</code> : 返回n的反双曲正切</li>
</ul>
<h3 id="Array对象的扩展"><a href="#Array对象的扩展" class="headerlink" title="Array对象的扩展"></a>Array对象的扩展</h3><ul>
<li><code>Array.prototype.from</code>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">'foo'</span>)) <span class="comment">// ["f", "o", "o"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x)) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.of()</code>：转换一组值为真正数组，返回新数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>)       <span class="comment">// [7] </span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>)          <span class="comment">// [empty, empty, empty, empty, empty, empty]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.copyWithin()</code>：把指定位置的成员复制到其他位置，返回原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// ["d", "b", "c", "d", "e"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">1</span>, <span class="number">3</span>)) <span class="comment">// ["d", "d", "e", "d", "e"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.find()</code>：返回第一个符合条件的成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.findIndex()</code>：返回第一个符合条件的成员索引值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isLargeNumber = <span class="function">(<span class="params">element</span>) =&gt;</span> element &gt; <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.findIndex(isLargeNumber)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.fill()</code>：根据指定值填充整个数组，返回原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>)) <span class="comment">// [1, 2, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">5</span>, <span class="number">1</span>)) <span class="comment">// [1, 5, 5, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">6</span>)) <span class="comment">// [6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.keys()</code>：返回以索引值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.values()</code>：返回以属性值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.values()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.prototype.entries()</code>：返回以索引值和属性值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.entries()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [1, "b"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>数组空位</code>：ES6明确将数组空位转为<code>undefined</code>或者<code>empty</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>]) <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]] <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">//  [empty × 3]</span></span><br><span class="line">[,<span class="string">'a'</span>] <span class="comment">// [empty, "a"]</span></span><br></pre></td></tr></table></figure>

<h2 id="ES7-ES2016"><a href="#ES7-ES2016" class="headerlink" title="ES7(ES2016)"></a>ES7(ES2016)</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h3><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array1.includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pets = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'cat'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'at'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符**"></a>幂运算符**</h3><p>幂运算符**，具有与Math.pow()一样的功能，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>) <span class="comment">// 1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)) <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（Template-string）-1"><a href="#模板字符串（Template-string）-1" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h3><p>自ES7起，带标签的模版字面量遵守以下转义序列的规则：</p>
<ul>
<li>Unicode字符以”\u”开头，例如<code>\u00A9</code></li>
<li>Unicode码位用”\u{}”表示，例如<code>\u{2F804}</code></li>
<li>十六进制以”\x”开头，例如<code>\xA9</code></li>
<li>八进制以””和数字开头，例如<code>\251</code></li>
</ul>
<p>这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">latex<span class="string">`\unicode`</span></span><br><span class="line"><span class="comment">// 在较老的ECMAScript版本中报错（ES2016及更早）</span></span><br><span class="line"><span class="comment">// SyntaxError: malformed Unicode character escape sequence</span></span><br></pre></td></tr></table></figure>

<h2 id="ES8-ES2017"><a href="#ES8-ES2017" class="headerlink" title="ES8(ES2017)"></a>ES8(ES2017)</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>虽然<code>Promise</code>可以解决回调地狱的问题，但是链式调用太多，则会变成另一种形式的回调地狱 —— 面条地狱，所以在ES8里则出现了<code>Promise</code>的语法糖<code>async/await</code>，专门解决这个问题。</p>
<p>我们先看一下下面的<code>Promise</code>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">    .then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob)</span><br><span class="line">          <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">          image.src = objectURL</span><br><span class="line">          <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'There has been a problem with your fetch operation: '</span> + e.message)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>然后再看看<code>async/await</code>版的，这样看起来是不是更清晰了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">      <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob)</span><br><span class="line">      <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      image.src = objectURL</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br></pre></td></tr></table></figure>

<p>当然，如果你喜欢，你甚至可以两者混用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> response.blob()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> objectURL = URL.createObjectURL(blob)</span><br><span class="line">      <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      image.src = objectURL</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">      a: <span class="string">'somestring'</span>,</span><br><span class="line">      b: <span class="number">42</span>,</span><br><span class="line">      c: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(object1)) <span class="comment">// ["somestring", 42, false]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">      a: <span class="string">'somestring'</span>,</span><br><span class="line">      b: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "a: somestring"</span></span><br><span class="line"><span class="comment">// "b: 42"</span></span><br></pre></td></tr></table></figure>

<h3 id="padStart"><a href="#padStart" class="headerlink" title="padStart()"></a>padStart()</h3><p><code>padStart()</code> 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'5'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.padStart(<span class="number">2</span>, <span class="string">'0'</span>)) <span class="comment">// "05"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullNumber = <span class="string">'2034399002125581'</span></span><br><span class="line"><span class="keyword">const</span> last4Digits = fullNumber.slice(<span class="number">-4</span>)</span><br><span class="line"><span class="keyword">const</span> maskedNumber = last4Digits.padStart(fullNumber.length, <span class="string">'*'</span>) </span><br><span class="line"><span class="built_in">console</span>.log(maskedNumber) <span class="comment">// "************5581"</span></span><br></pre></td></tr></table></figure>

<h3 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h3><p><code>padEnd()</code> 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'Breaded Mushrooms'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.padEnd(<span class="number">25</span>, <span class="string">'.'</span>)) <span class="comment">// "Breaded Mushrooms........"</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'200'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.padEnd(<span class="number">5</span>)) <span class="comment">// "200  "</span></span><br></pre></td></tr></table></figure>

<p>###函数参数结尾逗号（Function parameter lists and calls trailing commas）</p>
<p>在ES5里就添加了对象的尾逗号，不过并不支持函数参数，但是在ES8之后，便开始支持这一特性，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p,</span>) </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">(p) =&gt; &#123;&#125;</span><br><span class="line">(p,) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">f(p)</span><br><span class="line">f(p,)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>,)</span><br></pre></td></tr></table></figure>

<p>但是以下的方式是不合法的：</p>
<p>仅仅包含逗号的函数参数定义或者函数调用会抛出 SyntaxError。 而且，当使用剩余参数的时候，并不支持尾后逗号，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">,</span>) </span>&#123;&#125; <span class="comment">// SyntaxError: missing formal parameter</span></span><br><span class="line">(,) =&gt; &#123;&#125;       <span class="comment">// SyntaxError: expected expression, got ','</span></span><br><span class="line">f(,)             <span class="comment">// SyntaxError: expected expression, got ','</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...p,</span>) </span>&#123;&#125; <span class="comment">// SyntaxError: parameter after rest parameter</span></span><br><span class="line">(...p,) =&gt; &#123;&#125;        <span class="comment">// SyntaxError: expected closing parenthesis, got ','</span></span><br></pre></td></tr></table></figure>

<p>在解构里也可以使用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有尾后逗号的数组解构</span></span><br><span class="line">[a, b,] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有尾后逗号的对象解构</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  p: <span class="number">42</span>, </span><br><span class="line">  q: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;p, q,&#125; = o</span><br></pre></td></tr></table></figure>

<p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...b,] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// SyntaxError: rest element may not have a trailing comma</span></span><br></pre></td></tr></table></figure>

<h3 id="ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）"><a href="#ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）" class="headerlink" title="ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）"></a>ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sab = <span class="keyword">new</span> SharedArrayBuffer(<span class="number">1024</span>) <span class="comment">// 必须实例化</span></span><br><span class="line">worker.postMessage(sab)</span><br></pre></td></tr></table></figure>

<h3 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a>Atomics对象</h3><p><strong>Atomics对象</strong>  提供了一组静态方法用来对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener"><code>SharedArrayBuffer</code></a> 对象进行原子操作。</p>
<p>方法如下：</p>
<ul>
<li><strong>Atomics.add()</strong> ：将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</li>
<li><strong>Atomics.and()</strong>：将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</li>
<li><strong>Atomics.compareExchange()</strong>：如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</li>
<li><strong>Atomics.exchange()</strong>：将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</li>
<li><strong>Atomics.load()</strong>：返回数组中指定元素的值。</li>
<li><strong>Atomics.or()</strong>：将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</li>
<li><strong>Atomics.store()</strong>：将数组中指定的元素设置为给定的值，并返回该值。</li>
<li><strong>Atomics.sub()</strong>：将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</li>
<li><strong>Atomics.xor()</strong>：将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</li>
<li><strong>Atomics.wait()</strong>：检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</li>
<li><strong>Atomics.wake()</strong>：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</li>
<li><strong>Atomics.isLockFree(size)</strong>：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</li>
</ul>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  property1: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptors1 = <span class="built_in">Object</span>.getOwnPropertyDescriptors(object1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors1.property1.writable) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors1.property1.value) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝一个对象</span></span><br><span class="line"><span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj), </span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">superclass.prototype = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">subclass.prototype = <span class="built_in">Object</span>.create(superclass.prototype, <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h2 id="ES9-ES2018"><a href="#ES9-ES2018" class="headerlink" title="ES9(ES2018)"></a>ES9(ES2018)</h2><h3 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h3><p><code>for await...of</code> 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 <code>String</code>，<code>Array</code>，<code>Array-like</code> 对象（比如<code>arguments</code> 或者<code>NodeList</code>)，<code>TypedArray</code>，<code>Map</code>， <code>Set</code>和自定义的异步或者同步可迭代对象。其会调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p>配合迭代异步生成器，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> i++</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="keyword">await</span> (num <span class="keyword">of</span> asyncGenerator()) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(num)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（Template-string）-2"><a href="#模板字符串（Template-string）-2" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h3><p>ES9开始，模板字符串允许嵌套支持常见转义序列，移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。</p>
<p>不过，非法转义序列在”cooked”当中仍然会体现出来。它们将以<code>undefined</code>元素的形式存在于”cooked”之中，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="string">"cooked"</span>: str[<span class="number">0</span>], <span class="string">"raw"</span>: str.raw[<span class="number">0</span>] &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">latex<span class="string">`\unicode`</span> <span class="comment">// &#123; cooked: undefined, raw: "\\unicode" &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式反向-lookbehind-断言"><a href="#正则表达式反向-lookbehind-断言" class="headerlink" title="正则表达式反向(lookbehind)断言"></a>正则表达式反向(lookbehind)断言</h3><p>首先我们得先知道什么是<strong>断言(Assertion)</strong>。</p>
<p><strong>断言(Assertion)</strong>是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符，所以断言也被称为“非消耗性匹配”或“非获取匹配”。</p>
<p>正则表达式的断言一共有 4 种形式：</p>
<ul>
<li><code>(?=pattern)</code> 零宽正向肯定断言(zero-width positive lookahead assertion)</li>
<li><code>(?!pattern)</code> 零宽正向否定断言(zero-width negative lookahead assertion)</li>
<li><code>(?&lt;=pattern)</code> 零宽反向肯定断言(zero-width positive lookbehind assertion)</li>
<li><code>(?&lt;!pattern)</code> 零宽反向否定断言(zero-width negative lookbehind assertion)</li>
</ul>
<p>在ES9之前，JavaScript 正则表达式，只支持正向断言。正向断言的意思是：当前位置后面的字符串应该满足断言，但是并不捕获。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'fishHeadfishTail'</span>.match(<span class="regexp">/fish(?=Head)/g</span>) <span class="comment">// ["fish"]</span></span><br></pre></td></tr></table></figure>

<p>反向断言和正向断言的行为一样，只是方向相反。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc123'</span>.match(<span class="regexp">/(?&lt;=(\d+)(\d+))$/</span>) <span class="comment">//  ["", "1", "23", index: 6, input: "abc123", groups: undefined]</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>正则表达式中的Unicode转义符允许根据Unicode字符属性匹配Unicode字符。 它允许区分字符类型，例如大写和小写字母，数学符号和标点符号。</p>
<p>部分例子代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>具体的属性列表可查看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noopener">developer.mozilla.org/en-US/docs/…</a></p>
<h3 id="正则表达式-s-dotAll-模式"><a href="#正则表达式-s-dotAll-模式" class="headerlink" title="正则表达式 s/dotAll 模式"></a>正则表达式 s/dotAll 模式</h3><p>在以往的版本里，JS的正则的<code>.</code>只能匹配emoji跟行终结符以外的所有文本，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/./</span>;</span><br><span class="line"></span><br><span class="line">regex.test(<span class="string">'\n'</span>);       <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\r'</span>);       <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;2028&#125;'</span>); <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;2029&#125;'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">regex.test(<span class="string">'\v'</span>);       <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'\f'</span>);       <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;0085&#125;'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>);     <span class="comment">// false</span></span><br><span class="line">/foo[^]bar/.test(<span class="string">'foo\nbar'</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>);     <span class="comment">// false</span></span><br><span class="line">/foo[\s]bar/.test(<span class="string">'foo\nbar'</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是在ES9之后，JS正则增加了一个新的标志 <code>s</code> 用来表示 dotAll，这可以匹配任意字符。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;  <span class="comment">//  等价于 const re = new RegExp('foo.bar', 's');</span></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>);    <span class="comment">// true</span></span><br><span class="line">re.dotAll;      <span class="comment">// true</span></span><br><span class="line">re.flags;       <span class="comment">// "s"</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><p>在以往的版本里，JS的正则分组是无法命名的，所以容易混淆。例如下面获取年月日的例子，很容易让人搞不清哪个是月份，哪个是年份:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matched = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>.exec(<span class="string">'2019-01-01'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">0</span>]);    <span class="comment">// 2019-01-01</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">1</span>]);    <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">2</span>]);    <span class="comment">// 01</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">3</span>]);    <span class="comment">// 01</span></span><br></pre></td></tr></table></figure>

<p>ES9引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对象扩展操作符"><a href="#对象扩展操作符" class="headerlink" title="对象扩展操作符"></a>对象扩展操作符</h3><p>ES6中添加了数组的扩展操作符，让我们在操作数组时更加简便，美中不足的是并不支持对象扩展操作符，但是在ES9开始，这一功能也得到了支持，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面便是一个简便的浅拷贝。这里有一点小提示，就是<code>Object.assign()</code> 函数会触发 <code>setters</code>，而展开语法则不会。所以不能替换也不能模拟<code>Object.assign()</code> 。</p>
<p>如果存在相同的属性名，只有最后一个会生效。</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code>方法会返回一个<code>Promise</code>，当promise的状态变更，不管是变成<code>rejected</code>或者<code>fulfilled</code>，最终都会执行<code>finally()</code>的回调。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">      &#125;)</span><br><span class="line">      .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ES10-ES2019"><a href="#ES10-ES2019" class="headerlink" title="ES10(ES2019)"></a>ES10(ES2019)</h2><h3 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat() / flatMap()"></a>Array.prototype.flat() / flatMap()</h3><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p><code>flatMap()</code>与 <code>map()</code> 方法和深度为1的 <code>flat()</code> 几乎相同.，不过它会首先使用映射函数映射每个元素，然后将结果压缩成一个新数组，这样效率会更高。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度为1</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]) <span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>可以代替<code>reduce()</code> 与 <code>concat()</code>，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>]) <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc.concat([x, x * <span class="number">2</span>]), []) <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>

<p>但这是非常低效的，在每次迭代中，它创建一个必须被垃圾收集的新临时数组，并且它将元素从当前的累加器数组复制到一个新的数组中，而不是将新的元素添加到现有的数组中。</p>
<h3 id="String-prototype-trimStart-trimLeft-trimEnd-trimRight"><a href="#String-prototype-trimStart-trimLeft-trimEnd-trimRight" class="headerlink" title="String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()"></a>String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()</h3><p>在ES5中，我们可以通过<code>trim()</code>来去掉字符首尾的空格，但是却无法只去掉单边的，但是在ES10之后，我们可以实现这个功能。</p>
<p>如果我们要去掉开头的空格，可以使用<code>trimStart()</code>或者它的别名<code>trimLeft()</code>，</p>
<p>同样的，如果我们要去掉结尾的空格，我们可以使用<code>trimEnd()</code>或者它的别名<code>trimRight()</code>。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Str = <span class="string">'   Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str) <span class="comment">// '   Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimStart()) <span class="comment">// 'Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimLeft()) <span class="comment">// 'Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimEnd()) <span class="comment">// '   Hello world!'</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimRight()) <span class="comment">// '   Hello world!'</span></span><br></pre></td></tr></table></figure>

<p>不过这里有一点要注意的是，<code>trimStart()</code>跟<code>trimEnd()</code>才是标准方法，<code>trimLeft()</code>跟<code>trimRight()</code>只是别名。</p>
<p>在某些引擎里（例如Chrome），有以下的等式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trimLeft.name === <span class="string">"trimStart"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.trimRight.name === <span class="string">"trimEnd"</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.fromEntries()</code> 方法把键值对列表转换为一个对象，它是<code>Object.entries()</code>的反函数。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// Object &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p><code>description</code> 是一个只读属性，它会返回<code>Symbol</code>对象的可选描述的字符串。与 <code>Symbol.prototype.toString()</code> 不同的是它不会包含<code>Symbol()</code>的字符串。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'desc'</span>).toString();   <span class="comment">// "Symbol(desc)"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'desc'</span>).description;  <span class="comment">// "desc"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">''</span>).description;      <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">Symbol</span>().description;        <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名 symbols</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator.toString();  <span class="comment">// "Symbol(Symbol.iterator)"</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator.description; <span class="comment">// "Symbol.iterator"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局 symbols</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>).toString();  <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>).description; <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'test1test2'</span></span><br><span class="line"></span><br><span class="line">str.match(regexp) <span class="comment">// ['test1', 'test2']</span></span><br><span class="line">str.matchAll(regexp) <span class="comment">// RegExpStringIterator &#123;&#125;</span></span><br><span class="line">[...str.matchAll(regexp)] <span class="comment">// [['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4], ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4]]</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-prototype-toString-返回注释与空格"><a href="#Function-prototype-toString-返回注释与空格" class="headerlink" title="Function.prototype.toString() 返回注释与空格"></a>Function.prototype.toString() 返回注释与空格</h3><p>在以往的版本中，<code>Function.prototype.toString()</code>得到的字符串是去掉空白符号的，但是从ES10开始会保留这些空格，如果是原生函数则返回你控制台看到的效果，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.toString())</span><br><span class="line"><span class="comment">// "function sum(a, b) &#123;</span></span><br><span class="line"><span class="comment">// 		return a + b;</span></span><br><span class="line"><span class="comment">//  &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs.toString()) <span class="comment">// "function abs() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>

<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>在以往的版本中，<code>try-catch</code>里<code>catch</code>后面必须带异常参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ES10之前</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// tryCode</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// catchCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在ES10之后，这个参数却不是必须的，如果用不到，我们可以不用传，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Foobar'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'Bar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><strong>BigInt</strong> 是一种内置对象，它提供了一种方法来表示大于 <code>253 - 1</code> 的整数。这原本是 Javascript中可以用 <code>Number</code> 表示的最大数字。<strong>BigInt</strong> 可以表示任意大的整数。</p>
<p>可以用在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>BigInt</code> ，如：<code>10n</code>，或者调用函数<code>BigInt()</code>。</p>
<p>在以往的版本中，我们有以下的弊端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大于2的53次方的整数，无法保持精度</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">53</span> === (<span class="number">2</span> ** <span class="number">53</span> + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 超过2的1024次方的数值，无法表示</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">1024</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>但是在ES10引入<code>BigInt</code>之后，这个问题便得到了解决。</p>
<p>以下操作符可以和 <code>BigInt</code> 一起使用： <code>+</code>、<code>*</code>、<code>-</code>、<code>**</code>、<code>%</code> 。除 <code>&gt;&gt;&gt;</code> （无符号右移）之外的位操作也可以支持。因为 <code>BigInt</code> 都是有符号的， <code>&gt;&gt;&gt;</code> （无符号右移）不能用于 <code>BigInt</code>。<code>BigInt</code> 不支持单目 (<code>+</code>) 运算符。</p>
<p><code>/</code> 操作符对于整数的运算也没问题。可是因为这些变量是 <code>BigInt</code> 而不是 <code>BigDecimal</code> ，该操作符结果会向零取整，也就是说不会返回小数部分。</p>
<p><code>BigInt</code> 和 <code>Number</code>不是严格相等的，但是宽松相等的。</p>
<p>所以在<code>BigInt</code>出来以后，JS的原始类型便增加到了7个，如下：</p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ES6)</li>
<li>BigInt (ES10)</li>
</ul>
<h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p><code>globalThis</code>属性包含类似于全局对象 <code>this</code>值。所以在全局环境下，我们有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalThis === <span class="keyword">this</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h3><p>静态的<code>import</code> 语句用于导入由另一个模块导出的绑定。无论是否声明了 严格模式，导入的模块都运行在严格模式下。在浏览器中，<code>import</code> 语句只能在声明了 <code>type=&quot;module&quot;</code> 的 <code>script</code> 的标签中使用。</p>
<p>但是在ES10之后，我们有动态 <code>import()</code>，它不需要依赖 <code>type=&quot;module&quot;</code> 的script标签。</p>
<p>所以我们有以下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">"nav &gt; a"</span>)) &#123;</span><br><span class="line">      link.addEventListener(<span class="string">"click"</span>, e =&gt; &#123;</span><br><span class="line">            e.preventDefault()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">import</span>(<span class="string">'/modules/my-module.js'</span>)</span><br><span class="line">              .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">module</span>.loadPageInto(main);</span><br><span class="line">              &#125;)</span><br><span class="line">              .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    main.textContent = err.message;</span><br><span class="line">              &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="私有元素与方法"><a href="#私有元素与方法" class="headerlink" title="私有元素与方法"></a>私有元素与方法</h3><p>在ES10之前，如果我们要实现一个简单的计数器组件，我们可能会这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// web component 写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">      <span class="keyword">get</span> x() &#123; </span><br><span class="line">          	<span class="keyword">return</span> <span class="keyword">this</span>.xValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> x(value) &#123;</span><br><span class="line">              <span class="keyword">this</span>.xValue = value</span><br><span class="line">              <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      clicked() &#123;</span><br><span class="line">            <span class="keyword">this</span>.x++</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">super</span>()</span><br><span class="line">            <span class="keyword">this</span>.onclick = <span class="keyword">this</span>.clicked.bind(<span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">this</span>.xValue = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      connectedCallback() &#123; </span><br><span class="line">          	<span class="keyword">this</span>.render()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">            <span class="keyword">this</span>.textContent = <span class="keyword">this</span>.x.toString()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'num-counter'</span>, Counter)</span><br></pre></td></tr></table></figure>

<p>但是在ES10之后我们可以使用私有变量进行组件封装，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">      #xValue = 0</span><br><span class="line"></span><br><span class="line">      <span class="keyword">get</span> #x() &#123; </span><br><span class="line">          return #xValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> #x(value) &#123;</span><br><span class="line">            this.#xValue = value</span><br><span class="line">            window.requestAnimationFrame(this.#render.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      #clicked() &#123;</span><br><span class="line">            this.#x++</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            this.onclick = this.#clicked.bind(this)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      connectedCallback() &#123; </span><br><span class="line">          	this.#render()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      #render() &#123;</span><br><span class="line">            this.textContent = this.#x.toString()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'num-counter'</span>, Counter)</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://es6.ruanyifeng.com/#docs/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li>
<li><a href="https://juejin.im/post/5d9bf530518825427b27639d" target="_blank" rel="noopener">1.5万字概括ES6全部特性</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">MDN</a></li>
<li><a href="https://segmentfault.com/a/1190000013519526" target="_blank" rel="noopener">ES2018 新特征之：非转义序列的模板字符串</a></li>
<li><a href="https://esnext.justjavac.com/proposal/regexp-lookbehind.html" target="_blank" rel="noopener">正则表达式反向(lookbehind)断言</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noopener">Unicode property escapes</a></li>
<li><a href="https://esnext.justjavac.com/proposal/exponentiation-operator.html" target="_blank" rel="noopener">exnext提案</a></li>
<li><a href="https://mp.weixin.qq.com/s/JuWoahhnEunkOTi4qNtWQg" target="_blank" rel="noopener">ES7、ES8、ES9、ES10新特性大盘点</a></li>
<li><a href="https://github.com/tc39" target="_blank" rel="noopener">Ecma TC39</a></li>
<li><a href="https://www.jianshu.com/p/b0877d1fc2a4" target="_blank" rel="noopener">[ECMAScript] TC39 process</a></li>
<li><a href="https://tc39.es/process-document/" target="_blank" rel="noopener">The TC39 Process</a></li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/21/原生JS-灵魂拷问-下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/21/原生JS-灵魂拷问-下/" class="post-title-link" itemprop="url">原生JS-灵魂拷问-下</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-21 16:29:16 / 修改时间：18:50:00" itemprop="dateCreated datePublished" datetime="2019-12-21T16:29:16+08:00">2019-12-21</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第24篇-JavaScript内存机制之问——数据是如何存储的？"><a href="#第24篇-JavaScript内存机制之问——数据是如何存储的？" class="headerlink" title="第24篇: JavaScript内存机制之问——数据是如何存储的？"></a>第24篇: JavaScript内存机制之问——数据是如何存储的？</h2><p>网上的资料基本是这样说的: 基本数据类型用<code>栈</code>存储，引用数据类型用<code>堆</code>存储。</p>
<p>看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完<code>栈顶空间销毁</code>，闭包变量不就没了吗？</p>
<p>其实还是需要补充一句:</p>
<blockquote>
<p>闭包变量是存在堆内存中的。</p>
</blockquote>
<p>具体而言，以下数据类型存储在栈中:</p>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
<li>bigint</li>
</ul>
<p>而所有的对象数据类型存放在堆中。</p>
<p>值得注意的是，对于<code>赋值</code>操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。</p>
<p>因此会有下面的情况:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = obj;</span><br><span class="line">newObj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//变成了2</span></span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为 obj 和 newObj 是同一份堆空间的地址，改变newObj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。</p>
<p>当然，你可能会问: 为什么不全部用栈来保存呢？</p>
<p>首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  f(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：</p>
<ol>
<li>调用func, 将 func 函数的上下文压栈，ESP指向栈顶。</li>
<li>执行func，又调用f函数，将 f 函数的上下文压栈，ESP 指针上移。</li>
<li>执行完 f 函数，将ESP 下移，f函数对应的栈顶空间被回收。</li>
<li>执行完 func，ESP 下移，func对应的空间被回收。</li>
</ol>
<p>图示如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%9B%BE.webp" alt></p>
<p>因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！</p>
<p>不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销，下一篇就来分析一下堆内存到底是如何进行垃圾回收并进行优化的。</p>
<h2 id="第25篇：V8-引擎如何进行垃圾内存的回收？"><a href="#第25篇：V8-引擎如何进行垃圾内存的回收？" class="headerlink" title="第25篇：V8 引擎如何进行垃圾内存的回收？"></a>第25篇：V8 引擎如何进行垃圾内存的回收？</h2><p>JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解JS的闭包特性、以及对内存的高效使用，都有很大的帮助。</p>
<h3 id="V8-内存限制"><a href="#V8-内存限制" class="headerlink" title="V8 内存限制"></a>V8 内存限制</h3><p>在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在<code>64</code>位系统下，V8最多只能分配<code>1.4G</code>, 在 32 位系统中，最多只能分配<code>0.7G</code>。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。</p>
<p>我们知道对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。</p>
<p>上一篇我们提到过了，所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。</p>
<p>那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？</p>
<p>究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。</p>
<p>首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p>
<blockquote>
<p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。</p>
</blockquote>
<p>可见其耗时之久，而且在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。</p>
<p>不过，如果你想调整这个内存的限制也不是不行。配置命令如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存</span></span><br><span class="line">node --max-old-space-size=<span class="number">2048</span> xxx.js</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是调整新生代这部分的内存，单位是 KB。</span></span><br><span class="line">node --max-<span class="keyword">new</span>-space-size=<span class="number">2048</span> xxx.js</span><br></pre></td></tr></table></figure>

<h3 id="新生代内存的回收"><a href="#新生代内存的回收" class="headerlink" title="新生代内存的回收"></a>新生代内存的回收</h3><p>V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61.webp" alt></p>
<p>根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。</p>
<p>首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。</p>
<p>那好了，新生代的垃圾回收是怎么做的呢？</p>
<p>首先将新生代内存空间一分为二:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62.webp" alt></p>
<p>其中From部分表示正在使用的内存，To 是目前闲置的内存。</p>
<p>当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。</p>
<p>当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色<code>对调</code>，From现在被闲置，To为正在使用，如此循环。</p>
<p>那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？</p>
<p>注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63.webp" alt></p>
<p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做<strong>内存碎片</strong>。刚刚介绍的新生代垃圾回收算法也叫<strong>Scavenge算法</strong>。</p>
<p>Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64.webp" alt></p>
<p>是不是整齐了许多？这样就大大方便了后续连续空间的分配。</p>
<p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象<code>一般很少</code>，因此<code>时间</code>性能非常优秀。</p>
<h3 id="老生代内存的回收"><a href="#老生代内存的回收" class="headerlink" title="老生代内存的回收"></a>老生代内存的回收</h3><p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到<code>老生代内存</code>中，这种现象就叫<code>晋升</code>。</p>
<p>发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p>
<ul>
<li>已经经历过一次 Scavenge 回收。</li>
<li>To（闲置）空间的内存占用超过25%。</li>
</ul>
<p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用<code>Scavenge</code>算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？</p>
<p>那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？</p>
<p>第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中<code>使用的变量</code>以及被<code>强引用</code>的变量取消标记，剩下的就是要删除的变量了，在随后的<code>清除阶段</code>对其进行空间的回收。</p>
<p>当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？</p>
<p>第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B65.webp" alt></p>
<p>由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。</p>
<h3 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h3><p>由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就”歇”一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像，这里就不展开了。</p>
<p>经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。</p>
<p>JS垃圾回收的原理就介绍到这里了，其实理解起来是非常简单的，重要的是理解它<code>为什么要这么做</code>，而不仅仅是<code>如何做的</code>，希望这篇总结能够对你有所启发。</p>
<h2 id="第26篇-描述一下-V8-执行一段JS代码的过程？"><a href="#第26篇-描述一下-V8-执行一段JS代码的过程？" class="headerlink" title="第26篇: 描述一下 V8 执行一段JS代码的过程？"></a>第26篇: 描述一下 V8 执行一段JS代码的过程？</h2><p>前端相对来说是一个比较新兴的领域，因此各种前端框架和工具层出不穷，让人眼花缭乱，尤其是各大厂商推出<code>小程序</code>之后<code>各自制定标准</code>，让前端开发的工作更加繁琐，在此背景下为了抹平平台之间的差异，诞生的各种<code>编译工具/框架</code>也数不胜数。但无论如何，想要赶上这些框架和工具的更新速度是非常难的，即使赶上了也很难产生自己的<code>技术积淀</code>，一个更好的方式便是学习那些<code>本质的知识</code>，抓住上层应用中不变的<code>底层机制</code>，这样我们便能轻松理解上层的框架而不仅仅是被动地使用，甚至能够在适当的场景下自己造出轮子，以满足开发效率的需求。</p>
<p>站在 V8 的角度，理解其中的执行机制，也能够帮助我们理解很多的上层应用，包括Babel、Eslint、前端框架的底层机制。那么，一段 JavaScript 代码放在 V8 当中究竟是如何执行的呢？</p>
<p>首先需要明白的是，机器是读不懂 JS 代码，机器只能理解特定的机器码，那如果要让 JS 的逻辑在机器上运行起来，就必须将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:</p>
<ul>
<li>通过词法分析和语法分析生成 AST(抽象语法树)</li>
<li>生成字节码</li>
</ul>
<p>然后解释器根据字节码来执行程序。但 JS 整个执行的过程其实会比这个更加复杂，接下来就来一一地拆解。</p>
<h3 id="1-生成-AST"><a href="#1-生成-AST" class="headerlink" title="1.生成 AST"></a>1.生成 AST</h3><p>生成 AST 分为两步——词法分析和语法分析。</p>
<p>词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'sanyuan'</span></span><br></pre></td></tr></table></figure>

<p>其中会把句子分解成四个部分:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.webp" alt></p>
<p>最后生成的 AST 是这样的:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B2.webp" alt></p>
<p>当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES6 的代码解析生成<code>ES6的AST</code>，然后将 ES6 的 AST 转换为 <code>ES5 的AST</code>,最后才将 ES5 的 AST 转化为具体的 ES5 代码。由于本文着重阐述原理，关于 babel 编译的细节就不展开了，推荐大家去读一读荒山的<a href="https://juejin.im/post/5d94bfbf5188256db95589be" target="_blank" rel="noopener">babel文章</a>, 帮你打开新世界的大门: )</p>
<p>回到 V8 本身，生成 AST 后，接下来会生成执行上下文，关于执行上下文，可以参考上上篇《JavaScript内存机制之问——数据是如何存储的？》中对于上下文压栈出栈过程的讲解。</p>
<h3 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2. 生成字节码"></a>2. 生成字节码</h3><p>开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是<code>字节码</code>并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。</p>
<p>给一张对比图让大家直观地感受以下三者代码量的差异:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B3.webp" alt></p>
<p>很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？</p>
<blockquote>
<p>子节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。</p>
</blockquote>
<p>字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。</p>
<h3 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h3><p>接下来，就进入到字节码解释执行的阶段啦！</p>
<p>在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做<code>热点代码</code>(HotSpot)，然后将这么代码编译成<code>机器码</code>保存起来，这个用来编译的工具就是V8的<code>编译器</code>(也叫做<code>TurboFan</code>) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为<code>热点代码</code>，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。</p>
<p>其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。</p>
<p>并且，这种字节码跟编译器和解释器结合的技术，我们称之为<code>即时编译</code>, 也就是我们经常听到的<code>JIT</code>。</p>
<p>这就是 V8 中执行一段JS代码的整个过程，梳理一下:</p>
<ol>
<li>首先通过词法分析和语法分析生成 <code>AST</code></li>
<li>将 AST 转换为字节码</li>
<li>由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率</li>
</ol>
<p>关于这个问题的拆解就到这里，希望对你有所启发。</p>
<h2 id="第28篇：如何理解EventLoop——宏任务和微任务篇"><a href="#第28篇：如何理解EventLoop——宏任务和微任务篇" class="headerlink" title="第28篇：如何理解EventLoop——宏任务和微任务篇"></a>第28篇：如何理解EventLoop——宏任务和微任务篇</h2><h3 id="宏任务-MacroTask-引入"><a href="#宏任务-MacroTask-引入" class="headerlink" title="宏任务(MacroTask)引入"></a>宏任务(MacroTask)引入</h3><p>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:</p>
<ol>
<li>渲染事件</li>
<li>用户交互事件</li>
<li>js脚本执行</li>
<li>网络请求、文件读写完成事件等等。</li>
</ol>
<p>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种<code>队列</code>的方式来存储这些任务， 即先进来的先执行。模拟如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">void</span> MainTherad()&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//执行队列中的任务</span></span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行延迟队列中的任务</span></span><br><span class="line">    ProcessDelayTask()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了一个 for 循环，将队列中的任务一一取出，然后执行，这个很好理解。但是其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如setTimeout/setInterval这样的定时器回调任务。</p>
<p>上述提到的，普通任务队列和延迟队列中的任务，都属于<strong>宏任务</strong>。</p>
<h3 id="微任务-MicroTask-引入"><a href="#微任务-MicroTask-引入" class="headerlink" title="微任务(MicroTask)引入"></a>微任务(MicroTask)引入</h3><p>对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？</p>
<p>其实引入微任务的初衷是为了解决异步回调的问题。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:</p>
<ol>
<li>将异步回调进行宏任务队列的入队操作。</li>
<li>将异步回调放到当前宏任务的末尾。</li>
</ol>
<p>如果采用第一种方式，那么执行回调的时机应该是在前面<code>所有的宏任务</code>完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成<code>应用卡顿</code>。</p>
<p>为了规避这样的问题，V8 引入了第二种方式，这就是<code>微任务</code>的解决方式。在每一个宏任务中定义一个<strong>微任务队列</strong>，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则<code>依次执行微任务</code>，执行完成才去执行下一个宏任务。</p>
<p>常见的微任务有MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程。</p>
<p>Ok, 这便是<code>宏任务</code>和<code>微任务</code>的概念，接下来正式介绍JS非常重要的运行机制——EventLoop。</p>
<h2 id="第29篇-如何理解EventLoop——浏览器篇"><a href="#第29篇-如何理解EventLoop——浏览器篇" class="headerlink" title="第29篇: 如何理解EventLoop——浏览器篇"></a>第29篇: 如何理解EventLoop——浏览器篇</h2><p>干讲理论不容易理解，让我们直接以一个例子开始吧:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure>

<p>我们来分析一下:</p>
<ol>
<li>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈(关于执行栈，若不了解请移步之前的文章《JavaScript内存机制之问——数据是如何存储的？》)进行执行，因此<strong>先打印start和end</strong></li>
<li>setTimeout 作为一个宏任务放入宏任务队列</li>
<li>Promise.then作为一个为微任务放入到微任务队列</li>
<li>当本次宏任务执行完，检查微任务队列，发现一个Promise.then, <strong>执行</strong></li>
<li>接下来进入到下一个宏任务——setTimeout, <strong>执行</strong></li>
</ol>
<p>因此最后的顺序是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">resolve</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<p>这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结。</p>
<ol>
<li>一开始整段脚本作为第一个<strong>宏任务</strong>执行</li>
<li>执行过程中同步代码直接执行，<strong>宏任务</strong>进入宏任务队列，<strong>微任务</strong>进入微任务队列</li>
<li>当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空</li>
<li>执行浏览器 UI 线程的渲染工作</li>
<li>检查是否有Web worker任务，有则执行</li>
<li>执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</li>
</ol>
<p>最后给大家留一道题目练习:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// Promise2</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br></pre></td></tr></table></figure>

<h2 id="第30篇-如何理解EventLoop——nodejs篇"><a href="#第30篇-如何理解EventLoop——nodejs篇" class="headerlink" title="第30篇: 如何理解EventLoop——nodejs篇"></a>第30篇: 如何理解EventLoop——nodejs篇</h2><p>nodejs 和 浏览器的 eventLoop 还是有很大差别的，值得单独拿出来说一说。</p>
<p>不知你是否看过关于 nodejs 中 eventLoop 的一些文章, 是否被这些流程图搞得眼花缭乱、一头雾水:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-node1.webp" alt></p>
<p>看到这你不用紧张，这里会抛开这些晦涩的流程图，以最清晰浅显的方式来一步步拆解 nodejs 的事件循环机制。</p>
<h3 id="1-三大关键阶段"><a href="#1-三大关键阶段" class="headerlink" title="1. 三大关键阶段"></a>1. 三大关键阶段</h3><p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p>
<ol>
<li>执行 <code>定时器回调</code> 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它<code>timer</code>。</li>
<li>轮询(英文叫<code>poll</code>)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、 ‘connect’等事件使得事件循环到达 <code>poll</code> 阶段。到达了这个阶段后:</li>
</ol>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li><p>如果队列<code>不为空</code>，拿出队列中的方法依次执行</p>
</li>
<li><p>如果队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为空</span><br></pre></td></tr></table></figure>

<p>，检查是否有 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setImmdiate</span><br></pre></td></tr></table></figure>

<p> 的回调 </p>
<ul>
<li>有则前往<code>check阶段</code>(下面会说)</li>
<li><code>没有则继续等待</code>，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后<code>自动进入 check 阶段</code>。</li>
</ul>
</li>
</ul>
<ol>
<li>check 阶段。这是一个比较简单的阶段，直接<code>执行 setImmdiate</code> 的回调。</li>
</ol>
<p>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。</p>
<h3 id="2-完善"><a href="#2-完善" class="headerlink" title="2. 完善"></a>2. 完善</h3><p>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 <code>I/O异常的回调阶段</code>。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p>
<p>并且在 check 阶段结束后还会进入到 <code>关闭事件的回调阶段</code>。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()， ‘close’ 事件的回调就会在这个阶段执行。</p>
<p>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</p>
<ol>
<li>timer 阶段</li>
<li>I/O 异常回调阶段</li>
<li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll 阶段</li>
<li>check 阶段</li>
<li>关闭事件的回调阶段</li>
</ol>
<p>是不是清晰了许多？</p>
<h3 id="3-实例演示"><a href="#3-实例演示" class="headerlink" title="3. 实例演示"></a>3. 实例演示</h3><p>好，我们以上次的练习题来实践一把:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这里我要说，node版本 &gt;= 11和在 11 以下的会有不同的表现。</p>
<p>首先说 node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">time2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>

<p>而 node 版本小于 11 的情况下，对于定时器的处理是:</p>
<blockquote>
<p>若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，<code>直接去执行</code>新的定时器任务，当新的定时器任务执行完后，<code>再一一执行</code>中途产生的微任务。</p>
</blockquote>
<p>因此会打印出这样的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>

<h3 id="4-nodejs-和-浏览器关于eventLoop的主要区别"><a href="#4-nodejs-和-浏览器关于eventLoop的主要区别" class="headerlink" title="4.nodejs 和 浏览器关于eventLoop的主要区别"></a>4.nodejs 和 浏览器关于eventLoop的主要区别</h3><p>两者最主要的区别在于浏览器中的微任务是在<code>每个相应的宏任务</code>中执行的，而nodejs中的微任务是在<code>不同阶段之间</code>执行的。</p>
<h3 id="5-关于process-nextTick的一点说明"><a href="#5-关于process-nextTick的一点说明" class="headerlink" title="5.关于process.nextTick的一点说明"></a>5.关于process.nextTick的一点说明</h3><p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p>
<p>在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<code>优先于微任务</code>执行。</p>
<h2 id="第31篇-nodejs中的异步、非阻塞I-O是如何实现的？"><a href="#第31篇-nodejs中的异步、非阻塞I-O是如何实现的？" class="headerlink" title="第31篇: nodejs中的异步、非阻塞I/O是如何实现的？"></a>第31篇: nodejs中的异步、非阻塞I/O是如何实现的？</h2><p>在听到 nodejs 相关的特性时，经常会对 <code>异步I/O</code>、<code>非阻塞I/O</code>有所耳闻，听起来好像是差不多的意思，但其实是两码事，下面我们就以原理的角度来剖析一下对 nodejs 来说，这两种技术底层是如何实现的？</p>
<h3 id="什么是I-O？"><a href="#什么是I-O？" class="headerlink" title="什么是I/O？"></a>什么是I/O？</h3><p>首先，我想有必要把 I/O 的概念解释一下。I/O 即Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于<code>网络I/O</code>。回到 nodejs 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:</p>
<ul>
<li>文件 I/O。比如用 fs 模块对文件进行读写操作。</li>
<li>网络 I/O。比如 http 模块发起网络请求。</li>
</ul>
<h3 id="阻塞和非阻塞I-O"><a href="#阻塞和非阻塞I-O" class="headerlink" title="阻塞和非阻塞I/O"></a>阻塞和非阻塞I/O</h3><p><code>阻塞</code>和<code>非阻塞</code> I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是一定要<strong>等到操作系统完成所有操作后才表示调用结束</strong>，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。</p>
<p>对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成<code>非阻塞I/O</code>，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 I/O 操作呢？</p>
<p>为了让 nodejs 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是<code>轮询</code>。对于轮询而言，有以下这么几种方案:</p>
<ol>
<li>一直轮询检查I/O状态，直到 I/O 完成。这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面。其实跟阻塞 I/O 的效果是一样的。</li>
<li>遍历文件描述符(即 文件I/O 时操作系统和 nodejs 之间的文件凭证)的方式来确定 I/O 是否完成，I/O完成则文件描述符的状态改变。但 CPU 轮询消耗还是很大。</li>
<li>epoll模式。即在进入轮询的时候如果I/O未完成CPU就休眠，完成之后唤醒CPU。</li>
</ol>
<p>总之，CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:</p>
<blockquote>
<p>nodejs 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。</p>
</blockquote>
<p>这是理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？</p>
<h3 id="异步-I-O-的本质"><a href="#异步-I-O-的本质" class="headerlink" title="异步 I/O 的本质"></a>异步 I/O 的本质</h3><p>Linux 原生存在这样的一种方式，即(AIO), 但两个致命的缺陷:</p>
<ol>
<li>只有 Linux 下存在，在其他系统中没有异步 I/O 支持。</li>
<li>无法利用系统缓存。</li>
</ol>
<h4 id="nodejs中的异步-I-O-方案"><a href="#nodejs中的异步-I-O-方案" class="headerlink" title="nodejs中的异步 I/O 方案"></a>nodejs中的异步 I/O 方案</h4><p>是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，<strong>异步 I/O 就是使用这样的线程池来实现的</strong>。</p>
<p>只不过在不同的系统下面表现会有所差异，在 Linux 下可以直接使用线程池来完成，在Window系统下则采用 IOCP 这个系统API(其内部还是用线程池完成的)。</p>
<p>有了操作系统的支持，那 nodejs 如何来对接这些操作系统从而实现异步 I/O 呢？</p>
<p>以文件为 I/O 我们以一段代码为例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'/test.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>执行代码的过程中大概发生了这些事情:</p>
<ol>
<li>首先，fs.readFile调用Node的核心模块fs.js ；</li>
<li>接下来，Node的核心模块调用内建模块node_file.cc，创建对应的文件I/O观察者对象(这个对象后面有大用！) ；</li>
<li>最后，根据不同平台（Linux或者window），内建模块通过libuv中间层进行系统调用</li>
</ol>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-node2.webp" alt></p>
<h4 id="ibuv调用过程拆解"><a href="#ibuv调用过程拆解" class="headerlink" title="ibuv调用过程拆解"></a>ibuv调用过程拆解</h4><p>重点来了！libuv 中是如何来进行进行系统调用的呢？也就是 uv_fs_open() 中做了些什么？</p>
<h5 id="1-创建请求对象"><a href="#1-创建请求对象" class="headerlink" title="1. 创建请求对象"></a>1. 创建请求对象</h5><p>以Windows系统为例来说，在这个函数的调用过程中，我们创建了一个文件I/O的<strong>请求对象</strong>，并往里面注入了回调函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback);</span><br></pre></td></tr></table></figure>

<p>req_wrap 便是这个请求对象，req_wrap 中 object_ 的 oncomplete_sym 属性对应的值便是我们 nodejs 应用程序代码中传入的回调函数。</p>
<h5 id="2-推入线程池，调用返回"><a href="#2-推入线程池，调用返回" class="headerlink" title="2. 推入线程池，调用返回"></a>2. 推入线程池，调用返回</h5><p>在这个对象包装完成后，QueueUserWorkItem() 方法将这个对象推进线程池中等待执行。</p>
<p>好，至此现在js的调用就直接返回了，我们的 js 应用程序代码可以<code>继续往下执行</code>，当然，当前的 <code>I/O</code> 操作同时也在线程池中将被执行，这不就完成了异步么：）</p>
<p>等等，别高兴太早，回调都还没执行呢！接下来便是执行回调通知的环节。</p>
<h5 id="3-回调通知"><a href="#3-回调通知" class="headerlink" title="3. 回调通知"></a>3. 回调通知</h5><p>事实上现在线程池中的 I/O 无论是阻塞还是非阻塞都已经无所谓了，因为异步的目的已经达成。重要的是 I/O 完成后会发生什么。</p>
<p>在介绍后续的故事之前，给大家介绍两个重要的方法: <code>GetQueuedCompletionStatus</code> 和 <code>PostQueuedCompletionStatus</code>。</p>
<ol>
<li>还记得之前讲过的 eventLoop 吗？在每一个Tick当中会调用<code>GetQueuedCompletionStatus</code>检查线程池中是否有执行完的请求，如果有则表示时机已经成熟，可以执行回调了。</li>
<li><code>PostQueuedCompletionStatus</code>方法则是向 IOCP 提交状态，告诉它当前I/O完成了。</li>
</ol>
<p>名字比较长，先介绍是为了让大家混个脸熟，至少后面出来不会感到太突兀：）</p>
<p>我们言归正传，把后面的过程串联起来。</p>
<p>当对应线程中的 I/O 完成后，会将获得的结果<code>存储</code>起来，保存到<code>相应的请求对象</code>中，然后调用<code>PostQueuedCompletionStatus()</code>向 IOCP 提交执行完成的状态，并且将线程还给操作系统。一旦 EventLoop 的轮询操作中，调用<code>GetQueuedCompletionStatus</code>检测到了完成的状态，就会把<code>请求对象</code>塞给I/O观察者(之前埋下伏笔，如今终于闪亮登场)。</p>
<p>I/O 观察者现在的行为就是取出<code>请求对象</code>的<code>存储结果</code>，同时也取出它的<code>oncomplete_sym</code>属性，即回调函数(不懂这个属性的回看第1步的操作)。将前者作为函数参数传入后者，并执行后者。 这里，回调函数就成功执行啦！</p>
<p>总结 :</p>
<ol>
<li><code>阻塞</code>和<code>非阻塞</code> I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要<strong>等到操作系统完成所有操作后才表示调用结束</strong>，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。</li>
<li>nodejs中的异步 I/O 采用多线程的方式，由 <code>EventLoop</code>、<code>I/O 观察者</code>，<code>请求对象</code>、<code>线程池</code>四大要素相互配合，共同实现。</li>
</ol>
<h2 id="第32篇：JS异步编程有哪些方案？为什么会出现这些方案？"><a href="#第32篇：JS异步编程有哪些方案？为什么会出现这些方案？" class="headerlink" title="第32篇：JS异步编程有哪些方案？为什么会出现这些方案？"></a>第32篇：JS异步编程有哪些方案？为什么会出现这些方案？</h2><p>关于 JS <code>单线程</code>、<code>EventLoop</code> 以及<code>异步 I/O</code> 这些底层的特性，我们之前做过了详细的拆解，不在赘述。在探究了底层机制之后，我们还需要对代码的组织方式有所理解，这是离我们最日常开发最接近的部分，异步代码的组织方式直接决定了<code>开发</code>和<code>维护</code>的<code>效率</code>，其重要性也不可小觑。尽管<strong>底层机制</strong>没变，但异步代码的组织方式却随着 ES 标准的发展，一步步发生了巨大的<code>变革</code>。接着让我们来一探究竟吧！</p>
<h3 id="回调函数时代"><a href="#回调函数时代" class="headerlink" title="回调函数时代"></a>回调函数时代</h3><p>相信很多 nodejs 的初学者都或多或少踩过这样的坑，node 中很多原生的 api 就是诸如这样的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'xxx'</span>, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>典型的高阶函数，将回调函数作为函数参数传给了readFile。但久而久之，就会发现，这种传入回调的方式也存在大坑, 比如下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'1.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    fs.readFile(<span class="string">'2.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">        fs.readFile(<span class="string">'3.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            fs.readFile(<span class="string">'4.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调当中嵌套回调，也称<code>回调地狱</code>。这种代码的可读性和可维护性都是非常差的，因为嵌套的层级太多。而且还有一个严重的问题，就是每次任务可能会失败，需要在回调里面对每个任务的失败情况进行处理，增加了代码的混乱程度。</p>
<h3 id="Promise-时代"><a href="#Promise-时代" class="headerlink" title="Promise 时代"></a>Promise 时代</h3><p>ES6 中新增的 Promise 就很好了解决了<code>回调地狱</code>的问题，同时了合并了错误处理。写出来的代码类似于下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'3.json'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'4.json'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以链式调用的方式避免了大量的嵌套，也符合人的线性思维方式，大大方便了异步编程。</p>
<h3 id="co-Generator-方式"><a href="#co-Generator-方式" class="headerlink" title="co + Generator 方式"></a>co + Generator 方式</h3><p>利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> r1 = <span class="keyword">yield</span> readFilePromise(<span class="string">'1.json'</span>);</span><br><span class="line">  <span class="keyword">const</span> r2 = <span class="keyword">yield</span> readFilePromise(<span class="string">'2.json'</span>);</span><br><span class="line">  <span class="keyword">const</span> r3 = <span class="keyword">yield</span> readFilePromise(<span class="string">'3.json'</span>);</span><br><span class="line">  <span class="keyword">const</span> r4 = <span class="keyword">yield</span> readFilePromise(<span class="string">'4.json'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="async-await方式"><a href="#async-await方式" class="headerlink" title="async + await方式"></a>async + await方式</h3><p>这是 ES7 中新增的关键字，凡是加上 async 的函数都默认返回一个 Promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFileAsync = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFilePromise(<span class="string">'1.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFilePromise(<span class="string">'2.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> f3 = <span class="keyword">await</span> readFilePromise(<span class="string">'3.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> f4 = <span class="keyword">await</span> readFilePromise(<span class="string">'4.json'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四种经典的异步编程方式就简单回顾完了，由于是鸟瞰大局，我觉得<code>知道是什么</code>比<code>了解细节</code>要重要, 因此也没有展开。不过没关系，接下来，让我们针对这些具体的解决方案，一步步深入异步编程，理解其中的本质。</p>
<h2 id="第33篇-能不能简单实现一下-node-中回调函数的机制？"><a href="#第33篇-能不能简单实现一下-node-中回调函数的机制？" class="headerlink" title="第33篇: 能不能简单实现一下 node 中回调函数的机制？"></a>第33篇: 能不能简单实现一下 node 中回调函数的机制？</h2><p><code>回调函数</code>的方式其实内部利用了<code>发布-订阅</code>模式，在这里我们以模拟实现 node 中的 Event 模块为例来写实现回调函数的机制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.events = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 EventEmitter 一共需要实现这些方法: <code>addListener</code>, <code>removeListener</code>, <code>once</code>, <code>removeAllListener</code>, <code>emit</code>。</p>
<p>首先是addListener：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// once 参数表示是否只是触发一次</span></span><br><span class="line"><span class="keyword">const</span> wrapCallback = <span class="function">(<span class="params">fn, once = <span class="literal">false</span></span>) =&gt;</span> (&#123; <span class="attr">callback</span>: fn, once &#125;);</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn, once = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="comment">// 为 type 事件绑定回调</span></span><br><span class="line">    <span class="keyword">this</span>.events.set(type, wrapCallback(fn, once));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler.callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 目前 type 事件只有一个回调</span></span><br><span class="line">    <span class="keyword">this</span>.events.set(type, [handler, wrapCallback(fn, once)]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 目前 type 事件回调数 &gt;= 2</span></span><br><span class="line">    handler.push(wrapCallback(fn, once));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeLisener 的实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler.callback === listener.callback) <span class="keyword">this</span>.events.delete(type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = handler[i];</span><br><span class="line">    <span class="keyword">if</span> (item.callback === listener.callback) &#123;</span><br><span class="line">      <span class="comment">// 删除该回调，注意数组塌陷的问题，即后面的元素会往前挪一位。i 要 -- </span></span><br><span class="line">      handler.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--;</span><br><span class="line">      <span class="keyword">if</span> (handler.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 长度为 1 就不用数组存了</span></span><br><span class="line">        <span class="keyword">this</span>.events.set(type, handler[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>once 实现思路很简单，先调用 addListener 添加上了once标记的回调对象, 然后在 emit 的时候遍历回调列表，将标记了once: true的项remove掉即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.addListener(type, fn, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">    <span class="comment">// 遍历列表，执行回调</span></span><br><span class="line">    handler.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.callback.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="comment">// 标记的 once: true 的项直接移除</span></span><br><span class="line">      <span class="keyword">if</span> (item.once) <span class="keyword">this</span>.removeListener(type, item);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个回调则直接执行</span></span><br><span class="line">    handler.callback.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是 removeAllListener：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.removeAllListener = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = <span class="keyword">this</span>.events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.events.delete(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们测试一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">e.addListener(<span class="string">'type'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"type事件触发！"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">e.addListener(<span class="string">'type'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"WOW!type事件又触发了！"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"type事件我只触发一次"</span>); </span><br><span class="line">&#125;</span><br><span class="line">e.once(<span class="string">'type'</span>, f)</span><br><span class="line">e.emit(<span class="string">'type'</span>);</span><br><span class="line">e.emit(<span class="string">'type'</span>);</span><br><span class="line">e.removeAllListener(<span class="string">'type'</span>);</span><br><span class="line">e.emit(<span class="string">'type'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// type事件触发！</span></span><br><span class="line"><span class="comment">// WOW!type事件又触发了！</span></span><br><span class="line"><span class="comment">// type事件我只触发一次</span></span><br><span class="line"><span class="comment">// type事件触发！</span></span><br><span class="line"><span class="comment">// WOW!type事件又触发了！</span></span><br></pre></td></tr></table></figure>

<p>OK，一个简易的 Event 就这样实现完成了，为什么说它简易呢？因为还有很多细节的部分没有考虑:</p>
<ol>
<li>在<code>参数少</code>的情况下，call 的性能优于 apply，反之 apply 的性能更好。因此在执行回调时候可以根据情况调用 call 或者 apply。</li>
<li>考虑到内存容量，应该设置<code>回调列表的最大值</code>，当超过最大值的时候，应该选择部分回调进行删除操作。</li>
<li><code>鲁棒性</code>有待提高。对于<code>参数的校验</code>很多地方直接忽略掉了。</li>
</ol>
<p>不过，这个案例的目的只是带大家掌握核心的原理，如果在这里洋洋洒洒写三四百行意义也不大，有兴趣的可以去看看Node中 <a href="https://github.com/Gozala/events/blob/master/events.js" target="_blank" rel="noopener">Event 模块</a> 的源码，里面对各种细节和边界情况做了详细的处理。</p>
<h2 id="第34篇-Promise之问-一-——Promise-凭借什么消灭了回调地狱？"><a href="#第34篇-Promise之问-一-——Promise-凭借什么消灭了回调地狱？" class="headerlink" title="第34篇: Promise之问(一)——Promise 凭借什么消灭了回调地狱？"></a>第34篇: Promise之问(一)——Promise 凭借什么消灭了回调地狱？</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>首先，什么是回调地狱:</p>
<ol>
<li>多层嵌套的问题。</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ol>
<p>这两种问题在回调函数时代尤为突出。Promise 的诞生就是为了解决这两个问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Promise 利用了三大技术手段来解决<code>回调地狱</code>:</p>
<ul>
<li><strong>回调函数延迟绑定</strong>。</li>
<li><strong>返回值穿透</strong>。</li>
<li><strong>错误冒泡</strong>。</li>
</ul>
<p>首先来举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看到没有，回调函数不是直接声明的，而是在通过后面的 then 方法传入的，即延迟传入。这就是<code>回调函数延迟绑定</code>。</p>
<p>然后我们做以下微调:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>)<span class="comment">//这是返回的Promise</span></span><br><span class="line">&#125;);</span><br><span class="line">x.then(<span class="comment">/* 内部逻辑省略 */</span>)</span><br></pre></td></tr></table></figure>

<p>我们会根据 then 中回调函数的传入值创建不同类型的Promise, 然后把返回的 Promise 穿透到外层, 以供后续的调用。这里的 x 指的就是内部返回的 Promise，然后在 x 后面可以依次完成链式调用。</p>
<p>这便是<code>返回值穿透</code>的效果。</p>
<p>这两种技术一起作用便可以将深层的嵌套回调写成下面的形式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'3.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'4.json'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就显得清爽了许多，更重要的是，它更符合人的线性思维模式，开发体验也更好。</p>
<p>两种技术结合产生了<code>链式调用</code>的效果。</p>
<p>这解决的是多层嵌套的问题，那另一个问题，即每次任务执行结束后<code>分别处理成功和失败</code>的情况怎么解决的呢？</p>
<p>Promise 采用了<code>错误冒泡</code>的方式。其实很简单理解，我们来看看效果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">readFilePromise(<span class="string">'1.json'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'2.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'3.json'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFilePromise(<span class="string">'4.json'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。</p>
<h3 id="解决效果"><a href="#解决效果" class="headerlink" title="解决效果"></a>解决效果</h3><ul>
<li><ol>
<li>实现链式调用，解决多层嵌套问题</li>
</ol>
</li>
<li><ol>
<li>实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题</li>
</ol>
</li>
</ul>
<h2 id="第35篇-Promise之问-二-——为什么Promise要引入微任务？"><a href="#第35篇-Promise之问-二-——为什么Promise要引入微任务？" class="headerlink" title="第35篇: Promise之问(二)——为什么Promise要引入微任务？"></a>第35篇: Promise之问(二)——为什么Promise要引入微任务？</h2><p>在这里，如果你还没有接触过 Promise, 务必去看看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN 文档</a>，了解使用方式，不然后面很会懵。</p>
<p>Promise 中的执行函数是同步进行的，但是里面存在着异步操作，在异步操作结束后会调用 resolve 方法，或者中途遇到错误调用 reject 方法，这两者都是作为微任务进入到 EventLoop 中。但是你有没有想过，Promise 为什么要引入微任务的方式来进行回调操作？</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:</p>
<ol>
<li>使用同步回调，直到异步任务进行完，再进行后面的任务。</li>
<li>使用异步回调，将回调函数放在进行<code>宏任务队列</code>的队尾。</li>
<li>使用异步回调，将回调函数放到<code>当前宏任务中</code>的最后面。</li>
</ol>
<h3 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h3><p>第一种方式显然不可取，因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分<code>等待的时间</code>是可以拿来完成其他事情的，导致 CPU 的利用率非常低，而且还有另外一个致命的问题，就是无法实现<code>延迟绑定</code>的效果。</p>
<p>如果采用第二种方式，那么执行回调(resolve/reject)的时机应该是在前面<code>所有的宏任务</code>完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成<code>应用卡顿</code>。</p>
<p>为了解决上述方案的问题，另外也考虑到<code>延迟绑定</code>的需求，Promise 采取第三种方式, 即<code>引入微任务</code>, 即把 resolve(reject) 回调的执行放在当前宏任务的末尾。</p>
<p>这样，利用<code>微任务</code>解决了两大痛点:</p>
<ul>
<li><ol>
<li>采用<strong>异步回调</strong>替代同步回调解决了浪费 CPU 性能的问题。</li>
</ol>
</li>
<li><ol>
<li>放到<strong>当前宏任务最后</strong>执行，解决了回调执行的实时性问题。</li>
</ol>
</li>
</ul>
<p>好，Promise 的基本实现思想已经讲清楚了，相信大家已经知道了它<code>为什么这么设计</code>，接下来就让我们一步步弄清楚它内部到底是<code>怎么设计的</code>。</p>
<h2 id="第36篇-Promise之问-三-——Promise-如何实现链式调用？"><a href="#第36篇-Promise之问-三-——Promise-如何实现链式调用？" class="headerlink" title="第36篇: Promise之问(三)——Promise 如何实现链式调用？"></a>第36篇: Promise之问(三)——Promise 如何实现链式调用？</h2><p>从现在开始，我们就来动手实现一个功能完整的Promise，一步步深挖其中的细节。我们先从链式调用开始。</p>
<h3 id="简易版实现"><a href="#简易版实现" class="headerlink" title="简易版实现"></a>简易版实现</h3><p>首先写出第一版的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>; <span class="comment">// 缓存当前promise实例</span></span><br><span class="line">  self.value = <span class="literal">null</span>;</span><br><span class="line">  self.error = <span class="literal">null</span>; </span><br><span class="line">  self.status = PENDING;</span><br><span class="line">  self.onFulfilled = <span class="literal">null</span>; <span class="comment">//成功的回调函数</span></span><br><span class="line">  self.onRejected = <span class="literal">null</span>; <span class="comment">//失败的回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.status = FULFILLED;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.onFulfilled(self.value);<span class="comment">//resolve时执行成功回调</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      self.status = REJECTED;</span><br><span class="line">      self.error = error;</span><br><span class="line">      self.onRejected(self.error);<span class="comment">//resolve时执行成功回调</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilled = onFulfilled;</span><br><span class="line">    <span class="keyword">this</span>.onRejected = onRejected;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    <span class="comment">//如果状态是fulfilled，直接执行成功回调，并将成功值传入</span></span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果状态是rejected，直接执行失败回调，并将失败原因传入</span></span><br><span class="line">    onRejected(<span class="keyword">this</span>.error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Promise 的本质是一个<code>有限状态机</code>，存在三种状态:</p>
<ul>
<li>PENDING(等待)</li>
<li>FULFILLED(成功)</li>
<li>REJECTED(失败)</li>
</ul>
<p>状态改变规则如下图:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-Promise.webp" alt></p>
<p>对于 Promise 而言，状态的改变<code>不可逆</code>，即由等待态变为其他的状态后，就无法再改变了。</p>
<p>不过，回到目前这一版的 Promise, 还是存在一些问题的。</p>
<h3 id="设置回调数组"><a href="#设置回调数组" class="headerlink" title="设置回调数组"></a>设置回调数组</h3><p>首先只能执行一个回调函数，对于多个回调的绑定就无能为力，比如下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">'./001.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x1 = promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第一次展示"</span>, data.toString());    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x2 = promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第二次展示"</span>, data.toString());    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x3 = promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第三次展示"</span>, data.toString());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里我绑定了三个回调，想要在 resolve() 之后一起执行，那怎么办呢？</p>
<p>需要将 <code>onFulfilled</code> 和 <code>onRejected</code> 改为数组，调用 resolve 时将其中的方法拿出来一一执行即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.onFulfilledCallbacks = [];</span><br><span class="line">self.onRejectedCallbacks = [];</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将 resolve 和 reject 方法中执行回调的部分进行修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 中</span></span><br><span class="line">self.onFulfilledCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.value));</span><br><span class="line"><span class="comment">//reject 中</span></span><br><span class="line">self.onRejectedCallbacks.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(self.error));</span><br></pre></td></tr></table></figure>

<h3 id="链式调用完成"><a href="#链式调用完成" class="headerlink" title="链式调用完成"></a>链式调用完成</h3><p>我们采用目前的代码来进行测试:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFilePromise(<span class="string">'./001.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());    </span><br><span class="line">  <span class="keyword">return</span> readFilePromise(<span class="string">'./002.txt'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 001.txt的内容</span></span><br><span class="line"><span class="comment">// 001.txt的内容</span></span><br></pre></td></tr></table></figure>

<p>咦？怎么打印了两个 <code>001</code>，第二次不是读的 <code>002</code> 文件吗？</p>
<p>问题出在这里:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写每次返回的都是第一个 Promise。then 函数当中返回的第二个 Promise 直接被无视了！</p>
<p>说明 then 当中的实现还需要改进, 我们现在需要对 then 中返回值重视起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bridgePromise;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      self.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 看到了吗？要拿到 then 中回调返回的结果。</span></span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallbacks.push(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(error);</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假若当前状态为 PENDING，将回调数组中添加如上的函数，当 Promise 状态变化后，会遍历相应回调数组并执行回调。</p>
<p>但是这段程度还是存在一些问题:</p>
<ol>
<li>首先 then 中的两个参数不传的情况并没有处理，</li>
<li>假如 then 中的回调执行后返回的结果(也就是上面的<code>x</code>)是一个 Promise, 直接给 resolve 了，这是我们不希望看到的。</li>
</ol>
<p>怎么来解决这两个问题呢？</p>
<p>先对参数不传的情况做判断:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功回调不传给它一个默认函数</span></span><br><span class="line">onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">"function"</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">// 对于失败回调直接抛错</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;;</span><br></pre></td></tr></table></figure>

<p>然后对<code>返回Promise</code>的情况进行处理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">bridgePromise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果x是一个promise</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="comment">// 拆解这个 promise ，直到返回值不为 promise 为止</span></span><br><span class="line">    <span class="keyword">if</span> (x.status === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">        resolvePromise(bridgePromise, y, resolve, reject);</span><br><span class="line">      &#125;, error =&gt; &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非 Promise 的话直接 resolve 即可</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 then 的方法实现中作如下修改:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve(x)  -&gt;  resolvePromise(bridgePromise, x, resolve, reject);</span><br></pre></td></tr></table></figure>

<p>在这里大家好好体会一下拆解 Promise 的过程，其实不难理解，我要强调的是其中的递归调用始终传入的<code>resolve</code>和<code>reject</code>这两个参数是什么含义，其实他们控制的是最开始传入的<code>bridgePromise</code>的状态，这一点非常重要。</p>
<p>紧接着，我们实现一下当 Promise 状态不为 PENDING 时的逻辑。</p>
<p>成功状态下调用then：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 状态变为成功，会有相应的 self.value</span></span><br><span class="line">      <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">      <span class="comment">// 暂时可以理解为 resolve(x)，后面具体实现中有拆解的过程</span></span><br><span class="line">      resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败状态下调用then：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 状态变为失败，会有相应的 self.error</span></span><br><span class="line">      <span class="keyword">let</span> x = onRejected(self.error);</span><br><span class="line">      resolvePromise(bridgePromise, x, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise A+中规定成功和失败的回调都是微任务，由于浏览器中 JS 触碰不到底层微任务的分配，可以直接拿 <code>setTimeout</code>(属于<strong>宏任务</strong>的范畴) 来模拟，用 <code>setTimeout</code>将需要执行的任务包裹 ，当然，上面的 resolve 实现也是同理, 大家注意一下即可，其实并不是真正的微任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">  <span class="keyword">return</span> bridgePromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到这里, 我们基本实现了 then 方法，现在我们拿刚刚的测试代码做一下测试, 依次打印如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br></pre></td></tr></table></figure>

<p>可以看到，已经可以顺利地完成链式调用。</p>
<h3 id="错误捕获及冒泡机制分析"><a href="#错误捕获及冒泡机制分析" class="headerlink" title="错误捕获及冒泡机制分析"></a>错误捕获及冒泡机制分析</h3><p>现在来实现 catch 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对，就是这么几行，catch 原本就是 then 方法的语法糖。</p>
<p>相比于实现来讲，更重要的是理解其中错误冒泡的机制，即中途一旦发生错误，可以在最后用 catch 捕获错误。</p>
<p>我们回顾一下 Promise 的运作流程也不难理解，贴上一行关键的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then 的实现中</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;;</span><br></pre></td></tr></table></figure>

<p>一旦其中有一个<code>PENDING状态</code>的 Promise 出现错误后状态必然会变为<code>失败</code>, 然后执行 <code>onRejected</code>函数，而这个 onRejected 执行又会抛错，把新的 Promise 状态变为<code>失败</code>，新的 Promise 状态变为失败后又会执行<code>onRejected</code>……就这样一直抛下去，直到用<code>catch</code> 捕获到这个错误，才停止往下抛。</p>
<p>这就是 Promise 的<code>错误冒泡机制</code>。</p>
<p>至此，Promise 三大法宝: <code>回调函数延迟绑定</code>、<code>回调返回值穿透</code>和<code>错误冒泡</code>。</p>
<h2 id="第37篇-Promise-之问-四-——实现Promise的-resolve、reject-和-finally"><a href="#第37篇-Promise-之问-四-——实现Promise的-resolve、reject-和-finally" class="headerlink" title="第37篇: Promise 之问(四)——实现Promise的 resolve、reject 和 finally"></a>第37篇: Promise 之问(四)——实现Promise的 resolve、reject 和 finally</h2><h3 id="实现-Promise-resolve"><a href="#实现-Promise-resolve" class="headerlink" title="实现 Promise.resolve"></a>实现 Promise.resolve</h3><p>实现 resolve 静态方法有三个要点:</p>
<ul>
<li><ol>
<li>传参为一个 Promise, 则直接返回它。</li>
</ol>
</li>
<li><ol>
<li>传参为一个 thenable 对象，返回的 Promise 会跟随这个对象，<code>采用它的最终状态</code>作为<code>自己的状态</code>。</li>
</ol>
</li>
<li><ol>
<li>其他情况，直接返回以该值为成功状态的promise对象。</li>
</ol>
</li>
</ul>
<p>具体实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(param <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="keyword">return</span> param;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(param &amp;&amp; param.then &amp;&amp; <span class="keyword">typeof</span> param.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// param 状态变为成功会调用resolve，将新 Promise 的状态变为成功，反之亦然</span></span><br><span class="line">      param.then(resolve, reject);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(param);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Promise-reject"><a href="#实现-Promise-reject" class="headerlink" title="实现 Promise.reject"></a>实现 Promise.reject</h3><p>Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Promise-prototype-finally"><a href="#实现-Promise-prototype-finally" class="headerlink" title="实现 Promise.prototype.finally"></a>实现 Promise.prototype.finally</h3><p>无论当前 Promise 是成功还是失败，调用<code>finally</code>之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第38篇-Promise-之问-五-——实现Promise的-all-和-race"><a href="#第38篇-Promise-之问-五-——实现Promise的-all-和-race" class="headerlink" title="第38篇: Promise 之问(五)——实现Promise的 all 和 race"></a>第38篇: Promise 之问(五)——实现Promise的 all 和 race</h2><h3 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h3><p>对于 all 方法而言，需要完成下面的核心功能:</p>
<ol>
<li>传入参数为一个空的可迭代对象，则<code>直接进行resolve</code>。</li>
<li>如果参数中<code>有一个</code>promise失败，那么Promise.all返回的promise对象失败。</li>
<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个<code>数组</code></li>
</ol>
<p>具体实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index === len) resolve(result);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Promise-race"><a href="#实现-Promise-race" class="headerlink" title="实现 Promise.race"></a>实现 Promise.race</h3><p>race 的实现相比之下就简单一些，只要有一个 promise 执行完，直接 resolve 并停止执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，一个完整的 Promise 就被我们实现完啦。从原理到细节，我们一步步拆解和实现，希望大家在知道 Promise 设计上的几大亮点之后，也能自己手动实现一个Promise，让自己的思维层次和动手能力更上一层楼！</p>
<h2 id="第39篇-谈谈你对生成器以及协程的理解。"><a href="#第39篇-谈谈你对生成器以及协程的理解。" class="headerlink" title="第39篇: 谈谈你对生成器以及协程的理解。"></a>第39篇: 谈谈你对生成器以及协程的理解。</h2><p>生成器(Generator)是 ES6 中的新语法，相对于之前的异步语法，上手的难度还是比较大的。因此这里我们先来好好熟悉一下 Generator 语法。</p>
<h3 id="生成器执行流程"><a href="#生成器执行流程" class="headerlink" title="生成器执行流程"></a>生成器执行流程</h3><p>上面是生成器函数？</p>
<p>生成器是一个带<code>星号</code>的”函数”(注意：它并不是真正的函数)，可以通过<code>yield</code>关键字<code>暂停执行</code>和<code>恢复执行</code>的</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"enter"</span>);</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2</span>&#125;)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen() <span class="comment">// 阻塞住，不会执行任何语句</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> g)  <span class="comment">// object  看到了吗？不是"function"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next())  </span><br><span class="line"><span class="built_in">console</span>.log(g.next())  </span><br><span class="line"><span class="built_in">console</span>.log(g.next())  </span><br><span class="line"><span class="built_in">console</span>.log(g.next()) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// enter</span></span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">// &#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>由此可以看到，生成器的执行有这样几个关键点:</p>
<ol>
<li>调用 gen() 后，程序会阻塞住，不会执行任何语句。</li>
<li>调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。</li>
<li>next 方法返回一个对象， 有两个属性: <code>value</code> 和 <code>done</code>。value 为<code>当前 yield 后面的结果</code>，done 表示<code>是否执行完</code>，遇到了<code>return</code> 后，<code>done</code> 会由<code>false</code>变为<code>true</code>。</li>
</ol>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>当一个生成器要调用另一个生成器时，使用 yield* 就变得十分方便。比如下面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要按照<code>1234</code>的顺序执行，如何来做呢？</p>
<p>在 <code>gen1</code> 中，修改如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* gen2();</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改之后，之后依次调用<code>next</code>即可。</p>
<h3 id="生成器实现机制——协程"><a href="#生成器实现机制——协程" class="headerlink" title="生成器实现机制——协程"></a>生成器实现机制——协程</h3><p>可能你会比较好奇，生成器究竟是如何让函数暂停, 又会如何恢复的呢？接下来我们就来对其中的执行机制——<code>协程</code>一探究竟。</p>
<h4 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h4><p>协程是一种比线程更加轻量级的存在，协程处在线程的环境中，<code>一个线程可以存在多个协程</code>，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。</p>
<h4 id="协程的运作过程"><a href="#协程的运作过程" class="headerlink" title="协程的运作过程"></a>协程的运作过程</h4><p>那你可能要问了，JS 不是单线程执行的吗，开这么多协程难道可以一起执行吗？</p>
<p>答案是：并不能。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将<code>JS 线程的控制权转交给 B协程</code>，那么现在 B 执行，A 就相当于处于暂停的状态。</p>
<p>举个具体的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是A"</span>);</span><br><span class="line">  <span class="keyword">yield</span> B(); <span class="comment">// A停住，在这里转交线程执行权给B</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"结束了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我是B"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;<span class="comment">// 返回，并且将线程执行权还给A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = A();</span><br><span class="line">gen.next();</span><br><span class="line">gen.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是A</span></span><br><span class="line"><span class="comment">// 我是B</span></span><br><span class="line"><span class="comment">// 结束了</span></span><br></pre></td></tr></table></figure>

<p>在这个过程中，A 将执行权交给 B，也就是 <code>A 启动 B</code>，我们也称 A 是 B 的<strong>父协程</strong>。因此 B 当中最后<code>return 100</code>其实是将 100 传给了父协程。</p>
<p>需要强调的是，对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程<code>上下文切换</code>的开销，这是<code>高性能</code>的重要原因。</p>
<p>OK, 原理就说到这里。可能你还会有疑问: 这个生成器不就暂停-恢复、暂停-恢复这样执行的吗？它和异步有什么关系？而且，每次执行都要调用next，能不能让它一次性执行完毕呢？下一节我们就来仔细拆解这些问题。</p>
<h2 id="第40篇-如何让-Generator-的异步代码按顺序执行完毕？"><a href="#第40篇-如何让-Generator-的异步代码按顺序执行完毕？" class="headerlink" title="第40篇: 如何让 Generator 的异步代码按顺序执行完毕？"></a>第40篇: 如何让 Generator 的异步代码按顺序执行完毕？</h2><p>这里面其实有两个问题:</p>
<ol>
<li><code>Generator</code> 如何跟<code>异步</code>产生关系？</li>
<li>怎么把 <code>Generator</code> 按顺序执行完毕？</li>
</ol>
<h3 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h3><p>要想知道 <code>Generator</code> 跟异步的关系，首先带大家搞清楚一个概念——thunk函数(即<code>偏函数</code>)，虽然这只是实现两者关系的方式之一。(另一种方式是<code>Promise</code>, 后面会讲到)</p>
<p>举个例子，比如我们现在要判断数据类型。可以写如下的判断逻辑:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object String]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> isFunction = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Function]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> isArray = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> isSet = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Set]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以看到，出现了非常多重复的逻辑。我们将它们做一下封装:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们这样做即可:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">let</span> isFunction = isType(<span class="string">'Function'</span>);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>相应的 <code>isString</code>和<code>isFunction</code>是由<code>isType</code>生产出来的函数，但它们依然可以判断出参数是否为String（Function），而且代码简洁了不少。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isString(<span class="string">"123"</span>);</span><br><span class="line">isFunction(<span class="function"><span class="params">val</span> =&gt;</span> val);</span><br></pre></td></tr></table></figure>

<p><strong>isType</strong>这样的函数我们称为<strong>thunk 函数</strong>。它的核心逻辑是接收一定的参数，生产出定制化的函数，然后使用定制化的函数去完成功能。thunk函数的实现会比单个的判断函数复杂一点点，但就是这一点点的复杂，大大方便了后续的操作。</p>
<h3 id="Generator-和-异步"><a href="#Generator-和-异步" class="headerlink" title="Generator 和 异步"></a>Generator 和 异步</h3><h4 id="thunk-版本"><a href="#thunk-版本" class="headerlink" title="thunk 版本"></a>thunk 版本</h4><p>以<code>文件操作</code>为例，我们来看看 <strong>异步操作</strong> 如何应用于<code>Generator</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFileThunk = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readFileThunk</code>就是一个<code>thunk函数</code>。异步操作核心的一环就是绑定回调函数，而<code>thunk函数</code>可以帮我们做到。首先传入文件名，然后生成一个针对某个文件的定制化函数。这个函数中传入回调，这个回调就会成为异步操作的回调。这样就让 <code>Generator</code> 和<code>异步</code>关联起来了。</p>
<p>紧接者我们做如下的操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'001.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1.toString())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'002.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们让它执行完:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="comment">// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。</span></span><br><span class="line"><span class="comment">// next返回值中有一个value值，这个value是yield后面的结果，放在这里也就是是thunk函数生成的定制化函数，里面需要传一个回调函数作为参数</span></span><br><span class="line">g.next().value(<span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第二步: 拿到上一次得到的结果，调用next, 将结果作为参数传入，程序继续执行。</span></span><br><span class="line">  <span class="comment">// 同理，value传入回调</span></span><br><span class="line">  g.next(data1).value(<span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">    g.next(data2);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br></pre></td></tr></table></figure>

<p>上面嵌套的情况还算简单，如果任务多起来，就会产生很多层的嵌套，可操作性不强，有必要把执行的代码封装一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span>;</span><br><span class="line">    res.value(next);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<p>Ok,再次执行，依然打印正确的结果。代码虽然就这么几行，但包含了递归的过程，好好体会一下。</p>
<p>这是通过<code>thunk</code>完成异步操作的情况。</p>
<h4 id="Promise-版本"><a href="#Promise-版本" class="headerlink" title="Promise 版本"></a>Promise 版本</h4><p>还是拿上面的例子，用<code>Promise</code>来实现就轻松一些:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readFilePromise = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> readFilePromise(<span class="string">'001.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1.toString())</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> readFilePromise(<span class="string">'002.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2.toString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGenPromise</span>(<span class="params">gen, data</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> gen.next(data).value;</span><br><span class="line">&#125;</span><br><span class="line">getGenPromise(g).then(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getGenPromise(g, data1);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getGenPromise(g, data2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br></pre></td></tr></table></figure>

<p>同样，我们可以对执行<code>Generator</code>的代码加以封装:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = g.next();</span><br><span class="line">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span>;</span><br><span class="line">    res.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样能输出正确的结果。代码非常精炼，希望能参照刚刚链式调用的例子，仔细体会一下递归调用的过程。</p>
<h3 id="采用-co-库"><a href="#采用-co-库" class="headerlink" title="采用 co 库"></a>采用 co 库</h3><p>以上我们针对 <code>thunk 函数</code>和<code>Promise</code>两种<code>Generator异步操作</code>的一次性执行完毕做了封装，但实际场景中已经存在成熟的工具包了，如果大名鼎鼎的<strong>co</strong>库, 其实核心原理就是我们已经手写过了（就是刚刚封装的Promise情况下的执行代码），只不过源码会各种边界情况做了处理。使用起来非常简单:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">co(g).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001.</span>txt的内容</span><br><span class="line"><span class="number">002.</span>txt的内容</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>简单几行代码就完成了<code>Generator</code>所有的操作，真不愧<code>co</code>和<code>Generator</code>天生一对啊！</p>
<h2 id="第41篇-解释一下async-await的运行机制。"><a href="#第41篇-解释一下async-await的运行机制。" class="headerlink" title="第41篇: 解释一下async/await的运行机制。"></a>第41篇: 解释一下async/await的运行机制。</h2><p><code>async/await</code>被称为 JS 中<strong>异步终极解决方案</strong>。它既能够像 co + Generator 一样用同步的方式来书写异步代码，又得到底层的语法支持，无需借助任何第三方库。接下来，我们从原理的角度来重新审视这个语法糖背后究竟做了些什么。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>什么是 async ?</p>
<blockquote>
<p>MDN 的定义: async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p>
</blockquote>
<p>注意重点: <strong>返回结果为Promise</strong>。</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func());</span><br><span class="line"><span class="comment">// Promise &#123;&lt;resolved&gt;: 100&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就是隐式返回 Promise 的效果。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>我们来看看 <code>await</code>做了些什么事情。</p>
<p>以一段代码为例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">await</span> <span class="number">200</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<p>我们来分析一下这段程序。首先代码同步执行，打印出<code>0</code>，然后将<code>test</code>压入执行栈，打印出<code>100</code>, 下面注意了，遇到了关键角色<strong>await</strong>。</p>
<p>放个慢镜头:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>被 JS 引擎转换成一个 Promise :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">   resolve(<span class="number">100</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里调用了 resolve，resolve的任务进入微任务队列。</p>
<p>然后，JS 引擎将暂停当前协程的运行，把线程的执行权交给<code>父协程</code>(父协程不懂是什么的，上上篇才讲，回去补课)。</p>
<p>回到父协程中，父协程的第一件事情就是对<code>await</code>返回的<code>Promise</code>调用<code>then</code>, 来监听这个 Promise 的状态改变 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 相关逻辑，在resolve 执行之后来调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后往下执行，打印出<code>300</code>。</p>
<p>根据<code>EventLoop</code>机制，当前主线程的宏任务完成，现在检查<code>微任务队列</code>, 发现还有一个Promise的 resolve，执行，现在父协程在<code>then</code>中传入的回调执行。我们来看看这个回调具体做的是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 将线程的执行权交给test协程</span></span><br><span class="line">  <span class="comment">// 2. 把 value 值传递给 test 协程</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Ok, 现在执行权到了<code>test协程</code>手上，test 接收到<code>父协程</code>传来的<strong>200</strong>, 赋值给 a ,然后依次执行后面的语句，打印<code>200</code>、<code>200</code>。</p>
<p>最后的输出为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>总结一下，<code>async/await</code>利用<code>协程</code>和<code>Promise</code>实现了同步方式编写异步代码的效果，其中<code>Generator</code>是对<code>协程</code>的一种实现，虽然语法简单，但引擎在背后做了大量的工作，我们也对这些工作做了一一的拆解。用<code>async/await</code>写出的代码也更加优雅、美观，相比于之前的<code>Promise</code>不断调用then的方式，语义化更加明显，相比于<code>co + Generator</code>性能更高，上手成本也更低，不愧是JS异步终极解决方案！</p>
<h2 id="第42篇-forEach-中用-await-会产生什么问题-怎么解决这个问题？"><a href="#第42篇-forEach-中用-await-会产生什么问题-怎么解决这个问题？" class="headerlink" title="第42篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？"></a>第42篇: forEach 中用 await 会产生什么问题?怎么解决这个问题？</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>问题:<strong>对于异步代码，forEach 并不能保证按顺序执行。</strong></p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">	arr.forEach(<span class="keyword">async</span> item =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> res = <span class="keyword">await</span> handle(item)</span><br><span class="line">		<span class="built_in">console</span>.log(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			resolve(x)</span><br><span class="line">		&#125;, <span class="number">1000</span> * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>我们期望的结果是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<p>但是实际上会输出:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>这是为什么呢？我想我们有必要看看<code>forEach</code>底层怎么实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心逻辑</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">    <span class="keyword">var</span> element = array[i];</span><br><span class="line">    callback(element, i, array);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，forEach 拿过来直接执行了，这就导致它无法保证异步任务的执行顺序。比如后面的任务用时短，那么就又可能抢在前面的任务之前执行。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如何来解决这个问题呢？</p>
<p>其实也很简单, 我们利用<code>for...of</code>就能轻松解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="keyword">const</span> res = <span class="keyword">await</span> handle(item)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决原理——Iterator"><a href="#解决原理——Iterator" class="headerlink" title="解决原理——Iterator"></a>解决原理——Iterator</h3><p>好了，这个问题看起来好像很简单就能搞定，你有想过这么做为什么可以成功吗？</p>
<p>其实，for…of并不像forEach那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——<code>迭代器</code>去遍历。</p>
<p>首先，对于数组来讲，它是一种<code>可迭代数据类型</code>。那什么是<code>可迭代数据类型</code>呢？</p>
<blockquote>
<p>原生具有[Symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如arguments、NodeList）、Set和Map。</p>
</blockquote>
<p>可迭代对象可以通过迭代器进行遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 这就是迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>因此，我们的代码可以这样来组织:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">  <span class="keyword">let</span> res = iterator.next();</span><br><span class="line">  <span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = res.value;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">await</span> handle(value);</span><br><span class="line">    res = iterater.next();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 结束</span></span><br></pre></td></tr></table></figure>

<p>多个任务成功地按顺序执行！其实刚刚的for…of循环代码就是这段代码的语法糖。</p>
<h3 id="重新认识生成器"><a href="#重新认识生成器" class="headerlink" title="重新认识生成器"></a>重新认识生成器</h3><p>回头再看看用iterator遍历[4,2,1]这个数组的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>咦？返回值有<code>value</code>和<code>done</code>属性，生成器也可以调用 next,返回的也是这样的数据结构，这么巧?!</p>
<p>没错，<strong>生成器</strong>本身就是一个<strong>迭代器</strong>。</p>
<p>既然属于迭代器，那它就可以用for…of遍历了吧？</p>
<p>当然没错，不信来写一个简单的斐波那契数列(50以内)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, cur] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(cur);</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    [prev, cur] = [cur, prev + cur];</span><br><span class="line">    <span class="keyword">yield</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span>(item &gt; <span class="number">50</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 34</span></span><br></pre></td></tr></table></figure>

<p>是不是非常酷炫？这就是迭代器的魅力：）同时又对<code>生成器</code>有了更深入的理解，没想到我们的老熟人<code>Generator</code>还有这样的身份。</p>
<p>以上便是本文的全部内容，希望对你有所启发。</p>
<h1 id="作者寄语"><a href="#作者寄语" class="headerlink" title="作者寄语"></a>作者寄语</h1><h2 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h2><h3 id="读者灵魂之问"><a href="#读者灵魂之问" class="headerlink" title="读者灵魂之问"></a>读者灵魂之问</h3><p>当你看到这里的时候，可能会吐槽，JS 就这么点内容吗，就这么几篇就讲完了？</p>
<p>首先我要说的是，看完这个系列，我并不能<code>保证你能掌握掉JS的所有内容</code>，我也相信没有哪一个系列会涵盖一门语言所有的知识点，而且学习本来就是一个不断循环和迭代的过程，倘若哪天你觉得自己精通了，全部了如指掌，没有必要继续学了，那才是真正的悲哀。</p>
<p>因此，如果这个系列对你能<code>产生某种启发</code>，弥补你的一部分<code>知识盲区</code>，或者对之前模糊的概念重新理解，从而有了<code>深刻的认识</code>，我觉得这些文章的价值也就真正发挥出来了。</p>
<p>另外就是这个系列还会不断的增添内容，将之前有所疏漏的地方一一补充上来，把这个系列打造得更加完整和系统，也欢迎大家给我提提后续内容方面的需求。</p>
<h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><p>在<code>前端</code>这条路摸爬滚打也有一段时间了，接下来，给大家分享一下我这些年的心得和体会吧。</p>
<p>首先，对前端来讲，不像 Java，C++这些编程领域中科班出身的人那么多，一部分原因是前端领域的知识学校基本不教，另一方面科班毕业的大部分并不想做这一块的工作。</p>
<p>这就导致<code>半路出家</code>的前端er非常多。但是也并不用气馁，我是这么觉得的:</p>
<blockquote>
<p>成为一个真正专业的人，不在于你是不是拿到了科班文凭，甚至不在于你掌握了多少亮眼的技术，而在于你的大脑中是否有<strong>完整的知识体系</strong>。</p>
</blockquote>
<p>这一点非常重要，这份知识体系相当于是你大脑中的操作系统，有了这个系统，用当今比较时髦的词来形容就是有了<code>体系化的思考能力</code>，在应对复杂的问题才会站在更高的高度对各个方面采取综合性的权衡和取舍，或者在应对新技术的时候有足够的自信和能力去快速拿下，让这个系统更加坚固，总之这个系统会在很长一段时间伴随和影响自己，如果不好好建设一下，如蜻蜓点水一般随便学一堆技术栈，或者<code>三天打鱼两天晒网</code>, 没有<strong>持续深入学习</strong>的毅力，结果就是大脑中相当于缺少一个完整的操作系统，其实是挺可悲的一件事情。以前的我总是对各种技术趋之若鹜，恨不得掌握所有的技术栈，因此也总是因为时间不够、效果不好而焦虑。最后的结论就是：从一开始关注点就错了，<strong>关注点不应在于眼花缭乱的技术，而在于自身系统的建设</strong>，这样就并不会为xxx技术我不会而感到焦虑了，相反会为自己点滴的顿悟和进步感到兴奋和满足。</p>
<p>不知道什么时候想通了这件事情，可能是以前踩过太多的坑，另外一个原因也在于本人的危机感是比较强的，才会有一系列的挣扎和思考。</p>
<p>基于以上的<code>信念</code>, 我开始了这份知识体系的建设，进度每天不断地推进，进而也就让大家能够看到眼前的原生JS灵魂之问了。这个系列的由来我应该说清楚了，可能你又要问了，不是每天进度都在推进么？那完成的东西放在哪呢？</p>
<p>OK，这就得具体介绍一下我这份知识体系了，我把它放在了GitHub上，虽然是一个并不起眼的开源项目，但是也将是凝聚我很长一段时间心血的<code>系统建设工程</code>。</p>
<p><a href="https://github.com/sanyuan0704/frontend_daily_question/blob/master/README.md" target="_blank" rel="noopener">点击查看GitHub仓库</a></p>
<p>目前的大纲梳理如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%8B-%E4%BD%9C%E8%80%85%E5%AF%84%E8%AF%AD.webp" alt></p>
<p>图中用红旗标记了已经完成的部分，即使如此，在之后也会做更多的补充，让知识结构更加完善。</p>
<p>如果这个项目对你有那么一丝启发或者帮助，也请帮忙给项目点一个<code>star</code>, 非常感谢！</p>
<p>参考文献:</p>
<p>《深入浅出nodejs》朴灵著。</p>
<p>极客时间《浏览器工作原理与实践》</p>
<p><a href="https://github.com/wangfupeng1988/js-async-tutorial" target="_blank" rel="noopener">双越《深入理解JavaScript异步》</a></p>
<p><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></p>
<p>《JavaScript高级程序设计(第三版)》</p>
<p><a href="https://yuchengkai.cn/blog/" target="_blank" rel="noopener">《yck个人博客》</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/09/原生JS-灵魂拷问-中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/09/原生JS-灵魂拷问-中/" class="post-title-link" itemprop="url">原生JS-灵魂拷问-中</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-09 22:43:07" itemprop="dateCreated datePublished" datetime="2019-12-09T22:43:07+08:00">2019-12-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-21 19:34:12" itemprop="dateModified" datetime="2019-12-21T19:34:12+08:00">2019-12-21</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原生JS-灵魂拷问-中"><a href="#原生JS-灵魂拷问-中" class="headerlink" title="原生JS-灵魂拷问-中"></a>原生JS-灵魂拷问-中</h1><h2 id="第七篇-函数的arguments为什么不是数组？如何转化成数组？"><a href="#第七篇-函数的arguments为什么不是数组？如何转化成数组？" class="headerlink" title="第七篇: 函数的arguments为什么不是数组？如何转化成数组？"></a>第七篇: 函数的arguments为什么不是数组？如何转化成数组？</h2><p>因为argument是一个对象，只不过它的属性从0开始排，依次为0，1，2…最后还有callee和length属性。我们也把这样的对象称为类数组。</p>
<p>常见的类数组还有：</p>
<ul>
<li><ul>
<li>用getElementByTagName/ClassName/Name（）获得的HTMLCollection</li>
<li>用querySlector获得的nodeList</li>
</ul>
</li>
</ul>
<p>那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？</p>
<h3 id="1-Array-prototype-slice-call"><a href="#1-Array-prototype-slice-call" class="headerlink" title="1. Array.prototype.slice.call()"></a>1. Array.prototype.slice.call()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>这种方法也可以用来转换Set和Map哦！</p>
<h3 id="3-ES6展开运算符"><a href="#3-ES6展开运算符" class="headerlink" title="3. ES6展开运算符"></a>3. ES6展开运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments]</span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-利用concat-apply"><a href="#4-利用concat-apply" class="headerlink" title="4. 利用concat+apply"></a>4. 利用concat+apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.concat.apply([], <span class="built_in">arguments</span>) <span class="comment">// appaly 方法会把第二个参数展开</span></span><br><span class="line">    <span class="built_in">console</span>.log(args.reduce(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur)) <span class="comment">// args可以调用原生数组的方法啦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>当然，最原始的方法就是再创建一个数组，用for循环把类数组的每个属性值放在里面，过于简单，就不浪费篇幅了。</p>
<h2 id="第七篇-forEach中return有效果吗？如何中断forEach循环？"><a href="#第七篇-forEach中return有效果吗？如何中断forEach循环？" class="headerlink" title="第七篇: forEach中return有效果吗？如何中断forEach循环？"></a>第七篇: forEach中return有效果吗？如何中断forEach循环？</h2><p>在forEach中用return不会返回，函数会继续执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nums.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 无效</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>中断方法：</p>
<ol>
<li>使用try监视代码块，在需要中断的地方抛出异常。</li>
<li>官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return ture的时候，中止循环</li>
</ol>
<h2 id="第八篇-JS判断数组中是否包含某个值"><a href="#第八篇-JS判断数组中是否包含某个值" class="headerlink" title="第八篇: JS判断数组中是否包含某个值"></a>第八篇: JS判断数组中是否包含某个值</h2><h3 id="方法一：array-indexOf"><a href="#方法一：array-indexOf" class="headerlink" title="方法一：array.indexOf"></a>方法一：array.indexOf</h3><blockquote>
<p>此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> index = arr.indexOf(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二：array-includes-searcElement-fromIndex"><a href="#方法二：array-includes-searcElement-fromIndex" class="headerlink" title="方法二：array.includes(searcElement[,fromIndex])"></a>方法二：array.includes(searcElement[,fromIndex])</h3><p>此方法判断数组中是否存在某个值，如果存在返回true，否则返回false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'存在'</span>)  <span class="comment">//存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'不存在'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：array-find-callback-thisArg"><a href="#方法三：array-find-callback-thisArg" class="headerlink" title="方法三：array.find(callback[,thisArg])"></a>方法三：array.find(callback[,thisArg])</h3><p>返回数组中满足条件的<strong>第一个元素的值</strong>，如果没有，返回undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="方法四：array-findeIndex-callback-thisArg"><a href="#方法四：array-findeIndex-callback-thisArg" class="headerlink" title="方法四：array.findeIndex(callback[,thisArg])"></a>方法四：array.findeIndex(callback[,thisArg])</h3><p>返回数组中满足条件的第一个元素的下标，如果没有找到，返回 <code>-1</code>]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> result = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>当然，for循环当然是没有问题的，这里讨论的是数组方法，就不再展开了。</p>
<h2 id="第九篇-JS中flat—数组扁平化"><a href="#第九篇-JS中flat—数组扁平化" class="headerlink" title="第九篇: JS中flat—数组扁平化"></a>第九篇: JS中flat—数组扁平化</h2><p>对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？</p>
<p>需求:多维数组=&gt;一维数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]],<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(arr)</span><br></pre></td></tr></table></figure>

<h3 id="1-调用ES6中的flat方法"><a href="#1-调用ES6中的flat方法" class="headerlink" title="1. 调用ES6中的flat方法"></a>1. 调用ES6中的flat方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-replace-split"><a href="#2-replace-split" class="headerlink" title="2. replace + split"></a>2. replace + split</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-replace-JSON-parse"><a href="#3-replace-JSON-parse" class="headerlink" title="3. replace + JSON.parse"></a>3. replace + JSON.parse</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>)</span><br><span class="line"><span class="keyword">let</span> ary1 = <span class="string">'['</span> + ary + <span class="string">']'</span></span><br><span class="line">res = <span class="built_in">JSON</span>.parse(ary1)</span><br></pre></td></tr></table></figure>

<h3 id="4-普通递归"><a href="#4-普通递归" class="headerlink" title="4. 普通递归"></a>4. 普通递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">ary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = ary[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            fn(item)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(arr)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>

<h3 id="5-利用reduce函数迭代"><a href="#5-利用reduce函数迭代" class="headerlink" title="5. 利用reduce函数迭代"></a>5. 利用reduce函数迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">ary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ary.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure>

<h3 id="6：扩展运算符"><a href="#6：扩展运算符" class="headerlink" title="6：扩展运算符"></a>6：扩展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]],<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(arr.some(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">Array</span>.isArray(_))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="第十篇-JS数组的高阶函数——基础篇"><a href="#第十篇-JS数组的高阶函数——基础篇" class="headerlink" title="第十篇: JS数组的高阶函数——基础篇"></a>第十篇: JS数组的高阶函数——基础篇</h2><h3 id="1-什么是高阶函数"><a href="#1-什么是高阶函数" class="headerlink" title="1.什么是高阶函数"></a>1.什么是高阶函数</h3><p>概念非常简单，如下:</p>
<blockquote>
<p><code>一个函数</code>就可以接收另一个函数作为参数或者返回值为一个函数， <code>这种函数</code>就称之为高阶函数。</p>
</blockquote>
<p>那对应到数组中有哪些方法呢？</p>
<h3 id="2-数组中的高阶函数"><a href="#2-数组中的高阶函数" class="headerlink" title="2.数组中的高阶函数"></a>2.数组中的高阶函数</h3><h4 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h4><ul>
<li><input checked disabled type="checkbox"> 参数:接受两个参数，一个是回调函数，一个是回调函数的this值(可选)。</li>
</ul>
<p>其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。</p>
<ul>
<li><input checked disabled type="checkbox"> 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果</li>
<li><input checked disabled type="checkbox"> 对原来的数组没有影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">val</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newNums = nums.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item + index + array[index] + <span class="keyword">this</span>.val</span><br><span class="line">    <span class="comment">// 对第一个元素， 1 + 0 + 1 + 5 = 7</span></span><br><span class="line">    <span class="comment">// 对第二个元素， 2 + 1 + 2 + 5 = 10</span></span><br><span class="line">    <span class="comment">// 对第三个元素， 3 + 2 + 3 + 5 = 13 </span></span><br><span class="line">&#125;, obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums) <span class="comment">// 7, 10, 3</span></span><br></pre></td></tr></table></figure>

<p>当然，后面的参数都是可选的 ，不用的话可以省略。</p>
<h4 id="2-reduce"><a href="#2-reduce" class="headerlink" title="2. reduce"></a>2. reduce</h4><ul>
<li><input checked disabled type="checkbox"> <p>参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中三个默认参数，依次为积累值、当前值、整个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 多个数的加和</span></span><br><span class="line"><span class="keyword">let</span> newNums = nums.reduce(<span class="function">(<span class="params">pre, cur, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums)</span><br></pre></td></tr></table></figure>

<p>不传默认值会怎样？</p>
<p>不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。</p>
</li>
</ul>
<h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter"></a>3. filter</h4><p>参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。</p>
<p>filter方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 保留奇数项</span></span><br><span class="line"><span class="keyword">let</span> oldNums = nums.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(oldNums)  <span class="number">1</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="4-sort"><a href="#4-sort" class="headerlink" title="4. sort"></a>4. sort</h4><p>参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 两个比较的元素分别为a, b</span></span><br><span class="line"><span class="keyword">const</span> res = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>

<p>当比较函数返回值大于0，则 a 在 b 的后面，即a的下标应该比b大。</p>
<p>反之，则 a 在 b 的后面，即 a 的下标比 b 小。</p>
<p>整个过程就完成了一次升序的排列。</p>
<p>当然还有一个需要注意的情况，就是比较函数不传的时候，是如何进行排序的？</p>
<blockquote>
<p>答案是将数字转换为字符串，然后根据字母unicode值进行升序排序，也就是根据字符串的比较规则进行升序排序。</p>
</blockquote>
<h2 id="第十一篇-能不能手动实现数组的map方法"><a href="#第十一篇-能不能手动实现数组的map方法" class="headerlink" title="第十一篇: 能不能手动实现数组的map方法 ?"></a>第十一篇: 能不能手动实现数组的map方法 ?</h2><p>依照 <a href="https://tc39.es/ecma262/#sec-array.prototype.map" target="_blank" rel="noopener">ecma262 草案</a>，实现的map的规范如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-map.webp" alt></p>
<p>下面根据草案的规定一步步来模拟实现map函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">callbackFn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot read property 'map' of null or undefined"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 草案中提到要先转换为对象</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> T = thisArg;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="comment">// 还记得原型链那一节提到的 in 吗？in 表示在原型链查找</span></span><br><span class="line">    <span class="comment">// 如果用 hasOwnProperty 是有问题的，它只能找私有属性</span></span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = O[k];</span><br><span class="line">      <span class="comment">// 依次传入this, 当前项，当前索引，整个数组</span></span><br><span class="line">      <span class="keyword">let</span> mappedValue = callbackfn.call(T, KValue, k, O);</span><br><span class="line">      A[k] = mappedValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下, length &gt;&gt;&gt; 0, 字面意思是指”右移 0 位”，但实际上是把前面的空位用0填充，这里的作用是保证len为数字且为整数。</p>
<p>举几个特例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>) &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;;  a &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">[] &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;; a &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="number">123123</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//123123</span></span><br><span class="line"></span><br><span class="line"><span class="number">45.2</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//45</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="number">-0</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="number">-1</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="number">-1212</span> &gt;&gt;&gt; <span class="number">0</span>  <span class="comment">//4294966084</span></span><br></pre></td></tr></table></figure>

<p>总体实现起来并没那么难，需要注意的就是使用 in 来进行原型链查找。同时，如果没有找到就不处理，能有效处理稀疏数组的情况。</p>
<p>最后给大家奉上V8源码，参照源码检查一下，其实还是实现得很完整了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayMap</span>(<span class="params">f, receiver</span>) </span>&#123;</span><br><span class="line">  CHECK_OBJECT_COERCIBLE(<span class="keyword">this</span>, <span class="string">"Array.prototype.map"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pull out the length so that modifications to the length in the</span></span><br><span class="line">  <span class="comment">// loop will not affect the looping and side effects are visible.</span></span><br><span class="line">  <span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> length = TO_LENGTH(array.length);</span><br><span class="line">  <span class="keyword">if</span> (!IS_CALLABLE(f)) <span class="keyword">throw</span> %make_type_error(kCalledNonCallable, f);</span><br><span class="line">  <span class="keyword">var</span> result = ArraySpeciesCreate(array, length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">var</span> element = array[i];</span><br><span class="line">      %CreateDataProperty(result, i, %_Call(f, receiver, element, i, array));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L1132" target="_blank" rel="noopener">V8源码</a></p>
<p><a href="https://juejin.im/post/5d76f08ef265da03970be192#comment" target="_blank" rel="noopener">Array 原型方法源码实现大揭秘</a></p>
<p><a href="https://tc39.es/ecma262/#sec-array.prototype.map" target="_blank" rel="noopener">ecma262草案</a></p>
<h2 id="第十二篇-能不能手动实现数组的reduce方法"><a href="#第十二篇-能不能手动实现数组的reduce方法" class="headerlink" title="第十二篇: 能不能手动实现数组的reduce方法 ?"></a>第十二篇: 能不能手动实现数组的reduce方法 ?</h2><p>依照 <a href="https://tc39.es/ecma262/#sec-array.prototype.reduce" target="_blank" rel="noopener">ecma262 草案</a>，实现的reduce的规范如下:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/reduce.webp" alt></p>
<p>其中有几个核心要点:</p>
<p>1、初始值不传怎么处理</p>
<p>2、回调函数的参数有哪些，返回值如何处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce  = <span class="function"><span class="keyword">function</span>(<span class="params">callbackfn, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异常处理，和 map 一样</span></span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot read property 'reduce' of null or undefined"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue;</span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(; k &lt; len ; k++) &#123;</span><br><span class="line">      <span class="comment">// 查找原型链</span></span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        accumulator = O[k];</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 表示数组全为空</span></span><br><span class="line">  <span class="keyword">if</span>(k === len &amp;&amp; accumulator === <span class="literal">undefined</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Each element of the array is empty'</span>);</span><br><span class="line">  <span class="keyword">for</span>(;k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="comment">// 注意，核心！</span></span><br><span class="line">      accumulator = callbackfn.call(<span class="literal">undefined</span>, accumulator, O[k], k, O);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是从最后一项开始遍历，通过原型链查找跳过空项。</p>
<p>最后给大家奉上V8源码，以供大家检查:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayReduce</span>(<span class="params">callback, current</span>) </span>&#123;</span><br><span class="line">  CHECK_OBJECT_COERCIBLE(<span class="keyword">this</span>, <span class="string">"Array.prototype.reduce"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pull out the length so that modifications to the length in the</span></span><br><span class="line">  <span class="comment">// loop will not affect the looping and side effects are visible.</span></span><br><span class="line">  <span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> length = TO_LENGTH(array.length);</span><br><span class="line">  <span class="keyword">return</span> InnerArrayReduce(callback, current, array, length,</span><br><span class="line">                          <span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InnerArrayReduce</span>(<span class="params">callback, current, array, length, argumentsLength</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!IS_CALLABLE(callback)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> %make_type_error(kCalledNonCallable, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  find_initial: <span class="keyword">if</span> (argumentsLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">        current = array[i++];</span><br><span class="line">        <span class="keyword">break</span> find_initial;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> %make_type_error(kReduceNoInitial);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">var</span> element = array[i];</span><br><span class="line">      current = callback(current, element, i, array);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L1132" target="_blank" rel="noopener">V8源码</a></p>
<p><a href="https://tc39.es/ecma262/#sec-array.prototype.map" target="_blank" rel="noopener">ecma262草案</a></p>
<h2 id="第十四篇-能不能实现数组-push、pop-方法"><a href="#第十四篇-能不能实现数组-push、pop-方法" class="headerlink" title="第十四篇: 能不能实现数组 push、pop 方法 ?"></a>第十四篇: 能不能实现数组 push、pop 方法 ?</h2><p>参照 ecma262 草案的规定，关于 push 和 pop 的规范如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-push%E5%92%8Cpop.webp" alt></p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-push%E5%92%8Cpop2.webp" alt></p>
<p>首先来实现一下 push 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">...items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> argCount = items.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 2 ** 53 - 1 为JS能表示的最大正整数</span></span><br><span class="line">  <span class="keyword">if</span> (len + argCount &gt; <span class="number">2</span> ** <span class="number">53</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"The number of array is over the max value restricted!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; argCount; i++) &#123;</span><br><span class="line">    O[len + i] = items[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newLength = len + argCount;</span><br><span class="line">  O.length = newLength;</span><br><span class="line">  <span class="keyword">return</span> newLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>亲测已通过MDN上所有测试用例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">MDN链接</a></p>
<p>然后来实现 pop 方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">    O.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  len --;</span><br><span class="line">  <span class="keyword">let</span> value = O[len];</span><br><span class="line">  <span class="keyword">delete</span> O[len];</span><br><span class="line">  O.length = len;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>亲测已通过MDN上所有测试用例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">MDN链接</a></p>
<p>参考链接:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener">V8数组源码</a></p>
<p><a href="https://tc39.es/ecma262" target="_blank" rel="noopener">ecma262规范草案</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">MDN文档</a></p>
<h2 id="第十五篇-能不能实现数组filter方法"><a href="#第十五篇-能不能实现数组filter方法" class="headerlink" title="第十五篇: 能不能实现数组filter方法 ?"></a>第十五篇: 能不能实现数组filter方法 ?</h2><p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-filter.webp" alt></p>
<p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span>(<span class="params">callbackfn, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span> || <span class="keyword">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot read property 'filter' of null or undefined"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) != <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callbackfn + <span class="string">' is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> resLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = O[i];</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.call(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res[resLen++] = element;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MDN上所有测试用例亲测通过。</p>
<p>参考:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener">V8数组部分源码第1025行</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">MDN中filter文档</a></p>
<h2 id="第十六篇-能不能实现数组splice方法"><a href="#第十六篇-能不能实现数组splice方法" class="headerlink" title="第十六篇: 能不能实现数组splice方法 ?"></a>第十六篇: 能不能实现数组splice方法 ?</h2><p>splice 可以说是最受欢迎的数组方法之一，api 灵活，使用方便。现在来梳理一下用法:</p>
<ul>
<li><ol>
<li>splice(position, count) 表示从 position 索引的位置开始，删除count个元素</li>
</ol>
</li>
<li><ol>
<li>splice(position, 0, ele1, ele2, …) 表示从 position 索引的元素后面插入一系列的元素</li>
</ol>
</li>
<li><ol>
<li>splice(postion, count, ele1, ele2, …) 表示从 position 索引的位置开始，删除 count 个元素，然后再插入一系列的元素</li>
</ol>
</li>
<li><ol>
<li>返回值为<code>被删除元素</code>组成的<code>数组</code>。</li>
</ol>
</li>
</ul>
<p>接下来我们实现这个方法。</p>
<p>参照ecma262草案的规定，详情请<a href="https://tc39.es/ecma262/#sec-array.prototype.splice" target="_blank" rel="noopener">点击</a>。</p>
<p>首先我们梳理一下实现的思路。</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-splice.webp" alt></p>
<h3 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice = <span class="function"><span class="keyword">function</span>(<span class="params">startIndex, deleteCount, ...addElements</span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> argumentsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = array.length;</span><br><span class="line">  <span class="keyword">let</span> deleteArr = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);</span><br><span class="line">  <span class="comment">// 移动删除元素后面的元素</span></span><br><span class="line">  movePostElements(array, startIndex, len, deleteCount, addElements);</span><br><span class="line">  <span class="comment">// 插入新元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; addElements.length; i++) &#123;</span><br><span class="line">    array[startIndex + i] = addElements[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array.length = len - deleteCount + addElements.length;</span><br><span class="line">  <span class="keyword">return</span> deleteArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先拷贝删除的元素，如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceDeleteElements = <span class="function">(<span class="params">array, startIndex, deleteCount, deleteArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = startIndex + i;</span><br><span class="line">    <span class="keyword">if</span> (index <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = array[index];</span><br><span class="line">      deleteArr[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对删除元素后面的元素进行挪动, 挪动分为三种情况:</p>
<ol>
<li>添加的元素和删除的元素个数相等</li>
<li>添加的元素个数小于删除的元素</li>
<li>添加的元素个数大于删除的元素</li>
</ol>
<p>当两者相等时，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (deleteCount === addElements.length) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当添加的元素个数小于删除的元素时, 如图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-splice2.webp" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 如果添加的元素和删除的元素个数不相等，则移动后面的元素</span></span><br><span class="line">  <span class="keyword">if</span>(deleteCount &gt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素多，那么后面的元素整体向前挪动</span></span><br><span class="line">    <span class="comment">// 一共需要挪动 len - startIndex - deleteCount 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex + deleteCount; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i - (deleteCount - addElements.length);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素</span></span><br><span class="line">    <span class="comment">// 目前长度为 len + addElements - deleteCount</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= len + addElements.length - deleteCount; i --) &#123;</span><br><span class="line">      <span class="keyword">delete</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当添加的元素个数大于删除的元素时, 如图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-splice3.webp" alt></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span>(deleteCount &lt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素少，那么后面的元素整体向后挪动</span></span><br><span class="line">    <span class="comment">// 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= startIndex + deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i + (addElements.length - deleteCount);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="优化一-参数的边界情况"><a href="#优化一-参数的边界情况" class="headerlink" title="优化一: 参数的边界情况"></a>优化一: 参数的边界情况</h3><p>当用户传来非法的 startIndex 和 deleteCount 或者负索引的时候，需要我们做出特殊的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computeStartIndex = <span class="function">(<span class="params">startIndex, len</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理索引负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> startIndex + len &gt; <span class="number">0</span> ? startIndex + len: <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> startIndex &gt;= len ? len: startIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeDeleteCount = <span class="function">(<span class="params">startIndex, len, deleteCount, argumentsLen</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除数目没有传，默认删除startIndex及后面所有的</span></span><br><span class="line">  <span class="keyword">if</span> (argumentsLen === <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="comment">// 删除数目过小</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 删除数目过大</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; len - startIndex) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="keyword">return</span> deleteCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice = <span class="function"><span class="keyword">function</span> (<span class="params">startIndex, deleteCount, ...addElements</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//,...</span></span><br><span class="line">  <span class="keyword">let</span> deleteArr = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面参数的清洗工作</span></span><br><span class="line">  startIndex = computeStartIndex(startIndex, len);</span><br><span class="line">  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化二-数组为密封对象或冻结对象"><a href="#优化二-数组为密封对象或冻结对象" class="headerlink" title="优化二: 数组为密封对象或冻结对象"></a>优化二: 数组为密封对象或冻结对象</h3><p>什么是密封对象?</p>
<blockquote>
<p>密封对象是不可扩展的对象，而且已有成员的[[Configurable]]属性被设置为false，这意味着不能添加、删除方法和属性。但是属性值是可以修改的。</p>
</blockquote>
<p>什么是冻结对象？</p>
<blockquote>
<p>冻结对象是最严格的防篡改级别，除了包含密封对象的限制外，还不能修改属性值。</p>
</blockquote>
<p>接下来，我们来把这两种情况一一排除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.isSealed(array) &amp;&amp; deleteCount !== addElements.length) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a sealed object!'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.isFrozen(array) &amp;&amp; (deleteCount &gt; <span class="number">0</span> || addElements.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a frozen object!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在就写了一个比较完整的splice，如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliceDeleteElements = <span class="function">(<span class="params">array, startIndex, deleteCount, deleteArr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = startIndex + i;</span><br><span class="line">    <span class="keyword">if</span> (index <span class="keyword">in</span> array) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = array[index];</span><br><span class="line">      deleteArr[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> movePostElements = <span class="function">(<span class="params">array, startIndex, len, deleteCount, addElements</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果添加的元素和删除的元素个数相等，相当于元素的替换，数组长度不变，被删除元素后面的元素不需要挪动</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount === addElements.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 如果添加的元素和删除的元素个数不相等，则移动后面的元素</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(deleteCount &gt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素多，那么后面的元素整体向前挪动</span></span><br><span class="line">    <span class="comment">// 一共需要挪动 len - startIndex - deleteCount 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex + deleteCount; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i - (deleteCount - addElements.length);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意注意！这里我们把后面的元素向前挪，相当于数组长度减小了，需要删除冗余元素</span></span><br><span class="line">    <span class="comment">// 目前长度为 len + addElements - deleteCount</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= len + addElements.length - deleteCount; i --) &#123;</span><br><span class="line">      <span class="keyword">delete</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(deleteCount &lt; addElements.length) &#123;</span><br><span class="line">    <span class="comment">// 删除的元素比新增的元素少，那么后面的元素整体向后挪动</span></span><br><span class="line">    <span class="comment">// 思考一下: 这里为什么要从后往前遍历？从前往后会产生什么问题？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= startIndex + deleteCount; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> fromIndex = i;</span><br><span class="line">      <span class="comment">// 将要挪动到的目标位置</span></span><br><span class="line">      <span class="keyword">let</span> toIndex = i + (addElements.length - deleteCount);</span><br><span class="line">      <span class="keyword">if</span> (fromIndex <span class="keyword">in</span> array) &#123;</span><br><span class="line">        array[toIndex] = array[fromIndex];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> array[toIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeStartIndex = <span class="function">(<span class="params">startIndex, len</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理索引负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> startIndex + len &gt; <span class="number">0</span> ? startIndex + len: <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> startIndex &gt;= len ? len: startIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computeDeleteCount = <span class="function">(<span class="params">startIndex, len, deleteCount, argumentsLen</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除数目没有传，默认删除startIndex及后面所有的</span></span><br><span class="line">  <span class="keyword">if</span> (argumentsLen === <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="comment">// 删除数目过小</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 删除数目过大</span></span><br><span class="line">  <span class="keyword">if</span> (deleteCount &gt; len - startIndex) </span><br><span class="line">    <span class="keyword">return</span> len - startIndex;</span><br><span class="line">  <span class="keyword">return</span> deleteCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice = <span class="function"><span class="keyword">function</span>(<span class="params">startIndex, deleteCount, ...addElements</span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> argumentsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> len = array.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> deleteArr = <span class="keyword">new</span> <span class="built_in">Array</span>(deleteCount);</span><br><span class="line"></span><br><span class="line">  startIndex = computeStartIndex(startIndex, len);</span><br><span class="line">  deleteCount = computeDeleteCount(startIndex, len, deleteCount, argumentsLen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 sealed 对象和 frozen 对象, 即 密封对象 和 冻结对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.isSealed(array) &amp;&amp; deleteCount !== addElements.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a sealed object!'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.isFrozen(array) &amp;&amp; (deleteCount &gt; <span class="number">0</span> || addElements.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'the object is a frozen object!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 拷贝删除的元素</span></span><br><span class="line">  sliceDeleteElements(array, startIndex, deleteCount, deleteArr);</span><br><span class="line">  <span class="comment">// 移动删除元素后面的元素</span></span><br><span class="line">  movePostElements(array, startIndex, len, deleteCount, addElements);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入新元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; addElements.length; i++) &#123;</span><br><span class="line">    array[startIndex + i] = addElements[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  array.length = len - deleteCount + addElements.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> deleteArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对照<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">MDN文档</a>中的所有测试用例亲测通过。</p>
<p>相关测试代码请前往: <a href="https://github.com/sanyuan0704/frontend_daily_question/blob/master/test_splice.js" target="_blank" rel="noopener">传送门</a></p>
<p>最后给大家奉上V8源码，供大家检查： <a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#L660" target="_blank" rel="noopener">V8数组 splice 源码第 660 行</a></p>
<h2 id="第十七篇-能不能实现数组sort方法？"><a href="#第十七篇-能不能实现数组sort方法？" class="headerlink" title="第十七篇: 能不能实现数组sort方法？"></a>第十七篇: 能不能实现数组sort方法？</h2><p>估计大家对 JS 数组的sort 方法已经不陌生了，之前也对它的用法做了详细的总结。那，它的内部是如何来实现的呢？如果说我们能够进入它的内部去看一看， 理解背后的设计，会使我们的思维和素养得到不错的提升。</p>
<p>sort 方法在 V8 内部相对与其他方法而言是一个比较高深的算法，对于很多边界情况做了反复的优化，但是这里我们不会直接拿源码来干讲。我们会来根据源码的思路，实现一个 跟引擎性能<strong>一样</strong>的排序算法，并且一步步拆解其中的奥秘。</p>
<h3 id="V8-引擎的思路分析"><a href="#V8-引擎的思路分析" class="headerlink" title="V8 引擎的思路分析"></a>V8 引擎的思路分析</h3><p>首先大概梳理一下源码中排序的思路:</p>
<p>设要排序的元素个数是n：</p>
<p>当 n &lt;= 10 时，采用<code>插入排序</code></p>
<p>当 n &gt; 10 时，采用<code>三路快速排序</code></p>
<ul>
<li>10 &lt; n &lt;= 1000, 采用中位数作为哨兵元素</li>
<li>n &gt; 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数</li>
</ul>
<p>在动手之前，我觉得我们有必要<strong>为什么</strong>这么做搞清楚。</p>
<p>第一、为什么元素个数少的时候要采用插入排序？</p>
<p>虽然<code>插入排序</code>理论上说是O(n^2)的算法，<code>快速排序</code>是一个O(nlogn)级别的算法。但是别忘了，这只是理论上的估算，在实际情况中两者的算法复杂度前面都会有一个系数的， 当 n 足够小的时候，快速排序<code>nlogn</code>的优势会越来越小，倘若插入排序O(n^2)前面的系数足够小，那么就会超过快排。而事实上正是如此，<code>插入排序</code>经过优化以后对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。</p>
<p>因此，对于很小的数据量，应用<code>插入排序</code>是一个非常不错的选择。</p>
<p>第二、为什么要花这么大的力气选择哨兵元素？</p>
<p>因为<code>快速排序</code>的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行partition(一边是小于哨兵的元素，另一边是大于哨兵的元素)时，就会有一边是空的，那么这么排下去，递归的层数就达到了n, 而每一层的复杂度是O(n)，因此快排这时候会退化成O(n^2)级别。</p>
<p>这种情况是要尽力避免的！如果来避免？</p>
<p>就是让哨兵元素进可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的种种优化了。</p>
<p>接下来，我们来一步步实现的这样的官方排序算法。</p>
<h3 id="插入排序及优化"><a href="#插入排序及优化" class="headerlink" title="插入排序及优化"></a>插入排序及优化</h3><p>最初的插入排序可能是这样写的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">  end = end || arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; arr[j]; j --) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">      arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看似可以正确的完成排序，但实际上交换元素会有相当大的性能消耗，我们完全可以用变量覆盖的方式来完成，如图所示:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort1.webp" alt></p>
<p>优化后代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">  end = end || arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> e = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = i; j &gt; start &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j --)</span><br><span class="line">      arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">    arr[j] = e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来正式进入到 sort 方法。</p>
<h3 id="寻找哨兵元素"><a href="#寻找哨兵元素" class="headerlink" title="寻找哨兵元素"></a>寻找哨兵元素</h3><p>sort的骨架大致如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sort = <span class="function">(<span class="params">comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">let</span> length = array.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> InnerArraySort(array, length, comparefn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InnerArraySort = <span class="function">(<span class="params">array, length, comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 比较函数未传入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callbackfn) !== <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x === y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      x = x.toString();</span><br><span class="line">      y = y.toString();</span><br><span class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> insertSort = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> getThirdIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数大于1000时寻找哨兵元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//哨兵位置</span></span><br><span class="line">    <span class="keyword">let</span> thirdIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(to - <span class="keyword">from</span> &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        insertSort(a, <span class="keyword">from</span>, to);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(to - <span class="keyword">from</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        thirdIndex = getThirdIndex(a, <span class="keyword">from</span> , to);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于1000 直接取中点</span></span><br><span class="line">        thirdIndex = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面开始快排</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来把求取哨兵位置的代码实现一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getThirdIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmpArr = [];</span><br><span class="line">  <span class="comment">// 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的</span></span><br><span class="line">  <span class="keyword">let</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">from</span> += <span class="number">1</span>;</span><br><span class="line">  to -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">    tmpArr[j] = [i, a[i]];</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把临时数组排序，取中间的值，确保哨兵的值接近平均位置</span></span><br><span class="line">  tmpArr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> thirdIndex = tmpArr[tmpArr.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> thirdIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成快排"><a href="#完成快排" class="headerlink" title="完成快排"></a>完成快排</h3><p>接下来我们来完成快排的具体代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _sort = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [a, b, c];</span><br><span class="line">  insertSort(arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 上面我们拿到了thirdIndex</span></span><br><span class="line">  <span class="comment">// 现在我们拥有三个元素，from, thirdIndex, to</span></span><br><span class="line">  <span class="comment">// 为了再次确保 thirdIndex 不是最值，把这三个值排序</span></span><br><span class="line">  [a[<span class="keyword">from</span>], a[thirdIndex], a[to - <span class="number">1</span>]] = _sort(a[<span class="keyword">from</span>], a[thirdIndex], a[to - <span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 现在正式把 thirdIndex 作为哨兵</span></span><br><span class="line">  <span class="keyword">let</span> pivot = a[thirdIndex];</span><br><span class="line">  <span class="comment">// 正式进入快排</span></span><br><span class="line">  <span class="keyword">let</span> lowEnd = <span class="keyword">from</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> highStart = to - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 现在正式把 thirdIndex 作为哨兵, 并且lowEnd和thirdIndex交换</span></span><br><span class="line">  <span class="keyword">let</span> pivot = a[thirdIndex];</span><br><span class="line">  a[thirdIndex] = a[lowEnd];</span><br><span class="line">  a[lowEnd] = pivot;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// [lowEnd, i)的元素是和pivot相等的</span></span><br><span class="line">  <span class="comment">// [i, highStart) 的元素是需要处理的</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = lowEnd + <span class="number">1</span>; i &lt; highStart; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> element = a[i];</span><br><span class="line">    <span class="keyword">let</span> order = comparefn(element, pivot);</span><br><span class="line">    <span class="keyword">if</span> (order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      a[i] = a[lowEnd];</span><br><span class="line">      a[lowEnd] = element;</span><br><span class="line">      lowEnd++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(order &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">        highStart--;</span><br><span class="line">        <span class="keyword">if</span>(highStart === i) <span class="keyword">break</span>;</span><br><span class="line">        order = comparefn(a[highStart], pivot);</span><br><span class="line">      &#125;<span class="keyword">while</span>(order &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 现在 a[highStart] &lt;= pivot</span></span><br><span class="line">      <span class="comment">// a[i] &gt; pivot</span></span><br><span class="line">      <span class="comment">// 两者交换</span></span><br><span class="line">      a[i] = a[highStart];</span><br><span class="line">      a[highStart] = element;</span><br><span class="line">      <span class="keyword">if</span>(order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// a[i] 和 a[lowEnd] 交换</span></span><br><span class="line">        element = a[i];</span><br><span class="line">        a[i] = a[lowEnd];</span><br><span class="line">        a[lowEnd] = element;</span><br><span class="line">        lowEnd++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 永远切分大区间</span></span><br><span class="line">  <span class="keyword">if</span> (lowEnd - <span class="keyword">from</span> &gt; to - highStart) &#123;</span><br><span class="line">    <span class="comment">// 继续切分lowEnd ~ from 这个区间</span></span><br><span class="line">    to = lowEnd;</span><br><span class="line">    <span class="comment">// 单独处理小区间</span></span><br><span class="line">    quickSort(a, highStart, to);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(lowEnd - <span class="keyword">from</span> &lt;= to - highStart) &#123;</span><br><span class="line">    <span class="keyword">from</span> = highStart;</span><br><span class="line">    quickSort(a, <span class="keyword">from</span>, lowEnd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试结果如下:</p>
<p>一万条数据:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort2.webp" alt></p>
<p>一百万条数据:</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort3.webp" alt></p>
<p>一千万条数据：</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/js%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE%E4%B8%AD-sort4.webp" alt></p>
<p>结果仅供大家参考，因为不同的node版本对于部分细节的实现可能不一样，我现在的版本是v10.15。</p>
<p>从结果可以看到，目前版本的 node 对于有序程度较高的数据是处理的不够好的，而我们刚刚实现的排序通过反复确定哨兵的位置就能 有效的规避快排在这一场景下的劣势。</p>
<p>最后给大家完整版的sort代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="function">(<span class="params">arr, comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="built_in">Object</span>(arr);</span><br><span class="line">  <span class="keyword">let</span> length = array.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> InnerArraySort(array, length, comparefn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InnerArraySort = <span class="function">(<span class="params">array, length, comparefn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 比较函数未传入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(comparefn) !== <span class="string">"[object Function]"</span>) &#123;</span><br><span class="line">    comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x === y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      x = x.toString();</span><br><span class="line">      y = y.toString();</span><br><span class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> insertSort = <span class="function">(<span class="params">arr, start = <span class="number">0</span>, end</span>) =&gt;</span> &#123;</span><br><span class="line">    end = end || arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> e = arr[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = i; j &gt; start &amp;&amp; comparefn(arr[j - <span class="number">1</span>], e) &gt; <span class="number">0</span>; j--)</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">      arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> getThirdIndex = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmpArr = [];</span><br><span class="line">    <span class="comment">// 递增量，200~215 之间，因为任何正数和15做与操作，不会超过15，当然是大于0的</span></span><br><span class="line">    <span class="keyword">let</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">from</span> += <span class="number">1</span>;</span><br><span class="line">    to -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">      tmpArr[j] = [i, a[i]];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把临时数组排序，取中间的值，确保哨兵的值接近平均位置</span></span><br><span class="line">    tmpArr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> thirdIndex = tmpArr[tmpArr.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> thirdIndex;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _sort = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    arr.push(a, b, c);</span><br><span class="line">    insertSort(arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> quickSort = <span class="function">(<span class="params">a, <span class="keyword">from</span>, to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//哨兵位置</span></span><br><span class="line">    <span class="keyword">let</span> thirdIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (to - <span class="keyword">from</span> &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        insertSort(a, <span class="keyword">from</span>, to);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (to - <span class="keyword">from</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        thirdIndex = getThirdIndex(a, <span class="keyword">from</span>, to);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于1000 直接取中点</span></span><br><span class="line">        thirdIndex = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> tmpArr = _sort(a[<span class="keyword">from</span>], a[thirdIndex], a[to - <span class="number">1</span>]);</span><br><span class="line">      a[<span class="keyword">from</span>] = tmpArr[<span class="number">0</span>]; a[thirdIndex] = tmpArr[<span class="number">1</span>]; a[to - <span class="number">1</span>] = tmpArr[<span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 现在正式把 thirdIndex 作为哨兵</span></span><br><span class="line">      <span class="keyword">let</span> pivot = a[thirdIndex];</span><br><span class="line">      [a[<span class="keyword">from</span>], a[thirdIndex]] = [a[thirdIndex], a[<span class="keyword">from</span>]];</span><br><span class="line">      <span class="comment">// 正式进入快排</span></span><br><span class="line">      <span class="keyword">let</span> lowEnd = <span class="keyword">from</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> highStart = to - <span class="number">1</span>;</span><br><span class="line">      a[thirdIndex] = a[lowEnd];</span><br><span class="line">      a[lowEnd] = pivot;</span><br><span class="line">      <span class="comment">// [lowEnd, i)的元素是和pivot相等的</span></span><br><span class="line">      <span class="comment">// [i, highStart) 的元素是需要处理的</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = lowEnd + <span class="number">1</span>; i &lt; highStart; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> element = a[i];</span><br><span class="line">        <span class="keyword">let</span> order = comparefn(element, pivot);</span><br><span class="line">        <span class="keyword">if</span> (order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          a[i] = a[lowEnd];</span><br><span class="line">          a[lowEnd] = element;</span><br><span class="line">          lowEnd++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (order &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">do</span>&#123;</span><br><span class="line">            highStart--;</span><br><span class="line">            <span class="keyword">if</span> (highStart === i) <span class="keyword">break</span>;</span><br><span class="line">            order = comparefn(a[highStart], pivot);</span><br><span class="line">          &#125;<span class="keyword">while</span> (order &gt; <span class="number">0</span>) ;</span><br><span class="line">          <span class="comment">// 现在 a[highStart] &lt;= pivot</span></span><br><span class="line">          <span class="comment">// a[i] &gt; pivot</span></span><br><span class="line">          <span class="comment">// 两者交换</span></span><br><span class="line">          a[i] = a[highStart];</span><br><span class="line">          a[highStart] = element;</span><br><span class="line">          <span class="keyword">if</span> (order &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// a[i] 和 a[lowEnd] 交换</span></span><br><span class="line">            element = a[i];</span><br><span class="line">            a[i] = a[lowEnd];</span><br><span class="line">            a[lowEnd] = element;</span><br><span class="line">            lowEnd++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 永远切分大区间</span></span><br><span class="line">      <span class="keyword">if</span> (lowEnd - <span class="keyword">from</span> &gt; to - highStart) &#123;</span><br><span class="line">        <span class="comment">// 单独处理小区间</span></span><br><span class="line">        quickSort(a, highStart, to);</span><br><span class="line">        <span class="comment">// 继续切分lowEnd ~ from 这个区间</span></span><br><span class="line">        to = lowEnd;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowEnd - <span class="keyword">from</span> &lt;= to - highStart) &#123;</span><br><span class="line">        quickSort(a, <span class="keyword">from</span>, lowEnd);</span><br><span class="line">        <span class="keyword">from</span> = highStart;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(array, <span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接:</p>
<p><a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js#997" target="_blank" rel="noopener">V8 sort源码(点开第997行)</a></p>
<p><a href="https://juejin.im/post/59e80dc6f265da432a7aaf15" target="_blank" rel="noopener">冴羽排序源码专题</a></p>
<h2 id="第十八篇-能不能模拟实现一个new的效果？"><a href="#第十八篇-能不能模拟实现一个new的效果？" class="headerlink" title="第十八篇: 能不能模拟实现一个new的效果？"></a>第十八篇: 能不能模拟实现一个new的效果？</h2><p><code>new</code>被调用后做了三件事情:</p>
<ol>
<li>让实例可以访问到私有属性</li>
<li>让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性</li>
<li>如果构造函数返回的结果不是引用数据类型</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span>(<span class="params">ctor, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'newOperator function the first param must be a function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = ctor.apply(obj, args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">'object'</span> &amp;&amp; res !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> isFunction = typoof res === <span class="string">'function'</span>;</span><br><span class="line">    <span class="keyword">return</span> isObect || isFunction ? res : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第十九篇-能不能模拟实现一个-bind-的效果？"><a href="#第十九篇-能不能模拟实现一个-bind-的效果？" class="headerlink" title="第十九篇: 能不能模拟实现一个 bind 的效果？"></a>第十九篇: 能不能模拟实现一个 bind 的效果？</h2><p>实现bind之前，我们首先要知道它做了哪些事情。</p>
<ol>
<li>对于普通函数，绑定this指向</li>
<li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存this的值，它代表调用 bind 的函数</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? </span><br><span class="line">            <span class="keyword">this</span> : </span><br><span class="line">            context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fbound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以这么用 Object.create 来处理原型:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? </span><br><span class="line">            <span class="keyword">this</span> : </span><br><span class="line">            context, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fbound.prototype = <span class="built_in">Object</span>.create(self.prototype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二十篇-能不能实现一个-call-apply-函数？"><a href="#第二十篇-能不能实现一个-call-apply-函数？" class="headerlink" title="第二十篇: 能不能实现一个 call/apply 函数？"></a>第二十篇: 能不能实现一个 call/apply 函数？</h2><p>引自<code>冴羽</code>大佬的代码，可以说比较完整了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>);</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过我认为换成 ES6 的语法会更精炼一些:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">'fn'</span>);</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，有apply的对应实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二十一篇-谈谈你对JS中this的理解。"><a href="#第二十一篇-谈谈你对JS中this的理解。" class="headerlink" title="第二十一篇: 谈谈你对JS中this的理解。"></a>第二十一篇: 谈谈你对JS中this的理解。</h2><p>其实JS中的this是一个非常简单的东西，只需要理解它的执行规则就OK。</p>
<p>在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。</p>
<p>call/apply/bind可以显示绑定, 这里就不说了。</p>
<p>主要这些场隐式绑定的场景讨论:</p>
<ol>
<li>全局上下文</li>
<li>直接调用函数</li>
<li>对象.方法的形式调用</li>
<li>DOM事件绑定(特殊)</li>
<li>new构造函数绑定</li>
<li>箭头函数</li>
</ol>
<h3 id="1-全局上下文"><a href="#1-全局上下文" class="headerlink" title="1. 全局上下文"></a>1. 全局上下文</h3><p>全局上下文默认this指向window, 严格模式下指向undefined。</p>
<h3 id="2-直接调用函数"><a href="#2-直接调用函数" class="headerlink" title="2. 直接调用函数"></a>2. 直接调用函数</h3><p>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = obj.a</span><br><span class="line">func()  <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<p>这种情况是直接调用。this相当于全局上下文的情况。</p>
<h3 id="3-对象-方法的形式调用"><a href="#3-对象-方法的形式调用" class="headerlink" title="3. 对象.方法的形式调用"></a>3. 对象.方法的形式调用</h3><p>还是刚刚的例子，我如果这样写:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.a() <span class="comment">// 指向obj</span></span><br></pre></td></tr></table></figure>

<p>这就是 <code>对象.方法</code>的情况，this指向这个对象</p>
<h3 id="4-DOM事件绑定"><a href="#4-DOM事件绑定" class="headerlink" title="4. DOM事件绑定"></a>4. DOM事件绑定</h3><p>onclick和addEventerListener中 this 默认指向绑定事件的元素。</p>
<p>IE比较奇异，使用attachEvent，里面的this默认指向window。</p>
<h3 id="5-new-构造函数"><a href="#5-new-构造函数" class="headerlink" title="5. new+构造函数"></a>5. new+构造函数</h3><p>此时构造函数中的this指向实例对象。</p>
<h3 id="6-箭头函数？"><a href="#6-箭头函数？" class="headerlink" title="6. 箭头函数？"></a>6. 箭头函数？</h3><p>箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        func()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.a() <span class="comment">// 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj</span></span><br></pre></td></tr></table></figure>

<p>优先级: new &gt; call、apply、bind &gt; 对象.方法 &gt; 直接调用。</p>
<h2 id="第二十二篇-JS中浅拷贝的手段有哪些？"><a href="#第二十二篇-JS中浅拷贝的手段有哪些？" class="headerlink" title="第二十二篇: JS中浅拷贝的手段有哪些？"></a>第二十二篇: JS中浅拷贝的手段有哪些？</h2><h3 id="重要-什么是拷贝？"><a href="#重要-什么是拷贝？" class="headerlink" title="重要: 什么是拷贝？"></a>重要: 什么是拷贝？</h3><p>首先来直观的感受一下什么是拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>这是直接赋值的情况，不涉及任何拷贝。当改变newArr的时候，由于是同一个引用，arr指向的值也跟着改变。</p>
<p>现在进行浅拷贝:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice()</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p>当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！</p>
<p>这就是浅拷贝！</p>
<p>但是这又会带来一个潜在的问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice()</span><br><span class="line">newArr[<span class="number">3</span>].val = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3 &#123;val: 1000&#125;]</span></span><br></pre></td></tr></table></figure>

<p>咦!不是已经不是同一块空间的引用了吗？为什么改变了newArr改变了第二个元素的val值，arr也跟着变了。</p>
<p>这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。当然，这是我们下一篇的重点。现在先让大家有一个基本的概念。</p>
<p>接下来，我们来研究一下JS中实现浅拷贝到底有多少种方式？</p>
<h3 id="1-手动实现"><a href="#1-手动实现" class="headerlink" title="1. 手动实现"></a>1. 手动实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">                cloneTarget[prop] = target[prop]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> newArr = shallowClone(arr)</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1,2,&#123;val: 1000&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2. Object.assign"></a>2. Object.assign</h3><p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'arr'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">'sss'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2) </span><br><span class="line"><span class="comment">//&#123; name: 'sss', age: 18 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-concat浅拷贝数组"><a href="#3-concat浅拷贝数组" class="headerlink" title="3. concat浅拷贝数组"></a>3. concat浅拷贝数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat()</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">2</span>] = <span class="number">30</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-slice浅拷贝"><a href="#4-slice浅拷贝" class="headerlink" title="4. slice浅拷贝"></a>4. slice浅拷贝</h3><p>开头的例子不就说的这个嘛！</p>
<h3 id="5-…展开运算符"><a href="#5-…展开运算符" class="headerlink" title="5. …展开运算符"></a>5. …展开运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr] <span class="comment">// 跟arr.slice() 是一样的效果</span></span><br></pre></td></tr></table></figure>

<h2 id="第二十三篇-能不能写一个完整的深拷贝？"><a href="#第二十三篇-能不能写一个完整的深拷贝？" class="headerlink" title="第二十三篇: 能不能写一个完整的深拷贝？"></a>第二十三篇: 能不能写一个完整的深拷贝？</h2><p>上一篇已经解释了什么是深拷贝，现在我们来一起实现一个完整且专业的深拷贝。</p>
<h3 id="1-简易版及问题"><a href="#1-简易版及问题" class="headerlink" title="1. 简易版及问题"></a>1. 简易版及问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify());</span><br></pre></td></tr></table></figure>

<p>估计这个api能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：</p>
<blockquote>
<p>无法解决<code>循环引用</code>的问题。举个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br></pre></td></tr></table></figure>

<p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况</p>
<blockquote>
<p>无法拷贝一写<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</p>
<p>无法拷贝<code>函数</code>(划重点)。</p>
</blockquote>
<p>因此这个api先pass掉，我们重新写一个深拷贝，简易版如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">          cloneTarget[prop] = deepClone(target[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们以刚刚发现的三个问题为导向，一步步来完善、优化我们的深拷贝代码。</p>
<h3 id="2-解决循环引用"><a href="#2-解决循环引用" class="headerlink" title="2. 解决循环引用"></a>2. 解决循环引用</h3><p>现在问题如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">val</span> : <span class="number">100</span>&#125;;</span><br><span class="line">obj.target = obj;</span><br><span class="line"></span><br><span class="line">deepClone(obj);<span class="comment">//报错: RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<p>这就是循环引用。我们怎么来解决这个问题呢？</p>
<p>创建一个Map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>(</span>)) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span>(map.get(target))  </span><br><span class="line">    <span class="keyword">return</span> target; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (isObject(target)) &#123; </span><br><span class="line">    map.set(target, <span class="literal">true</span>); </span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123; </span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123; </span><br><span class="line">          cloneTarget[prop] = deepClone(target[prop],map); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cloneTarget; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> target; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来试一试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">val</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> newA = deepClone(a);</span><br><span class="line"><span class="built_in">console</span>.log(newA)<span class="comment">//&#123; val: 2, target: &#123; val: 2, target: [Circular] &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是map 上的 key 和 map 构成了<code>强引用关系</code>，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了：</p>
<blockquote>
<p>在计算机程序设计中，弱引用与强引用相对， 是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 –百度百科</p>
</blockquote>
<p>说的有一点绕，我用大白话解释一下，被弱引用的对象可以在<code>任何时候被回收</code>，而对于强引用来说，只要这个强引用还在，那么对象<code>无法被回收</code>。拿上面的例子说，map 和 a一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直<code>不会被释放</code>。</p>
<p>怎么解决这个问题？</p>
<p>很简单，让 map 的 key 和 map 构成<code>弱引用</code>即可。ES6给我们提供了这样的数据结构，它的名字叫<code>WeakMap</code>，它是一种特殊的Map, 其中的键是<code>弱引用</code>的。其键必须是对象，而值可以是任意的。</p>
<p>稍微改造一下即可:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-拷贝特殊对象"><a href="#3-拷贝特殊对象" class="headerlink" title="3. 拷贝特殊对象"></a>3. 拷贝特殊对象</h3><h4 id="可继续遍历"><a href="#可继续遍历" class="headerlink" title="可继续遍历"></a>可继续遍历</h4><p>对于特殊的对象，我们使用以下方式来鉴别:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj);</span><br></pre></td></tr></table></figure>

<p>梳理一下对于可遍历对象会有什么结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"object Map"</span>]</span><br><span class="line">[<span class="string">"object Set"</span>]</span><br><span class="line">[<span class="string">"object Array"</span>]</span><br><span class="line">[<span class="string">"object Object"</span>]</span><br><span class="line">[<span class="string">"object Arguments"</span>]</span><br></pre></td></tr></table></figure>

<p>好，以这些不同的字符串为依据，我们就可以成功地鉴别这些对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">'[object Map]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Set]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Arguments]'</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.prototype;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.put(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key), deepClone(item));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      target.add(deepClone(item));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可遍历的对象"><a href="#不可遍历的对象" class="headerlink" title="不可遍历的对象"></a>不可遍历的对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">'[object Function]'</span>;</span><br></pre></td></tr></table></figure>

<p>对于不可遍历的对象，不同的对象有不同的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 待会的重点部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-拷贝函数"><a href="#4-拷贝函数" class="headerlink" title="4. 拷贝函数"></a>4. 拷贝函数</h3><p>虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。</p>
<p>提到函数，在JS种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是 Function的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要 处理普通函数的情况，箭头函数直接返回它本身就好了。</p>
<p>那么如何来区分两者呢？</p>
<p>答案是: 利用原型。箭头函数是不存在原型的。</p>
<p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在，我们的深拷贝就实现地比较完善了。不过在测试的过程中，我也发现了一个小小的bug。</p>
<h3 id="5-小小的bug"><a href="#5-小小的bug" class="headerlink" title="5. 小小的bug"></a>5. 小小的bug</h3><p>如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line"><span class="keyword">new</span> Ctor(target); <span class="comment">// 结果为 Boolean &#123;true&#125; 而不是 false。</span></span><br></pre></td></tr></table></figure>

<p>对于这样一个bug，我们可以对 Boolean 拷贝做最简单的修改， 调用valueOf: new target.constructor(target.valueOf())。</p>
<p>但实际上，这种写法是不推荐的。因为在ES6后不推荐使用【new 基本类型()】这 样的语法，所以es6中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)。</p>
<p>因此我们接下来统一一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-完整代码展示"><a href="#6-完整代码展示" class="headerlink" title="6. 完整代码展示"></a>6. 完整代码展示</h3><p>OK!是时候给大家放出完整版的深拷贝啦:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">target</span>) =&gt;</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> || <span class="keyword">typeof</span> target === <span class="string">'function'</span>) &amp;&amp; target !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">  <span class="string">'[object Map]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Set]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Array]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Object]'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'[object Arguments]'</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">'[object Map]'</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">'[object Set]'</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">'[object Symbol]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">'[object Function]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleRegExp = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleFunc = <span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">  <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">  <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">  <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">  <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (param) &#123;</span><br><span class="line">    <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleNotTraverse = <span class="function">(<span class="params">target, tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target));</span><br><span class="line">    <span class="keyword">case</span> errorTag: </span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> handleRegExp(target);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> handleFunc(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isObject(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">    <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">    <span class="keyword">return</span> handleNotTraverse(target, type);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">    <span class="keyword">let</span> ctor = target.constructor;</span><br><span class="line">    cloneTarget = <span class="keyword">new</span> ctor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(map.get(target)) </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  map.set(target, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">    <span class="comment">//处理Map</span></span><br><span class="line">    target.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(deepClone(key, map), deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">    <span class="comment">//处理Set</span></span><br><span class="line">    target.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(deepClone(item, map));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组和对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = deepClone(target[prop], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/09/ESLint里的规则教会我，无规矩不编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/09/ESLint里的规则教会我，无规矩不编程/" class="post-title-link" itemprop="url">ESLint里的规则教会我，无规矩不编程</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-09 22:25:43 / 修改时间：22:35:12" itemprop="dateCreated datePublished" datetime="2019-12-09T22:25:43+08:00">2019-12-09</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ESLint里的规则教会我，无规矩不编程"><a href="#ESLint里的规则教会我，无规矩不编程" class="headerlink" title="ESLint里的规则教会我，无规矩不编程"></a>ESLint里的规则教会我，无规矩不编程</h1><h2 id="编程风格要统一"><a href="#编程风格要统一" class="headerlink" title="编程风格要统一"></a>编程风格要统一</h2><p>编程风格这个东西，说实在的对于刚加入团队的新成员来说还是很难让人完全适应的。因为每人的编程风格都不同，完全是各有千秋的既视感啊</p>
<p>到了新公司后团队中的每个人也都有各自一套的编程习惯，撸起代码来是挡也挡不住啊，什么都别问，老夫就是干，哈哈，每个coder的代码风格都大相径庭</p>
<p>不过话说回来，在团队开发中，所有的代码看起来风格一致是极其重要的，所以我们也需要一些代码检查工具，从JSLint,JSHint到今天的主角ESLint，都是非常好用的检查工具</p>
<p>那么闲言少叙，直接进入主题，投入ESLint的怀抱吧！！！</p>
<h2 id="ESLint是伟大的作品"><a href="#ESLint是伟大的作品" class="headerlink" title="ESLint是伟大的作品"></a>ESLint是伟大的作品</h2><p>放眼望去，在前端，但凡有个项目，无论大小，都会看到它的身影。并非为了提高比格，让别人暗赞专业，而是它确确实实帮我们检测出不易察觉的错误，避免N多个线上bug</p>
<p>也通过其规则，让整个团队有了整齐划一的代码输出风格，也有业界的最佳实践写法，深入其中，受益匪浅…..好处优点不多说，用过都说好</p>
<p>既然都说好了，那还废话那么多，小二赶紧上菜啊</p>
<h3 id="安装ESLint"><a href="#安装ESLint" class="headerlink" title="安装ESLint"></a>安装ESLint</h3><p>现在前端项目开发中，都用到了webpack此等屌屌的构建工具(<a href="https://juejin.im/post/5adea0106fb9a07a9d6ff6de" target="_blank" rel="noopener">如果有对webpack不熟悉使用的可移步这里</a>)，那么就结合着一起来看下如何使用到项目里吧</p>
<ol>
<li><p>首先安装一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装eslint</span></span><br><span class="line"><span class="comment">// 安装eslint-loader 在webpack中解析</span></span><br><span class="line"><span class="comment">// 安装babel-eslint  对Babel解析器的包装与ESLint兼容</span></span><br><span class="line"><span class="comment">// -D 安装在开发依赖环境 devDependencies 原--save-dev的简写</span></span><br><span class="line">npm i eslint eslint-loader babel-eslint -D</span><br></pre></td></tr></table></figure>

<p><strong>友情提示</strong>：ESLint是基于Node的(当然webpack也是)，所以在使用之前，请确保Node已经安装</p>
</li>
<li><p>创建.eslintrc.js配置文件(默认是.eslintrc文件)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 指定解析器</span></span><br><span class="line">    <span class="string">'parse'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="comment">// 指定解析器选项</span></span><br><span class="line">    <span class="string">'parserOptions'</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 指定脚本的运行环境</span></span><br><span class="line">    <span class="string">'env'</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 别人可以直接使用你配置好的ESLint</span></span><br><span class="line">    <span class="string">'root'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 脚本在执行期间访问的额外的全局变量</span></span><br><span class="line">    <span class="string">'globals'</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 启用的规则及其各自的错误级别</span></span><br><span class="line">    <span class="string">'rules'</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置好的规则添加到webpack中对js文件检查</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">''</span>,</span><br><span class="line">    output: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                use: [<span class="string">'babel-loader'</span>, <span class="string">'eslint-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [],</span><br><span class="line">    devServer: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>按照上面的三步曲写完后，应该给自己撒花的，哈哈</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/ESlint%E8%A7%84%E5%88%99.webp" alt></p>
<p>再放一张打包的index.js主文件的代码</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/ESlint%E8%A7%84%E5%88%99-1.webp" alt></p>
<p>该配置的都配置完了，那就迫不及待的执行npm run dev吧，看看是不是完全OK的编译成功呢？</p>
<p>然并卵啊，高兴的太早了</p>
<p><img src="https://raw.githubusercontent.com/niuxinyu/typoraimg/master/img/ESlint%E8%A7%84%E5%88%99-2.webp" alt></p>
<p>上图之所以会有error和warning的报错提示，是因为参照了下面我在公司中使用的ESLint配置规则导致的，那么就赶紧进入下一环节，看看这些规则吧</p>
<h2 id="工作中用到的规则"><a href="#工作中用到的规则" class="headerlink" title="工作中用到的规则"></a>工作中用到的规则</h2><p>正所谓人在江湖飘啊，哪有不挨刀的道理。谁敢说写的代码放到ESLint里完全不报错，报错纯属正常，没必要慌张</p>
<p>现在针对一些比较常见的规范来简单梳理一下，这么多规则，其实看的我也吃了一鲸</p>
<p>现在来看看编译过程中报错的规则吧</p>
<p><strong>非友情提示</strong>：每个规则对应的0，1，2分别表示off, warning, error三个错误级别</p>
<ul>
<li>no-unused-vars <ul>
<li>定义了变量却没有在代码中使用，这是防止产生多余没用的变量</li>
</ul>
</li>
<li>semi <ul>
<li>缺少分号，行尾必须使用分号，这是为了在压缩代码的时候出现意外情况</li>
</ul>
</li>
<li>no-console <ul>
<li>禁止使用 console，提醒开发者，上线时要去掉，因为是warning不会导致编译的js出问题</li>
</ul>
</li>
<li>consistent-this <ul>
<li>this的别名规则，只允许self和that，防止有些人写成_this或者me等等，哈哈</li>
</ul>
</li>
<li>curly <ul>
<li>if 后必须包含 { ，单行 if 除外，也是为了方便阅读代码</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (key === <span class="string">'a'</span>) </span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (key === <span class="string">'a'</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (key === <span class="string">'b'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>default-case</p>
<ul>
<li>switch 语句必须包含 default</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            str = <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">            str = <span class="string">'b'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            str = <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">            str = <span class="string">'b'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            str = <span class="string">'c'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>eqeqeq<ul>
<li>必须使用全等===进行比较，防止隐式转换带来的意外问题</li>
</ul>
</li>
<li>guard-for-in<ul>
<li>for in时需检测hasOwnProperty，避免遍历到继承来的属性方法</li>
</ul>
</li>
<li>max-depth<ul>
<li>最大块嵌套不能超过5层</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> () &#123;</span><br><span class="line">        <span class="keyword">if</span> () &#123;</span><br><span class="line">            <span class="keyword">if</span> () &#123;</span><br><span class="line">                <span class="keyword">if</span> () &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>max-params <ul>
<li>函数的形参不能多于8个,如果形参过多，我们现在可以用扩展运算符…来代替后面多余的形参</li>
</ul>
</li>
<li>new-cap <ul>
<li>new关键字后类名应首字母大写，区分类和函数</li>
</ul>
</li>
<li>no-array-constructor <ul>
<li>禁止使用Array构造函数，定义数组直接用最快捷的方式[1, 2, 3]</li>
</ul>
</li>
<li>no-await-in-loop <ul>
<li>禁止将await写在循环里,循环属于同步操作，不该将await异步操作写在内部</li>
</ul>
</li>
<li>no-caller <ul>
<li>禁止使用arguments.caller和arguments.callee，ES6中废弃了</li>
</ul>
</li>
<li>no-const-assign <ul>
<li>禁止对const定义重新赋值</li>
</ul>
</li>
<li>no-delete-var <ul>
<li>禁止对变量使用delete关键字，delete只适用于对象的属性，提醒使用的范围</li>
</ul>
</li>
<li>no-dupe-args <ul>
<li>函数参数禁止重名</li>
</ul>
</li>
<li>no-empty-function <ul>
<li>禁止空的function,保证写的每一个function都有用</li>
</ul>
</li>
<li>no-eval <ul>
<li>禁止使用eval，eval是“魔鬼”，所以在开发中避免</li>
</ul>
</li>
<li>no-extra-semi <ul>
<li>禁止额外的分号，有些地方没必要加分号比如if () {};这样就是错误的</li>
</ul>
</li>
<li>no-global-assign <ul>
<li>禁止对全局变量赋值</li>
</ul>
</li>
</ul>
<p>好了还有一些就需要大家在使用中来去体会了，下面我将我司工作当中用到的ESLint规则贴出来，方便大家去做代码检查了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 解析ES6</span></span><br><span class="line">    <span class="string">'parser'</span>: <span class="string">'babel-eslint'</span>,</span><br><span class="line">    <span class="string">'parserOptions'</span>: &#123;</span><br><span class="line">        <span class="comment">// 启用ES8语法支持</span></span><br><span class="line">        <span class="string">'ecmaVersion'</span>: <span class="number">2017</span>,    </span><br><span class="line">        <span class="comment">// module表示ECMAScript模块</span></span><br><span class="line">        <span class="string">'sourceType'</span>: <span class="string">'module'</span>,</span><br><span class="line">        <span class="comment">// 使用额外的语言特性</span></span><br><span class="line">        <span class="string">'ecmaFeatures'</span>: &#123;</span><br><span class="line">            <span class="string">'experimentalObjectRestSpread'</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">'jsx'</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">'modules'</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这些环境并不是互斥的，所以你可以同时定义多个</span></span><br><span class="line">    <span class="string">'env'</span>: &#123;</span><br><span class="line">        <span class="string">'browser'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'jquery'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'node'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'commonjs'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'es6'</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'root'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 当访问当前源文件内未定义的变量时，no-undef 规则将发出警告</span></span><br><span class="line">    <span class="comment">// 所以需要定义这些额外的全局变量</span></span><br><span class="line">    <span class="string">'globals'</span>: &#123;</span><br><span class="line">        <span class="string">'OnlySVG'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'monitor'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'CanvasRender'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'Vue'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'VueRouter'</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'rules'</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置了 setter ，必须相应设置 getter ，反之不必须</span></span><br><span class="line">        <span class="string">'accessor-pairs'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组方括号前后的换行符使用规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'array-bracket-newline'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组方括号前后的空格使用规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'array-bracket-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组的 map、filter、sort 等方法，回调函数必须有返回值</span></span><br><span class="line">        <span class="string">'array-callback-return'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个数组项是否独占一行</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'array-element-newline'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 箭头函数的书写规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'arrow-body-style'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 箭头函数的圆括号使用规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 箭头函数的空格使用规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'arrow-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能在块外使用块作用域内 var 定义的变量</span></span><br><span class="line">        <span class="string">'block-scoped-var'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码块花括号前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'block-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if else 的花括号换行规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'brace-style'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback 之后必须立即 return</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'callback-return'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量名必须使用驼峰式</span></span><br><span class="line">        <span class="comment">// @off 暂不限制</span></span><br><span class="line">        <span class="string">'camelcase'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注释的首字母应该大写</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'capitalized-comments'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// class 的非静态方法必须包含 this 关键字</span></span><br><span class="line">        <span class="string">'class-methods-use-this'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象的最后一项后面是否写逗号</span></span><br><span class="line">        <span class="comment">// @off 此项目不关心</span></span><br><span class="line">        <span class="comment">// @fixable 对于 PC 项目考虑兼容性时需要设置</span></span><br><span class="line">        <span class="string">'comma-dangle'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逗号前后是否有空格</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'comma-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逗号写在行首还是行尾</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'comma-style'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止函数 if ... else if ... else 的复杂度超过 20</span></span><br><span class="line">        <span class="string">'complexity'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方括号访问对象属性时，方括号前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'computed-property-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止函数在不同条件下返回不同类型的值</span></span><br><span class="line">        <span class="comment">// @off 有时候会希望通过参数获取不同类型的返回值</span></span><br><span class="line">        <span class="string">'consistent-return'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this 的别名规则，只允许 self 或 that</span></span><br><span class="line">        <span class="string">'consistent-this'</span>: [<span class="number">2</span>, <span class="string">'self'</span>, <span class="string">'that'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数中必须调用 super</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'constructor-super'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if 后必须包含 &#123; ，单行 if 除外</span></span><br><span class="line">        <span class="string">'curly'</span>: [<span class="number">2</span>, <span class="string">'multi-line'</span>, <span class="string">'consistent'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// switch 语句必须包含 default</span></span><br><span class="line">        <span class="string">'default-case'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式操作时，点的位置，是在上一行结尾还是下一行开头</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'dot-location'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件最后必须有空行</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'eol-last'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用 === 和 !== ，和 null 对比时除外</span></span><br><span class="line">        <span class="string">'eqeqeq'</span>: [<span class="number">2</span>, <span class="string">'always'</span>, &#123; <span class="string">'null'</span>: <span class="string">'ignore'</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for 循环不得因方向错误造成死循环</span></span><br><span class="line">        <span class="string">'for-direction'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行函数的圆括号前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'func-call-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把函数赋给变量或对象属性时，函数名和变量名或对象属性名必须一致</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'func-name-matching'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不允许匿名函数</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'func-names'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须只使用函数申明或只使用函数表达式</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'func-style'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// generator 的 * 前后空格使用规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'generator-star-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getter 必须有返回值，允许返回 undefined</span></span><br><span class="line">        <span class="string">'getter-return'</span>: [<span class="number">2</span>, &#123; <span class="attr">allowImplicit</span>: <span class="literal">true</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// require 必须在全局作用域下</span></span><br><span class="line">        <span class="comment">// @off 条件加载很常见</span></span><br><span class="line">        <span class="string">'global-require'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for in 时需检测 hasOwnProperty</span></span><br><span class="line">        <span class="string">'guard-for-in'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback 中的 err、error 参数和变量必须被处理</span></span><br><span class="line">        <span class="string">'handle-callback-err'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// id 黑名单</span></span><br><span class="line">        <span class="comment">// @off 暂时没有</span></span><br><span class="line">        <span class="string">'id-blacklist'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量名长度限制</span></span><br><span class="line">        <span class="comment">// @off 长度不是重点，清晰易读才是关键</span></span><br><span class="line">        <span class="string">'id-length'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制变量名必须匹配指定的正则表达式</span></span><br><span class="line">        <span class="comment">// @off 没必要限制变量名</span></span><br><span class="line">        <span class="string">'id-match'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩进使用 tab 还是空格</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'indent'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量必须在定义的时候赋值</span></span><br><span class="line">        <span class="comment">// @off 先定义后赋值很常见</span></span><br><span class="line">        <span class="string">'init-declarations'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jsx 语法中，属性的值必须使用双引号</span></span><br><span class="line">        <span class="string">'jsx-quotes'</span>: [<span class="number">2</span>, <span class="string">'prefer-double'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象字面量冒号前后的空格使用规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'key-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键字前后必须有空格</span></span><br><span class="line">        <span class="string">'keyword-spacing'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换行符使用规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'linebreak-style'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单行注释必须写在前一行还是行尾</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'line-comment-position'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注释前后是否要空一行</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'lines-around-comment'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大块嵌套深度为 5 层</span></span><br><span class="line">        <span class="string">'max-depth'</span>: [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制单行代码的长度</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'max-len'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制单个文件最大行数</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'max-lines'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大回调深度为 3 层</span></span><br><span class="line">        <span class="string">'max-nested-callbacks'</span>: [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数的形参不能多于8个</span></span><br><span class="line">        <span class="string">'max-params'</span>: [<span class="number">2</span>, <span class="number">8</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制一行中的语句数量</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'max-statements-per-line'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制函数块中的语句数量</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'max-statements'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三元表达式的换行规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'multiline-ternary'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new关键字后类名应首字母大写</span></span><br><span class="line">        <span class="string">'new-cap'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">'capIsNew'</span>: <span class="literal">false</span>, <span class="comment">// 允许大写开头的函数直接执行</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new 关键字后类应包含圆括号</span></span><br><span class="line">        <span class="string">'new-parens'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用是否要换行</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'newline-per-chained-call'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 alert，提醒开发者，上线时要去掉</span></span><br><span class="line">        <span class="string">'no-alert'</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 Array 构造函数，使用 Array(num) 直接创建长度为 num 的数组时可以</span></span><br><span class="line">        <span class="string">'no-array-constructor'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止将 await 写在循环里</span></span><br><span class="line">        <span class="string">'no-await-in-loop'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止位运算</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'no-bitwise'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在 Node.js 中直接调用 Buffer 构造函数</span></span><br><span class="line">        <span class="string">'no-buffer-constructor'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 arguments.caller 和 arguments.callee</span></span><br><span class="line">        <span class="string">'no-caller'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// switch的条件中出现 var、let、const、function、class 等关键字，必须使用花括号把内容括起来</span></span><br><span class="line">        <span class="string">'no-case-declarations'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// catch中不得使用已定义的变量名</span></span><br><span class="line">        <span class="string">'no-catch-shadow'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// class定义的类名不得与其它变量重名</span></span><br><span class="line">        <span class="string">'no-class-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止与 -0 做比较</span></span><br><span class="line">        <span class="string">'no-compare-neg-zero'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在 if、for、while 中出现赋值语句，除非用圆括号括起来</span></span><br><span class="line">        <span class="string">'no-cond-assign'</span>: [<span class="number">2</span>, <span class="string">'except-parens'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现难以理解的箭头函数，除非用圆括号括起来</span></span><br><span class="line">        <span class="string">'no-confusing-arrow'</span>: [<span class="number">2</span>, &#123; <span class="string">'allowParens'</span>: <span class="literal">true</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 console，提醒开发者，上线时要去掉</span></span><br><span class="line">        <span class="string">'no-console'</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用常量作为判断条件</span></span><br><span class="line">        <span class="string">'no-constant-condition'</span>: [<span class="number">2</span>, &#123; <span class="string">'checkLoops'</span>: <span class="literal">false</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止对 const 定义重新赋值</span></span><br><span class="line">        <span class="string">'no-const-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 continue</span></span><br><span class="line">        <span class="comment">// @off 很常用</span></span><br><span class="line">        <span class="string">'no-continue'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止正则表达式中出现 Ctrl 键的 ASCII 表示，即/\x1f/</span></span><br><span class="line">        <span class="string">'no-control-regex'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 debugger 语句，提醒开发者，上线时要去掉</span></span><br><span class="line">        <span class="string">'no-debugger'</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止对变量使用 delete 关键字，删除对象的属性不受限制</span></span><br><span class="line">        <span class="string">'no-delete-var'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在正则表达式中出现形似除法操作符的开头，如 let a = /=foo/</span></span><br><span class="line">        <span class="comment">// @off 有代码高亮的话，在阅读这种代码时，也完全不会产生歧义或理解上的困难</span></span><br><span class="line">        <span class="string">'no-div-regex'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数参数禁止重名</span></span><br><span class="line">        <span class="string">'no-dupe-args'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止对象出现重名键值</span></span><br><span class="line">        <span class="string">'no-dupe-keys'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类方法禁止重名</span></span><br><span class="line">        <span class="string">'no-dupe-class-members'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 switch 中出现相同的 case</span></span><br><span class="line">        <span class="string">'no-duplicate-case'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止重复 import</span></span><br><span class="line">        <span class="string">'no-duplicate-imports'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现 if (cond) &#123; return a &#125; else &#123; return b &#125;，应该写为 if (cond) &#123; return a &#125; return b</span></span><br><span class="line">        <span class="comment">// @off 有时前一种写法更清晰易懂</span></span><br><span class="line">        <span class="string">'no-else-return'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正则表达式中禁止出现空的字符集[]</span></span><br><span class="line">        <span class="string">'no-empty-character-class'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止空的 function</span></span><br><span class="line">        <span class="comment">// 包含注释的情况下允许</span></span><br><span class="line">        <span class="string">'no-empty-function'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止解构中出现空 &#123;&#125; 或 []</span></span><br><span class="line">        <span class="string">'no-empty-pattern'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现空代码块</span></span><br><span class="line">        <span class="string">'no-empty'</span>: [<span class="number">2</span>, &#123; <span class="string">'allowEmptyCatch'</span>: <span class="literal">true</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 == 和 != 与 null 做比较，必须用 === 或 !==</span></span><br><span class="line">        <span class="comment">// @off 非严格相等可以同时判断 null 和 undefined</span></span><br><span class="line">        <span class="string">'no-eq-null'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 eval</span></span><br><span class="line">        <span class="string">'no-eval'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// catch 定义的参数禁止赋值</span></span><br><span class="line">        <span class="string">'no-ex-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止扩展原生对象</span></span><br><span class="line">        <span class="string">'no-extend-native'</span>: [<span class="number">2</span>, &#123; <span class="string">'exceptions'</span>: [<span class="string">'Array'</span>, <span class="string">'Object'</span>] &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止额外的 bind</span></span><br><span class="line">        <span class="string">'no-extra-bind'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止额外的布尔值转换</span></span><br><span class="line">        <span class="string">'no-extra-boolean-cast'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止额外的 label</span></span><br><span class="line">        <span class="string">'no-extra-label'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止额外的括号，仅针对函数体</span></span><br><span class="line">        <span class="string">'no-extra-parens'</span>: [<span class="number">2</span>, <span class="string">'functions'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止额外的分号</span></span><br><span class="line">        <span class="string">'no-extra-semi'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个 switch 的 case 都需要有 break, return 或 throw</span></span><br><span class="line">        <span class="comment">// 包含注释的情况下允许</span></span><br><span class="line">        <span class="string">'no-fallthrough'</span>: [<span class="number">2</span>, &#123; <span class="string">'commentPattern'</span>: <span class="string">'.'</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不允许使用 2. 或 .5 来表示数字，需要用 2、2.0、0.5 的格式</span></span><br><span class="line">        <span class="string">'no-floating-decimal'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止对函数声明重新赋值</span></span><br><span class="line">        <span class="string">'no-func-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止对全局变量赋值</span></span><br><span class="line">        <span class="string">'no-global-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用隐式类型转换</span></span><br><span class="line">        <span class="string">'no-implicit-coercion'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">'allow'</span>: [<span class="string">'+'</span>, <span class="string">'!!'</span>] <span class="comment">// 允许 + 转数值 '' + 转字符串和 !! 转布尔值</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在 setTimeout 和 setInterval 中传入字符串，因会触发隐式 eval</span></span><br><span class="line">        <span class="string">'no-implied-eval'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止隐式定义全局变量</span></span><br><span class="line">        <span class="string">'no-implicit-globals'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止行内注释</span></span><br><span class="line">        <span class="comment">// @off 很常用</span></span><br><span class="line">        <span class="string">'no-inline-comments'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在块作用域内使用 var 或函数声明</span></span><br><span class="line">        <span class="string">'no-inner-declarations'</span>: [<span class="number">2</span>, <span class="string">'both'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用非法的正则表达式</span></span><br><span class="line">        <span class="string">'no-invalid-regexp'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在类之外的地方使用 this</span></span><br><span class="line">        <span class="comment">// @off this 的使用很灵活，事件回调中可以表示当前元素，函数也可以先用 this，等以后被调用的时候再 call</span></span><br><span class="line">        <span class="string">'no-invalid-this'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用不规范空格</span></span><br><span class="line">        <span class="string">'no-irregular-whitespace'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">'skipStrings'</span>: <span class="literal">true</span>, <span class="comment">// 允许在字符串中使用</span></span><br><span class="line">            <span class="string">'skipComments'</span>: <span class="literal">true</span>, <span class="comment">// 允许在注释中使用</span></span><br><span class="line">            <span class="string">'skipRegExps'</span>: <span class="literal">true</span>, <span class="comment">// 允许在正则表达式中使用</span></span><br><span class="line">            <span class="string">'skipTemplates'</span>: <span class="literal">true</span>, <span class="comment">// 允许在模板字符串中使用</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 __iterator__</span></span><br><span class="line">        <span class="string">'no-iterator'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// label 不得与已定义的变量重名</span></span><br><span class="line">        <span class="string">'no-label-var'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 label</span></span><br><span class="line">        <span class="comment">// @off 禁止了将很难 break 多重循环和多重 switch</span></span><br><span class="line">        <span class="string">'no-labels'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用无效的块作用域</span></span><br><span class="line">        <span class="string">'no-lone-blocks'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 else 中只有一个单独的 if</span></span><br><span class="line">        <span class="comment">// @off 单独的 if 可以把逻辑表达的更清楚</span></span><br><span class="line">        <span class="string">'no-lonely-if'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 for (var i) &#123; function() &#123; use i &#125; &#125;，使用 let 则可以</span></span><br><span class="line">        <span class="string">'no-loop-func'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止魔法数字</span></span><br><span class="line">        <span class="string">'no-magic-numbers'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用混合的逻辑判断，必须把不同的逻辑用圆括号括起来</span></span><br><span class="line">        <span class="string">'no-mixed-operators'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"groups"</span>: [</span><br><span class="line">                [<span class="string">"&amp;&amp;"</span>, <span class="string">"||"</span>]</span><br><span class="line">            ]</span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相同类型的 require 必须放在一起</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'no-mixed-requires'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止混用空格和 tab 来做缩进，必须统一</span></span><br><span class="line">        <span class="string">'no-mixed-spaces-and-tabs'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止连等赋值</span></span><br><span class="line">        <span class="string">'no-multi-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用连续的空格</span></span><br><span class="line">        <span class="string">'no-multi-spaces'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 \ 来定义多行字符串，统一使用模板字符串来做</span></span><br><span class="line">        <span class="string">'no-multi-str'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连续空行的数量限制</span></span><br><span class="line">        <span class="string">'no-multiple-empty-lines'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            max: <span class="number">3</span>, <span class="comment">// 文件内最多连续 3 个</span></span><br><span class="line">            maxEOF: <span class="number">1</span>, <span class="comment">// 文件末尾最多连续 1 个</span></span><br><span class="line">            maxBOF: <span class="number">1</span> <span class="comment">// 文件头最多连续 1 个</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 if 中出现否定表达式 !==</span></span><br><span class="line">        <span class="comment">// @off 否定的表达式可以把逻辑表达的更清楚</span></span><br><span class="line">        <span class="string">'no-negated-condition'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止嵌套的三元表达式</span></span><br><span class="line">        <span class="comment">// @off 没有必要限制</span></span><br><span class="line">        <span class="string">'no-nested-ternary'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 new Function</span></span><br><span class="line">        <span class="comment">// @off 有时会用它来解析非标准格式的 JSON 数据</span></span><br><span class="line">        <span class="string">'no-new-func'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 new Object</span></span><br><span class="line">        <span class="string">'no-new-object'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 new require</span></span><br><span class="line">        <span class="string">'no-new-require'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 new Symbol</span></span><br><span class="line">        <span class="string">'no-new-symbol'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 new Boolean、Number 或 String</span></span><br><span class="line">        <span class="string">'no-new-wrappers'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 new 一个类而不存储该实例</span></span><br><span class="line">        <span class="string">'no-new'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止把原生对象 Math、JSON、Reflect 当函数使用</span></span><br><span class="line">        <span class="string">'no-obj-calls'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用八进制转义符</span></span><br><span class="line">        <span class="string">'no-octal-escape'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用0开头的数字表示八进制</span></span><br><span class="line">        <span class="string">'no-octal'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 __dirname + 'file' 的形式拼接路径，应该使用 path.join 或 path.resolve 来代替</span></span><br><span class="line">        <span class="string">'no-path-concat'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止对函数的参数重新赋值</span></span><br><span class="line">        <span class="string">'no-param-reassign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 ++ 和 --</span></span><br><span class="line">        <span class="comment">// @off 很常用</span></span><br><span class="line">        <span class="string">'no-plusplus'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 process.env.NODE_ENV</span></span><br><span class="line">        <span class="comment">// @off 使用很常见</span></span><br><span class="line">        <span class="string">'no-process-env'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 process.exit(0)</span></span><br><span class="line">        <span class="comment">// @off 使用很常见</span></span><br><span class="line">        <span class="string">'no-process-exit'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 hasOwnProperty, isPrototypeOf 或 propertyIsEnumerable</span></span><br><span class="line">        <span class="comment">// @off 与 guard-for-in 规则冲突，且没有必要</span></span><br><span class="line">        <span class="string">'no-prototype-builtins'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 __proto__</span></span><br><span class="line">        <span class="string">'no-proto'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止重复声明</span></span><br><span class="line">        <span class="string">'no-redeclare'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在正则表达式中出现连续空格</span></span><br><span class="line">        <span class="string">'no-regex-spaces'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止特定的全局变量</span></span><br><span class="line">        <span class="comment">// @off 暂时没有</span></span><br><span class="line">        <span class="string">'no-restricted-globals'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 import 特定的模块</span></span><br><span class="line">        <span class="comment">// @off 暂时没有</span></span><br><span class="line">        <span class="string">'no-restricted-imports'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用特定的模块</span></span><br><span class="line">        <span class="comment">// @off 暂时没有</span></span><br><span class="line">        <span class="string">'no-restricted-modules'</span>: <span class="string">'off'</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止特定的对象属性</span></span><br><span class="line">        <span class="comment">// @off 暂时没有</span></span><br><span class="line">        <span class="string">'no-restricted-properties'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用特定的语法</span></span><br><span class="line">        <span class="comment">// @off 暂时没有</span></span><br><span class="line">        <span class="string">'no-restricted-syntax'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在return中赋值</span></span><br><span class="line">        <span class="string">'no-return-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在 return 中使用 await</span></span><br><span class="line">        <span class="string">'no-return-await'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 location.href = 'javascript:void'</span></span><br><span class="line">        <span class="string">'no-script-url'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止将自己赋值给自己</span></span><br><span class="line">        <span class="string">'no-self-assign'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止自己与自己作比较</span></span><br><span class="line">        <span class="string">'no-self-compare'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止逗号操作符</span></span><br><span class="line">        <span class="string">'no-sequences'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用保留字作为变量名</span></span><br><span class="line">        <span class="string">'no-shadow-restricted-names'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在嵌套作用域中出现重名的定义，如 let a; function b() &#123; let a &#125;</span></span><br><span class="line">        <span class="string">'no-shadow'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止数组中出现连续逗号</span></span><br><span class="line">        <span class="string">'no-sparse-arrays'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 node 中的同步的方法，比如 fs.readFileSync</span></span><br><span class="line">        <span class="comment">// @off 使用很常见</span></span><br><span class="line">        <span class="string">'no-sync'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 tabs</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'no-tabs'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止普通字符串中出现模板字符串语法</span></span><br><span class="line">        <span class="string">'no-template-curly-in-string'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止三元表达式</span></span><br><span class="line">        <span class="comment">// @off 很常用</span></span><br><span class="line">        <span class="string">'no-ternary'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在构造函数的 super 之前使用 this</span></span><br><span class="line">        <span class="string">'no-this-before-super'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 throw 字面量，必须 throw 一个 Error 对象</span></span><br><span class="line">        <span class="string">'no-throw-literal'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止行尾空格</span></span><br><span class="line">        <span class="string">'no-trailing-spaces'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"skipBlankLines"</span>: <span class="literal">true</span>, <span class="comment">// 不检查空行</span></span><br><span class="line">            <span class="string">"ignoreComments"</span>: <span class="literal">true</span> <span class="comment">// 不检查注释</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止将 undefined 赋值给变量</span></span><br><span class="line">        <span class="string">'no-undef-init'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止访问未定义的变量或方法</span></span><br><span class="line">        <span class="string">'no-undef'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 undefined，如需判断一个变量是否为 undefined，请使用 typeof a === 'undefined'</span></span><br><span class="line">        <span class="string">'no-undefined'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止变量名中使用下划线</span></span><br><span class="line">        <span class="comment">// @off 暂不限制</span></span><br><span class="line">        <span class="string">'no-underscore-dangle'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现难以理解的多行代码</span></span><br><span class="line">        <span class="string">'no-unexpected-multiline'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环体内必须对循环条件进行修改</span></span><br><span class="line">        <span class="string">'no-unmodified-loop-condition'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止不必要的三元表达式</span></span><br><span class="line">        <span class="string">'no-unneeded-ternary'</span>: [<span class="number">2</span>, &#123; <span class="string">'defaultAssignment'</span>: <span class="literal">false</span> &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现不可到达的代码，如在 return、throw 之后的代码</span></span><br><span class="line">        <span class="string">'no-unreachable'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在finally块中出现 return、throw、break、continue</span></span><br><span class="line">        <span class="string">'no-unsafe-finally'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现不安全的否定，如 for (!key in obj&#125; &#123;&#125;，应该写为 for (!(key in obj)&#125; &#123;&#125;</span></span><br><span class="line">        <span class="string">'no-unsafe-negation'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止出现无用的表达式</span></span><br><span class="line">        <span class="string">'no-unused-expressions'</span>: [<span class="number">2</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'allowShortCircuit'</span>: <span class="literal">true</span>, <span class="comment">// 允许使用 a() || b 或 a &amp;&amp; b()</span></span><br><span class="line">                <span class="string">'allowTernary'</span>: <span class="literal">true</span>, <span class="comment">// 允许在表达式中使用三元运算符</span></span><br><span class="line">                <span class="string">'allowTaggedTemplates'</span>: <span class="literal">true</span>, <span class="comment">// 允许标记模板字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止定义不使用的 label</span></span><br><span class="line">        <span class="string">'no-unused-labels'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止定义不使用的变量</span></span><br><span class="line">        <span class="string">'no-unused-vars'</span>: [<span class="number">2</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'vars'</span>: <span class="string">'all'</span>, <span class="comment">// 变量定义必须被使用</span></span><br><span class="line">                <span class="string">'args'</span>: <span class="string">'none'</span>, <span class="comment">// 对于函数形参不检测</span></span><br><span class="line">                <span class="string">'ignoreRestSiblings'</span>: <span class="literal">true</span>, <span class="comment">// 忽略剩余子项 fn(...args)，&#123;a, b, ...coords&#125;</span></span><br><span class="line">                <span class="string">'caughtErrors'</span>: <span class="string">'none'</span>, <span class="comment">// 忽略 catch 语句的参数使用</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止在变量被定义之前使用它</span></span><br><span class="line">        <span class="string">'no-use-before-define'</span>: [<span class="number">2</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">'functions'</span>: <span class="literal">false</span>, <span class="comment">// 允许函数在定义之前被调用</span></span><br><span class="line">                <span class="string">'classes'</span>: <span class="literal">false</span>, <span class="comment">// 允许类在定义之前被引用</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止不必要的 call 和 apply</span></span><br><span class="line">        <span class="string">'no-useless-call'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用不必要计算的key，如 var a = &#123; ['0']: 0 &#125;</span></span><br><span class="line">        <span class="string">'no-useless-computed-key'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止不必要的字符串拼接</span></span><br><span class="line">        <span class="string">'no-useless-concat'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止无用的构造函数</span></span><br><span class="line">        <span class="string">'no-useless-constructor'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止无用的转义</span></span><br><span class="line">        <span class="string">'no-useless-escape'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止无效的重命名，如 import &#123;a as a&#125; from xxx</span></span><br><span class="line">        <span class="string">'no-useless-rename'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止没有必要的 return</span></span><br><span class="line">        <span class="comment">// @off 没有必要限制</span></span><br><span class="line">        <span class="string">'no-useless-return'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用 var，必须用 let 或 const</span></span><br><span class="line">        <span class="string">'no-var'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止使用void</span></span><br><span class="line">        <span class="string">'no-void'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止注释中出现 TODO 或 FIXME，用这个来提醒开发者，写了 TODO 就一定要做完</span></span><br><span class="line">        <span class="string">'no-warning-comments'</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止属性前出现空格，如 foo. bar()</span></span><br><span class="line">        <span class="string">'no-whitespace-before-property'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 with</span></span><br><span class="line">        <span class="string">'no-with'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止 if 语句在没有花括号的情况下换行</span></span><br><span class="line">        <span class="string">'nonblock-statement-body-position'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象的花括号前后是否要加空行</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'object-curly-newline'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象的花括号前后是否要加空格</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'object-curly-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象每个属性必须独占一行</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'object-property-newline'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// obj = &#123; a: a &#125; 必须转换成 obj = &#123; a &#125;</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'object-shorthand'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个变量声明必须独占一行</span></span><br><span class="line">        <span class="comment">// @off 有 one-var 就不需要此规则了</span></span><br><span class="line">        <span class="string">'one-var-declaration-per-line'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否允许使用逗号一次声明多个变量</span></span><br><span class="line">        <span class="string">'one-var'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">'const'</span>: <span class="string">'never'</span> <span class="comment">// 所有 const 声明必须独占一行，不允许用逗号定义多个</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用 x = x + y 而不是 x += y</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'operator-assignment'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断行时操作符位于行首还是行尾</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'operator-linebreak'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码块首尾必须要空行</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'padded-blocks'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制语句之间的空行规则，比如变量定义完之后必须要空行</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'padding-line-between-statements'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用箭头函数作为回调</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'prefer-arrow-callback'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明后不再修改的变量必须使用 const</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'prefer-const'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用解构</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'prefer-destructuring'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用 0b11111011 而不是 parseInt('111110111', 2)</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'prefer-numeric-literals'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// promise 的 reject 中必须传入 Error 对象，而不允许使用字面量</span></span><br><span class="line">        <span class="string">'prefer-promise-reject-errors'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用解构 ...args 来代替 arguments</span></span><br><span class="line">        <span class="string">'prefer-rest-params'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用 func(...args) 来代替 func.apply(args)</span></span><br><span class="line">        <span class="comment">// @off 没必要</span></span><br><span class="line">        <span class="string">'prefer-spread'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用模板字符串来代替字符串拼接</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'prefer-template'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串必须使用单引号</span></span><br><span class="line">        <span class="string">'quotes'</span>: [<span class="number">2</span>, <span class="string">'single'</span>, &#123;</span><br><span class="line">            <span class="string">'avoidEscape'</span>: <span class="literal">true</span>, <span class="comment">// 允许包含单引号的字符串使用双引号</span></span><br><span class="line">            <span class="string">'allowTemplateLiterals'</span>: <span class="literal">true</span>, <span class="comment">// 允许使用模板字符串</span></span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象字面量的键名禁止用引号括起来</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'quote-props'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parseInt方法必须传进制参数</span></span><br><span class="line">        <span class="string">'radix'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// async 函数中必须存在 await 语句</span></span><br><span class="line">        <span class="comment">// @off async function 中没有 await 的写法很常见，比如 koa 的示例中就有这种用法</span></span><br><span class="line">        <span class="string">'require-await'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须使用 jsdoc 风格的注释</span></span><br><span class="line">        <span class="comment">// @off 暂不考虑开启</span></span><br><span class="line">        <span class="string">'require-jsdoc'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// generator 函数内必须有 yield</span></span><br><span class="line">        <span class="string">'require-yield'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...后面不允许有空格</span></span><br><span class="line">        <span class="string">'rest-spread-spacing'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分号前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'semi-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止行首出现分号</span></span><br><span class="line">        <span class="string">'semi-style'</span>: [<span class="number">2</span>, <span class="string">'last'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 行尾必须使用分号结束</span></span><br><span class="line">        <span class="string">'semi'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// imports 必须排好序</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'sort-imports'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象字面量的键名必须排好序</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'sort-keys'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量声明必须排好序</span></span><br><span class="line">        <span class="comment">// @off 没必要限制</span></span><br><span class="line">        <span class="string">'sort-vars'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// function 等的花括号之前是否使用空格</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'space-before-blocks'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// function 的圆括号之前是否使用空格</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'space-before-function-paren'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 圆括号内的空格使用规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'space-in-parens'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作符前后要加空格</span></span><br><span class="line">        <span class="string">'space-infix-ops'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new, delete, typeof, void, yield 等表达式前后必须有空格，-, +, --, ++, !, !! 等表达式前后不许有空格</span></span><br><span class="line">        <span class="string">'space-unary-ops'</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">'words'</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">'nonwords'</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注释的斜线和星号后要加空格</span></span><br><span class="line">        <span class="string">'spaced-comment'</span>: [<span class="number">2</span>, <span class="string">'always'</span>, &#123;</span><br><span class="line">            <span class="string">'block'</span>: &#123;</span><br><span class="line">                exceptions: [<span class="string">'*'</span>],</span><br><span class="line">                balanced: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用严格模式，禁止在任何地方出现 'use strict'</span></span><br><span class="line">        <span class="string">'strict'</span>: [<span class="number">2</span>, <span class="string">'never'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// switch 中冒号前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不关心</span></span><br><span class="line">        <span class="string">'switch-colon-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Symbol 的时候必须传入描述</span></span><br><span class="line">        <span class="string">'symbol-description'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模板字符串 $&#123;&#125; 前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'template-curly-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模板字符串前后的空格规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'template-tag-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有文件头禁止出现 BOM</span></span><br><span class="line">        <span class="string">'unicode-bom'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止直接对 NaN 进行判断，必须使用 isNaN</span></span><br><span class="line">        <span class="string">'use-isnan'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注释必须符合 jsdoc 的规范</span></span><br><span class="line">        <span class="comment">// @off 暂不考虑开启</span></span><br><span class="line">        <span class="string">'valid-jsdoc'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// typeof 判断条件只能是 "undefined", "object", "boolean", "number", "string", "function" 或 "symbol"</span></span><br><span class="line">        <span class="string">'valid-typeof'</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// var 必须在作用域的最前面</span></span><br><span class="line">        <span class="comment">// @off var 不在最前面也是很常见的用法</span></span><br><span class="line">        <span class="string">'vars-on-top'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自执行函数必须使用圆括号括起来，如 (function()&#123;do something...&#125;)()</span></span><br><span class="line">        <span class="string">'wrap-iife'</span>: [<span class="number">2</span>, <span class="string">'inside'</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正则表达式必须用圆括号括起来</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'wrap-regex'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// yield 的 * 前后空格规则</span></span><br><span class="line">        <span class="comment">// @off 不限制</span></span><br><span class="line">        <span class="string">'yield-star-spacing'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止Yoda格式的判断条件，如 if (true === a)，应使用 if (a === true)</span></span><br><span class="line">        <span class="string">'yoda'</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/09/JavaScript字符串转换为数字的物种方式及陷阱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/09/JavaScript字符串转换为数字的物种方式及陷阱/" class="post-title-link" itemprop="url">JavaScript字符串转换为数字的物种方式及陷阱</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-09 22:11:51 / 修改时间：22:23:44" itemprop="dateCreated datePublished" datetime="2019-12-09T22:11:51+08:00">2019-12-09</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript字符串转换为数字的物种方式及陷阱"><a href="#JavaScript字符串转换为数字的物种方式及陷阱" class="headerlink" title="JavaScript字符串转换为数字的物种方式及陷阱"></a>JavaScript字符串转换为数字的物种方式及陷阱</h1><p>String 转换为 Number 有很多种方式，我可以想到的有 5 种！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(num); <span class="comment">// 默认方式 (没有基数)</span></span><br><span class="line"><span class="built_in">parseInt</span>(num, <span class="number">10</span>); <span class="comment">// 传入基数 (十位数)</span></span><br><span class="line"><span class="built_in">parseFloat</span>(num); <span class="comment">// 浮点数</span></span><br><span class="line"><span class="built_in">Number</span>(num); <span class="comment">// Number 构造器</span></span><br><span class="line">~~num; <span class="comment">//按位非</span></span><br><span class="line">num / <span class="number">1</span>; <span class="comment">// 除一个数</span></span><br><span class="line">num * <span class="number">1</span>; <span class="comment">// 乘一个数</span></span><br><span class="line">num - <span class="number">0</span>  <span class="comment">// 减去0</span></span><br><span class="line">+num; <span class="comment">// 一元运算符 "+"</span></span><br></pre></td></tr></table></figure>

<p>选择哪一种呢？什么时候选择它？为什么选择这种它？我们逐一进行分析，并解析每种方式的常见陷阱。</p>
<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h3><p>根据 JsPerf.com 的基准测试，大多数浏览器对 parseInt 的响应最佳。虽然它是最快的方式，但使用 preseInt 会碰到一些常见陷阱：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"08"</span>); <span class="comment">// returns 0 部分老浏览器.</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"44.jpg"</span>); <span class="comment">// returns 44</span></span><br></pre></td></tr></table></figure>

<p><code>parseInt</code>: 没有传入基数时，默认是传入的基数为 10 <code>parseInt(num, 10)</code>，如果你不知道 num 属性的类型，不要使用 parseInt 进行字符串转数字。</p>
<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat"></a>parseFloat</h3><p>如果你不解析 16 进制数，这是一个非常好的选择。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">-0xff</span>); <span class="comment">// returns -255</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"-0xFF"</span>); <span class="comment">// returns -255</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">-0xff</span>); <span class="comment">// returns -255</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"-0xFF"</span>); <span class="comment">// returns 0</span></span><br></pre></td></tr></table></figure>

<p>注意：字符串中的负十六进制数字是一个特殊情况，如果你用 parseFloat 解析，结果是不正确的。为了避免程序出现 NaN 的情况，应该检查转化后的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"44.jpg"</span>); <span class="comment">// return 44</span></span><br></pre></td></tr></table></figure>

<p><code>parseFloat</code>: 转换十六进制数时要小心，如果你不知道要转换对象的类型，不要使用 parseFloat。</p>
<h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><p>可以把字符串转换成整数，但他不是浮点数。如果是一个字符串转换，它将返回 0；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">1.23</span>; <span class="comment">// returns 1</span></span><br><span class="line">~~<span class="string">"1.23"</span>; <span class="comment">// returns 1</span></span><br><span class="line">~~<span class="string">"23"</span>; <span class="comment">// returns 23</span></span><br><span class="line">~~<span class="string">"Hello world"</span>; <span class="comment">// returns 0</span></span><br></pre></td></tr></table></figure>

<p>这是什么原理？通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#.7E_(Bitwise_NOT)>" target="_blank" rel="noopener">翻转</a>每个位，也称为数字的 A1 补码。你可以使用它，但注意只能用来存储整数。所以通常情况不要用它，除非你能确定这个数是在 32 位整数之间的值（因为调用的 ToInt32 的规范）。</p>
<p><code>按位非</code>：用它确保输入中没有字符，仅用于整数。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number 与以上提及的转换方式一样存在这样的问题，解析时试图找出你给他的数字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"023"</span>); <span class="comment">// returns 23</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">023</span>); <span class="comment">// returns 19</span></span><br></pre></td></tr></table></figure>

<p>注意：023 实际上是一个八进制数，无论你怎么做，都是返回 19；和没有单引号或双引号的十六进制数一样。</p>
<p>Number 也是 性能最差的一个。</p>
<p><code>Number</code>：几乎不用它。</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1.23"</span> * <span class="number">1</span>; <span class="comment">// returns 1.23</span></span><br><span class="line"><span class="string">"0xFF"</span> - <span class="number">0</span>; <span class="comment">// returns 255</span></span><br><span class="line"><span class="string">"0xFF.jpg"</span> / <span class="number">1</span>  <span class="comment">// returns NaN</span></span><br><span class="line"> +<span class="string">"023"</span>; <span class="comment">// returns 23</span></span><br></pre></td></tr></table></figure>

<p>一元运算符与其它的解析方式不同，如果是一个 NaN 值，那么返回的也是 NaN 。这是我最喜欢的数值转换方式，因为我认为任何带有字符的对象都不应该被视为 0 或者根据他有多少位来“猜”。我基本使用 <code>+</code> 操作符，因为这个方式不容易混淆。虽然 <code>-0</code> 的用法也很好，但它并没有很好的表达转换为数字的本意。</p>
<h3 id="字符串转换为数字的方式总结"><a href="#字符串转换为数字的方式总结" class="headerlink" title="字符串转换为数字的方式总结"></a>字符串转换为数字的方式总结</h3><p>负十六进制数字符串转换为数字时。应首先将任何其转换为 String（例如通过 <code>+ &quot;&quot;</code> ），然后使用一元运算符或带基数的 parseInt 解析为数字。但是结果不是 NaN 的数值时，使用 parseFloat 更为合适。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/09/JavaScript设计模式与开发实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/09/JavaScript设计模式与开发实战/" class="post-title-link" itemprop="url">JavaScript设计模式与开发实战</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-09 22:09:44 / 修改时间：22:10:36" itemprop="dateCreated datePublished" datetime="2019-12-09T22:09:44+08:00">2019-12-09</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaScript设计模式与开发实战"><a href="#JavaScript设计模式与开发实战" class="headerlink" title="JavaScript设计模式与开发实战"></a>JavaScript设计模式与开发实战</h1><p><strong>系列文章：</strong></p>
<p><a href="https://juejin.im/post/5c0d15a3f265da612e2876a2" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》基础篇（1）—— this、call 和 apply</a></p>
<p><a href="https://juejin.im/post/5c0e670ce51d452e2c697955" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》基础篇（2）—— 闭包和高阶函数</a></p>
<p><a href="https://juejin.im/post/5c0f5ca4f265da616d540801" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（1）—— 单例模式</a></p>
<p><a href="https://juejin.im/post/5c0fc32ae51d455c9f4a3afc" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（2）—— 策略模式</a></p>
<p><a href="https://juejin.im/post/5c10ff28518825778a56cb3e" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（3）—— 代理模式</a></p>
<p><a href="https://juejin.im/post/5c11083de51d45702018aa47" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（4）—— 迭代器模式</a></p>
<p><a href="https://juejin.im/post/5c1261526fb9a049b221c1d1" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（5）—— 观察者模式</a></p>
<p><a href="https://juejin.im/post/5c1379cd6fb9a049c2325166" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（6）—— 命令模式</a></p>
<p><a href="https://juejin.im/post/5c163d045188252704369430" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（7）—— 组合模式</a></p>
<p><a href="https://juejin.im/post/5c179e446fb9a04a102f3317" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（8）—— 模板方法模式</a></p>
<p><a href="https://juejin.im/post/5c1902e751882546150aef0c" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（9）—— 享元模式</a></p>
<p><a href="https://juejin.im/post/5c1a37ca6fb9a049f8193cc8" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（10）—— 职责链模式</a></p>
<p><a href="https://juejin.im/post/5c1ee1d66fb9a049ab0d9af6" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（11）—— 中介者模式</a></p>
<p><a href="https://juejin.im/post/5c20f4566fb9a049b82a7a93" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（12）—— 装饰者模式</a></p>
<p><a href="https://juejin.im/post/5c23725bf265da61764aedc7" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（13）—— 状态模式</a></p>
<p><a href="https://juejin.im/post/5c237cb3518825444612dd2a" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》模式篇（14）—— 适配器模式</a></p>
<p><a href="https://juejin.im/post/5c261e9fe51d4570f1455253" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》原则篇（1）—— 单一职责原则</a></p>
<p><a href="https://juejin.im/post/5c282b8a51882538472091ba" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》原则篇（2）—— 最少知识原则</a></p>
<p><a href="https://juejin.im/post/5c2e0c3f6fb9a049c30b5f2d" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》原则篇（3）—— 开放-封闭原则</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://niuxinyu.github.io/niuxinyublog/niuxinyublog/2019/12/09/axios设置content-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Niu">
      <meta itemprop="description" content="文章">
      <meta itemprop="image" content="/niuxinyublog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="niu的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/niuxinyublog/2019/12/09/axios设置content-type/" class="post-title-link" itemprop="url">axios设置content-type</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-12-09 21:48:51 / 修改时间：22:06:22" itemprop="dateCreated datePublished" datetime="2019-12-09T21:48:51+08:00">2019-12-09</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="axios设置content-type"><a href="#axios设置content-type" class="headerlink" title="axios设置content-type"></a>axios设置content-type</h1><p>关键使用axios的步骤：</p>
<ol>
<li>创建axios的实例，这样能将公共配置放在这里，如<code>instance.js</code>，处理各种异常情况</li>
<li>每个api单独写好，多的话写个文件夹，相关的api可以写在一个文件里，少的话直接一个文件如<code>api.js</code></li>
<li>将api放在全局，这样使用的时候，无需引入，页面调接口的时候直接 <code>this.api.apiName()</code></li>
</ol>
<h2 id="必须先理解content-type"><a href="#必须先理解content-type" class="headerlink" title="必须先理解content-type"></a>必须先理解content-type</h2><p>get请求不存在设置<code>content-type</code>。只有post和put用到<code>content-type</code>，常用的post方式，所以这里着重说post。<br>post的content-type三种类型：</p>
<ul>
<li>Content-Type: application/json<br> 对于axios，post的时候<code>axios.post(url,{a:1,b:2})</code>，第二个参数是对象的时候，默认是这个类型</li>
<li>Content-Type: application/x-www-form-urlencoded<br> 对于axios，post的时候<code>let data = {a:1,b:2}; axios.post(url,qs.stringify({ data }))</code>，第二个参数是字符串的时候，默认是这个类型</li>
<li>Content-Type: multipart/form-data<br> 对于axios，post的时候<code>let data = new FormData(); data.append(&#39;a&#39;,1&#39;); data.append(&#39;b&#39;,2); axios.post(url,data)</code>，参数是formData类型的时候，默认是这个类型，如果用form自带的action提交，默认是这个类型</li>
</ul>
<p><strong>以上三种方式，服务器会以不同的方式解析，这点尤其注意！！！！！</strong></p>
<p>换言之，<code>content-type</code>会根据参数的类型会自动有对应的值，一般无需设置<del>~</del><br> 但是，有些情况是，我想传对象，但实际服务器需要的的是<code>application/x-www-form-urlencoded</code>，此时需要只需要统一设置请求前将参数变成字符串即可<code>transformRequest: [ function (data) { return Qs.stringify(data) } ],</code></p>
<p>此处小结，上面的解释多看几遍，我反射弧长，很久才大约明白到底说的啥。</p>
<h2 id="创建axios的实例"><a href="#创建axios的实例" class="headerlink" title="创建axios的实例"></a>创建axios的实例</h2><p>以下是示例代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * axios封装</span></span><br><span class="line"><span class="comment"> * 请求拦截、响应拦截、错误统一处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;    <span class="attr">timeout</span>: <span class="number">1000</span> * <span class="number">12</span>&#125;);</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 请求拦截器 </span></span><br><span class="line"><span class="comment"> * 每次请求前，如果存在token则在请求头中携带token </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">instance.interceptors.request.use(    </span><br><span class="line">    config =&gt; &#123;        </span><br><span class="line">        <span class="comment">// 这里可以加统一的参数，appid，token这类的</span></span><br><span class="line">    &#125;,    </span><br><span class="line">    error =&gt; <span class="built_in">Promise</span>.error(error)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">instance.interceptors.response.use(    </span><br><span class="line">    <span class="comment">// 请求成功</span></span><br><span class="line">    res =&gt; res.status === <span class="number">200</span> ? <span class="built_in">Promise</span>.resolve(res) : <span class="built_in">Promise</span>.reject(res),    </span><br><span class="line">    <span class="comment">// 请求失败</span></span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; response &#125; = error;</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">            <span class="comment">// 请求已发出，但是不在2xx的范围，一般会和后台确定一些错误码，处理错误</span></span><br><span class="line">            errorHandle(response.status, response.data.message);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 请求都没发出去</span></span><br><span class="line">            <span class="comment">// 处理断网的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">window</span>.navigator.onLine) &#123;</span><br><span class="line">               <span class="comment">// 断网做啥</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br></pre></td></tr></table></figure>

<h2 id="每个api单独写好"><a href="#每个api单独写好" class="headerlink" title="每个api单独写好"></a>每个api单独写好</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.js</span></span><br><span class="line"><span class="comment">// 以对象的形式传参，这样参数不需要考虑顺序的问题</span></span><br><span class="line"><span class="keyword">const</span> ajaxKeMuData = <span class="function">(<span class="params">&#123; wind, projectSname = <span class="string">""</span> &#125;</span>) =&gt;</span></span><br><span class="line">  instance.post(<span class="string">'/keMuXuBanRate'</span>, &#123;</span><br><span class="line">    wind,</span><br><span class="line">    projectSname</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    ajaxKeMuData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将api放在全局"><a href="#将api放在全局" class="headerlink" title="将api放在全局"></a>将api放在全局</h2><p>最后统一加在全局里，这边如果是vue的项目</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./api'</span> <span class="comment">// 导入api接口</span></span><br><span class="line">Vue.prototype.$api = api; <span class="comment">// 将api挂载到vue的原型上</span></span><br></pre></td></tr></table></figure>

<p>页面里调用的时候<code>this.$api.ajaxKeMuData({...}).then(...)</code></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这边写的很粗略，也还有些需要完善，很多细节请看<a href="https://juejin.im/post/5b55c118f265da0f6f1aa354#heading-10" target="_blank" rel="noopener">axios的好文章，特别是更新处</a></p>
<blockquote>
<p><a href="https://juejin.im/post/5b55c118f265da0f6f1aa354#heading-10" target="_blank" rel="noopener">axios的好文章，特别是更新处</a><br><a href="https://segmentfault.com/a/1190000015261229" target="_blank" rel="noopener">content-type的解释</a></p>
</blockquote>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/niuxinyublog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/niuxinyublog/">1</a><span class="page-number current">2</span><a class="page-number" href="/niuxinyublog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/niuxinyublog/page/6/">6</a><a class="extend next" rel="next" href="/niuxinyublog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Niu</p>
  <div class="site-description" itemprop="description">文章</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/niuxinyublog/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Niu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/niuxinyublog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/niuxinyublog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/niuxinyublog/js/utils.js?v=7.4.0"></script><script src="/niuxinyublog/js/motion.js?v=7.4.0"></script>
<script src="/niuxinyublog/js/schemes/muse.js?v=7.4.0"></script>
<script src="/niuxinyublog/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
